<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[var str = new string(string)问题]]></title>
    <url>%2Fnew_string%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[前几日，广州群有小伙伴遇到了这样一道面试题1var s = new string("abc");关于以上语句到底创建了几个对象呢？由于印象里这种使用 string 来初始化 string 的操作并不常见，推测以下，应该是类似于 copy 的操作产生一个新的对象，所以我先盲猜，不考虑有上下文，只针对这一句语句，应该是2个。下面来试验：定义string 属于引用类型，所以我们把单个 string 定义为堆中的对象，两个或多个引用类型变量引用同一个对象时，依然认为只有一个对象。分析文档分析首先，事实证明了不是我对 string 了解太少，而是被公司从策划 diss 了几次的升级计划导致我常用的 .NET Core 版本一直是 1.1 ，而用 string 初始化 string 的用法只有在 .NET Core 2.1 及以上版本才有，确切的说，只有 .NET Core 2.1、.NET Core 2.2、.NET Core 3.0 三个版本才有，以上结论来自官方文档并经过实际测试，文档如下：.NET Core 2.0 String Constructors.NET Core 2.1 String Constructors由官方文档可知，.NET Core 从 2.0 升级为 2.1 时，增加了一个构造函数String(ReadOnlySpan&lt;Char&gt;)题目中的 new(“qqq”)使用的正式这一构造函数，入参为 ReadOnlySpan&lt;Char&gt;结构体泛型，而这一类型也正是从 .NET Core 2.1 版本才新引入的。故，这一题目在 .NET Core 2.1 - .NET Core 3.0 版本成立，其余.NET 版本中均无法编译通过。源码分析下面开始直接代码寻找答案，查看 String.cs 源码1234567891011121314151617181920...[MethodImpl(MethodImplOptions.InternalCall)]public extern String(ReadOnlySpan&lt;char&gt; value);#if !CORECLRstatic#endifprivate unsafe string Ctor(ReadOnlySpan&lt;char&gt; value)&#123; if (value.Length == 0) return Empty; string result = FastAllocateString(value.Length); Buffer.Memmove(ref result._firstChar, ref MemoryMarshal.GetReference(value), (uint)value.Length); return result;&#125;...[MethodImpl(MethodImplOptions.AggressiveInlining)]public static implicit operator ReadOnlySpan&lt;char&gt;(string? value) =&gt; value != null ? new ReadOnlySpan&lt;char&gt;(ref value.GetRawStringData(), value.Length) : default;由官方源码可知，当入参为 string 时，首先会调用隐式转换方法将入参转换为ReadOnlySpan&lt;char&gt;类型，而后再使用转换后的值调用构造函数String(ReadOnlySpan&lt;char&gt; value)，构造函数中，重新分配了新的内存空间给新字符串，将入参的值 Copy 到新字符串后返回，所以该构造函数会产生一个全新的字符串值。测试测试代码以下是试验代码：1234567891011121314151617181920212223242526using System;using System.Runtime.InteropServices;namespace ConsoleApp1&#123; class Program &#123; static void Main(string[] args) &#123; string str0 = null; var str1 = new string("123"); var str2 = "123"; var str3 = str2; var str4 = "123"; Console.WriteLine($"&#123;GetMemoryAddress(str0)&#125; - &#123;GetMemoryAddress(str1)&#125; - &#123;GetMemoryAddress(str2)&#125; - &#123;GetMemoryAddress(str3)&#125; - &#123;GetMemoryAddress(str4)&#125;"); Console.WriteLine($"&#123;object.ReferenceEquals(str0,str1)&#125; - &#123;object.ReferenceEquals(str1,str2)&#125; - &#123;object.ReferenceEquals(str2,str3)&#125; - &#123;object.ReferenceEquals(str3,str4)&#125;"); Console.ReadKey(); &#125; private static string GetMemoryAddress(object o) =&gt; $"0x&#123;GCHandle.Alloc(o, GCHandleType.Pinned).AddrOfPinnedObject().ToString("X")&#125;"; &#125;&#125;输出结果为：IL代码由 IL 代码可知，的确是先调用了隐式转换函数，而后再使用转换后的值调用构造函数String(ReadOnlySpan&lt;char&gt; value)。结论这一题目在 .NET Core 2.1 - .NET Core 3.0 版本成立，其余.NET 版本中均无法编译通过。如果传入的字符串已在字符串常量池中，那么该语句只会产生一个新的 string 对象。如果传入的字符串未在字符串常量池中，那么该语句会产生两个新的string对象。]]></content>
      <categories>
        <category>面试笔记</category>
      </categories>
      <tags>
        <tag>string</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多益大学技术简单总结]]></title>
    <url>%2F%E5%A4%9A%E7%9B%8A%E5%A4%A7%E5%AD%A6%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[距离离职也有了大半个月，决定对整个大学项目开发的方方面面做一个简要总结。架构图总结大学的整体结构采用单体架构，整套架构是从传统三层架构+MVC扩展演进而来的，目前大部分页面都已经完成了前后端分离，目前大部分的业务代码都集中在BLL层。待解决的问题前后端分离不彻底描述系统已经做了前后端分离，现在的情况是，所有的模块都是SPA，但是SPA本身还是通过 MVC 渲染模式，Router由后端完成， View 进行渲染。拟解决把所有的单页整合到一个更大的单页里，把所有交互跳转都交给前端来做。将整个前端代码分离到另一个库，前端的发版交由前端自行完成，不再由后端统一维护。后端服务层耦合严重描述系统经历了两年，多代程序员的维护，业务层各个Service中代码耦合严重，导致维护难度很大，也几乎不可能直接向微服务架构迁移。拟解决把各个Service里的引用收束到服务实体本身，所有需要跟其他业务实体交互的部分，部封装一层聚合服务来解决，将整个程序的架构演进到“面向微服务的单体应用架构”。（截止到离职前用户部分已经完成）Wait…]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>某某大学</tag>
        <tag>工作经历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下DockerCE启用K8s报错kubernetes.docker.internal no such host]]></title>
    <url>%2FWindows%E4%B8%8BDockerCE%E5%90%AF%E7%94%A8K8s%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[踩坑在安装 Windows CE 之后，我尝试从设置菜单中启用Kubernetes，却一直处于 starting 状态不见好，查找位于 C:\ProgramData\DockerDesktop\service.txt 目录下的日志文件后，发现大片大片类似的错误日志：根据错误信息dial tcp: lookup kubernetes.docker.internal: no such host可知，错误的原因是无法解析到域名 kubernetes.docker.internal，随即开始寻找解决思路。寻求解决一（失败）首先我在 DockerCE for Windows 的 issue 看到JoseThen提出了如下解决方案：I was able to get this working even after restarting docker::Change DNS to fixed and use 8.8.8.8, this is within docker for window’s settingsRemove the .kubeAdd the KUBECONFIG environment variable to System Variables and have the path be C:\Users[MYUSER].kube\config. Note that before I had it set as a User Variable.Restart Docker from the Docker for Window’s reset tab in settings.Restart Kubernetes Cluster from the Docker for Window’s reset tab in settings (you can do this a number of times).Afterwards just wait for some time and Kubernetes is running should display.I hope this can help someone, this issue is a pain.查看之后发现 kube 的配置文件确实有配置这个路径clusters[0]&gt;server:https://kubernetes.docker.internal:6443 ，按照 JoseThen 的方法删除配置文件后重启，却并未成功解决，重新生成的文件中对应节点的值依然还是之前的地址，继续寻找解决思路。二之后我在 DockerCE for Mac 的 issue 看到了解决方案，原来 kubernetes.docker.internal 应该指向的就是本机，将12# Kubernetes127.0.0.1 kubernetes.docker.internal加入hosts之后即成功解决。效果]]></content>
      <categories>
        <category>踩坑笔记</category>
      </categories>
      <tags>
        <tag>DockerCE</tag>
        <tag>K8s</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[离职总结及未来一段时间的计划]]></title>
    <url>%2F%E7%A6%BB%E8%81%8C%E6%80%BB%E7%BB%93%E5%8F%8A%E6%9C%AA%E6%9D%A5%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E7%9A%84%E8%AE%A1%E5%88%92.html</url>
    <content type="text"><![CDATA[2019 年 9 月 20 日 15 时 58 分，我签下了离职证明和放行条，为我在广州多益网络股份有限公司 530 天的工作画上了句号。离职说实话，到现在我自己都还没有想清楚离职的准确原因，或许是因为察觉到自己在过去一年的反复又繁复的业务中并没有很大的长进却又不得不囿于加班文化，也没有足够的自学时间，或许是因为明明意识到系统架构的系统性问题，整体结构很需要重新划分，模块需要使用更合适的技术重构，却又在各种急促繁复的需求压迫下不得不无限妥协的无奈，或许是因为今年年中连续几个月平均加班到十一点的加班，或许是因为我和身边同事相比缩水一半的工资，也或许是前半年我跟领导提出了工资倒挂的情况希望能调整工资，却在几个月后，已经处于离职的边缘时才告诉我保证留下来才可以加薪，总之，我在听到加薪消息的隔天（2019 年 8 月 21 日 17 时 58 分）按下了辞职信的发送键，为这场旅途画下了句号。回顾过去的一年半，非常感谢廖总和蔡总能给我机会，让我这个后端门外汉以1.5年经验（实习一年 + 工作半年）的流媒体开发攻城师菜鸟的身份成功入职多益网络信息技术中心的 Web 后端开发一职，在多益的一年半里，我从一个后端菜鸟成功晋级为一个熟练码农，从原本一手全包的开发模式晋升到了前后端分离的团队开发模式，又从一个只管实现需求的人偶码农晋升为了能推敲需求，和策划为了我认为不合理的需求吵得脸红脖子粗的主程序员。我负责公司内部培训系统 “多益大学” 的后端开发工作，前半段和组里的同事一起完成了系统几个大模块的重构和新模块的开发，并于今年开始成功进一步接手多益大学全部后端工作后主导系统的开发，而后完成了统一考试、训练营重构、职级晋升等模块的开发，在职级晋升模块成功上限使用之后提出了离职，经历了半个月的继续开发之后交接离开。总结这段经历，总体来讲还是觉得受益匪浅，当初因为喜欢后端开发，喜欢比较新的技术，遂从上家公司的“流媒体/Windows桌面开发”岗位辞职，转而从事后端开发。说实话当时面试表现得确实比较差，非常感谢面试官能给我这个机会，也非常欣喜能在公司学习并实践喜欢的技术，总结离开的原因，同样也是因为较长的工作时间下没有足够的时间学习新的技术，急促反复的需求下也没有空间实践新的技能，我对此非常遗憾，但是也并不会感到后悔。接下来的计划接下来我打算先修整一段时间，预计 1-2 个月，然后对已有技能进行整合，结合就业市场需求的方向对一些新技术进行学习实践，经过深思熟虑之后再寻找新的就业机会。技能微服务读完《CLR via C#》、《C# 7.0 本质论》参与 NCC 的开源项目习惯按时进行睡眠洗漱等习惯的养成指定奖惩规则，记录执行情况减肥控制脂肪、糖类的摄入记录每天摄入的卡路里自己做减肥餐吃每天完成一定时长的健身理财记账理论学习读书列书单，记录读书情况大约保持每天半小时到一小时的阅读时长]]></content>
      <categories>
        <category>偶有所得</category>
      </categories>
      <tags>
        <tag>离职总结</tag>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇总一下 Visual Studio 各个版本的 Key]]></title>
    <url>%2F%E6%B1%87%E6%80%BB%E4%B8%80%E4%B8%8B-Visual-Studio-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84-Key.html</url>
    <content type="text"><![CDATA[方便日后查用，汇总一下 Visual Studio 各个版本的 Key。如果侵犯了您或您公司的权益，请联系我删除。Visual Studio 2019Visual Studio 2019 Enterprise:1BF8Y8-GN2QH-T84XB-QVY3B-RC4DFVisual Studio 2019 Professional:1NYWVH-HT4XC-R2WYW-9Y3CM-X4V3YVisual Studio 2017Visual Studio 2017 Professional:123456KBJFW-NXHK6-W4WJM-CRMQB-G3CDHHMGNV-WCYXV-X7G9W-YCX63-B98R2HFDVM-KS3K9-OKYN1-N1ZS7-PVSQ896OLO-CXFRC-16CKR-Y1933-04MX67VMX9-TI69C-NXRG0-S4T89-9ABS470I9S-MIZ6L-RPH8Q-Q9C70-XQPRTVisual Studio 2017 Enterprise:123456NJVYC-BMHX2-G77MM-4XJMR-6Q8QFIOX0M-LAVBL-FPHQY-N0ROK-9K3MD4SB42-1Q0ZT-CMBDT-TN2XI-FIET17Z16L-372ES-M15YD-O8QM7-V6C25EBVI7-26CXQ-3CQD4-ZS3IR-6Q3K57BHBQ-3NNHM-I4ROB-R7L02-ZOSFMVisual Studio 2017 Enterprise:123456NJVYC-BMHX2-G77MM-4XJMR-6Q8QFCXP3Q-XKCIN-GXDTX-O369X-ALFPKAF7CS-PO8AZ-YL4GI-C95BV-9QXCN643OA-ACK9A-8N2NH-6YB8R-1OM0X328DP-Y1I77-DXNCM-L3XVT-7M89BBNZLP-XK60H-MT0SG-2L790-Q87Z7Visual Studio 2015Visual Studio 2015 Enterprise:12XNFG-KFHR8-QV3CP-3W6HT-683CHVisual Studio 2015 Professional:1HMGNV-WCYXV-X7G9W-YCX63-B98R2Visual Studio 2013Visual Studio 2013 Ultimate:12BWG7X-J98B3-W34RT-33B3R-JVYW987DQC-G8CYR-CRPJ4-QX9K8-RFV2BVisual Studio 2013 Team Foundation Server:16T3MC-YX8XF-7CWXW-462TQ-8G2B4Visual Studio 2013 Premium:1FBJVC-3CMTX-D8DVP-RTQCT-92494Visual Studio 2013 Professional:1KCQWK-Q43V3-M3F2T-83VGV-Y6VTXVisual Studio 2013 Test Professional:1TTDB9-9YPYH-7FBVY-X2CTQ-D8F2HVisual Studio 2013 Premium &amp; Express:1P27TG-XXX2W-XK8TK-QD9FK-V36W4Visual Studio 2012Visual Studio 2012 Ultimate:1RBCXF-CVBGR-382MK-DFHJ4-C69G8Visual Studio 2012 Professional:14D974-9QX42-9Y43G-YJ7JG-JDYBPVisual Studio 2012 Premium:1MH2FR-BC9R2-84433-47M63-KQVWCVisual Studio 2010Visual Studio 2010 Ultimate:1YCFHQ-9DWCY-DKV88-T2TMH-G7BHP]]></content>
      <categories>
        <category>闹着玩儿</category>
      </categories>
      <tags>
        <tag>VS</tag>
        <tag>VisualStudio</tag>
        <tag>Key</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编写高质量C#程序的建议（6-10）]]></title>
    <url>%2F%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FCx%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BB%BA%E8%AE%AE%EF%BC%886-10%EF%BC%89.html</url>
    <content type="text"><![CDATA[建议六：区别 readonly 和 const 的区别建议七：将 0 作为枚举的默认值建议八：避免给枚举类型的元素提供显式的值建议九：习惯重载运算符建议十：创建对象时需要考虑是否实现比较器建议六：区别 readonly 和 const 的区别constconst 是一个编译期常亮，用使用 const 的理由只有一个，那就是效率。const只能修饰基元类型、枚举类型或字符串类型。经过编译器编译后，我们在代码中引用 const 变量的地方会用 const 变量 所对应的实际值来代替，如，以下两句 WriteLine 语句的 IL 代码是一致的：1234const int ConstValue = 100;Console.WriteLine(ConstValue);Console.WriteLine(100);readonlyreadonly 是运行时常量，修饰类型没有限制。readonly 常量的复制行为发生在运行时，它在运行时第一次被赋值后将不可改变。对于值类型，之本身不可改变。对于引用类型，引用本身（指针）不可改变。建议七：将 0 作为枚举的默认值这里的主要原因是出于0作为默认值时所具有的工程上的意义。原因参见以下代码：12345678910111213141516171819enum Week&#123; Monday = 1, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday&#125;class Program&#123; static Week week; static void Main(string[] args) &#123; Console.WriteLine(week); &#125;&#125;输出值会是超出枚举定义范围的 0。建议八：避免给枚举类型的元素提供显式的值一般情况下，没有必要给枚举类型的元素提供显式的值。创建枚举的理由之一，就是为了代替使用实际的数值。不正确的为枚举类型设定显式的值，会带来意想不到的错误。1234567891011enum Week&#123; Monday = 1, Tuesday = 2, TempValue， Wednesday = 3, Thursday = 4, Friday = 5, Saturday = 6, Sunday = 7&#125;枚举中，未显式指定的值会自动等于上一个值 +1，所以在这个枚举类型 Week 中，TempValue 和 Wednesday 的值均为 3 ，这会在实际业务中带来毁灭性的问题。123Week week= Week.TempValue；Console.WriteLine(week);Console.WriteLine(week == Week.Wednesday);输出：12WednesdayTrue建议九：习惯重载运算符如果业务意义上的加减乘除复制等运算，应该习惯于重载运算符，而不是使用普通方法。建议十：创建对象时需要考虑是否实现比较器有对象的地方就会存在比较，在 .NET 的世界中也一样。创建类型时需要根据业务上的可能性，考虑为类型实现 ICompareable 接口。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>高质量代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ListBox 扩展方法-获取所有Item构成的集合]]></title>
    <url>%2FListBox-%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95-%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89Item%E6%9E%84%E6%88%90%E7%9A%84%E9%9B%86%E5%90%88.html</url>
    <content type="text"><![CDATA[今天在实现一个小功能 “插入更新 ListBox 中的 Item ”时，发现 ListBox.Items 的类型 ListBox.ObjectCollection 实现了 IList, ICollection, IEnumerable三个接口，整体的方法已经非常接近一个数组，但是方便程度跟数据确实差距较大，Linq 也完全不能使用，故封装一个扩展方法实现直接获取 ListBox.Items中所储存的数据的集合。123456789101112131415161718192021222324252627using System;using System.Collections.Generic;using System.Linq;namespace System.Windows.Forms&#123; public static class ListBoxExtension &#123; /// &lt;summary&gt; /// 获取 ListBox.Items 中的数据构成的集合 /// &lt;/summary&gt; /// &lt;typeparam name="T"&gt;ListBox.Items中储存的数据的类型&lt;/typeparam&gt; /// &lt;param name="listbox"&gt;ListBox对象&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static List&lt;T&gt; GetItems&lt;T&gt;(this ListBox listbox) where T : class &#123; var items = new object[listbox.Items.Count]; listbox.Items.CopyTo(items, 0); var current = items.Select(i =&gt; i as T).Where(i =&gt; i != null).ToList(); if (listbox.Items.Count != current.Count) throw new Exception($"并非所有元素都为&#123;typeof(T).Name&#125;类型"); return current.ToList(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>踩坑笔记</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>WinForm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编写高质量C#程序的建议（1-5）]]></title>
    <url>%2F%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FCx%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BB%BA%E8%AE%AE%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content type="text"><![CDATA[最近开始阅读陆敏技先生在机械工业出版社出版的《编写高质量代码：改善C#程序的157个建议》一书，打算把其中涉及的所有的观点做一下总结和分析，用于总结和事后翻阅，如果有侵权请联系我删除。建议一：正确操作字符串确保尽量小的装箱在自己编写的代码中，应当尽可能地避免编写不必要的装箱代码。12var str1 = "str1" + 9;var str2 = "str2" + 9.ToString();第一句代码中，+ 连接时是将 值类型 int 转换为 引用类型 string 之后在进行 Concat 操作，故而性能更差。装箱之所以带来性能损耗的原因是，装箱需要以下三个步骤：首先，会为值类型在托管堆中分配内存。除了值类型本身所分配的内存外，内存总量还要加上类型对象指针和同步块索引所占用的内存。将值类型的值复制到新分配的堆内存中。返回已经成为引用类型的对象的地址。避免分配额外的内存空间频繁的进行字符串的拼接操作时，最好使用 StringBuilder，字符串的任何方法或者进行任何运算都会在内存中创建一个新的字符串对象。建议二：使用默认转型方法使用类型的转换运算符。使用类型内置的 Parse、TryParse，或者如 ToString、ToDouble 和 ToDateTime 等方法。使用帮助类提供的方法。使用 CLR 支持的转型建议三：区别对待强制转型与 as 和 is如果类型之间都上溯到了某个共同的基类，那么根据此基类进行的转型（即基类转型为子类本身）应该使用 as。子类与子类之间的转型，则应该提供转换操作符，以便进行强制转型。as 操作符永远不会抛出异常，如果类型不匹配则会返回 null。as 不能操作基元类型，如果涉及基元类型的算法，就需要通过 is 转型前的类型进行判断，以避免转型失败。C# 7.0 中提供了 is 的新语法，以下两个方法其实是完全等价的：123456789101112public void A2(object obj)&#123; var str = obj as string; if (str != null) Console.WriteLine(str);&#125;public void A3(object obj)&#123; if (obj is string str) Console.WriteLine(str);&#125;建议四： TryParse 比 Parse 好Parse 和 TryParse 如果执行成功，他们的效率在一个数量级上，但如果执行失败，Parse 方法在转化失败的时候会引发异常，极大地消耗效率，而 TryParse 并不会。建议五： 使用 int? 来确保值类型也可以为 null业务需求中，int 类型的字段在无意义时在业务上为 null 比它的默认值 0 更为合适。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>高质量代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于租房到期离职纠结]]></title>
    <url>%2F%E5%85%B3%E4%BA%8E%E7%A7%9F%E6%88%BF%E5%88%B0%E6%9C%9F%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[缘起去年4月8日换工作时租的 Loft 公寓即将到期，而决定续租与否或是租在哪里的最重要的因素无疑就是要不要换工作，遂写一篇博客辅助分析。换 ~租房合同即将到期我现在租住的是一间复式的 Loft 公寓，去年 4月8日 签了为期一年的合同，月租1850。到今天已经询问过续租价格为2400，涨幅30%。995 确实是对人性的很大磨损。现在的作息基本就是周日晚上到周五晚上每天九点半以后到家，看会儿电视，逛逛论坛，再翻几页书，基本就到了十二点，再坐一些杂七杂八的事，到洗漱完成睡觉大约就是一点到两点了，八点左右起床，洗漱、喝咖啡，上班。如此往复，到周末确实是极累的，周末作息基本就是中午起床，晚上依然是一两点睡觉。这套作息带来的问题有：自我提升的时间较少。厌恶社交，越来越宅。（租住地偏远，外出社交成本至少是一小时以上的地铁）工作内容重复，温水煮青蛙我所在的项目组属于公司里支撑部门，用于内部培训，各种内部考核、人才培训相关的需求都会转到组里，需求迭代非常快，经常有紧急需求需要处理，所以大部分时间都是各种重复度很高的业务接口，很多技术框架的调整一直想要做，却没有足够的时间。项目到现在已经经历了两年多，底层框架是较为成熟的老框架，有些问题需要更换框架才能解决，但是时间不足。现在的工作模式是前后端分离，我作为后端开发的主要工作就是约定、完成接口，重复度极高。起薪低带来的未来不可期之前所在的公司是从实习期起一直就职的，故而没有积累到这方面的经验。去年四月跳槽到现在的公司属于技术转型，因为刚开始从事后端工作，没有足够的经验，故而起薪很低。到年底统一调薪之后暗示直系领导无果之后，我才意识到，起薪真的是非常重要。有资格上调薪资的领导和我中间隔了一层，一般没办法直接接触到，故而领导主动注意到我的成绩并且我调整薪水基本不可能，剩下的机会就只有统一调薪，而统一调薪基本就属于“侮辱性普调”。我现在是组里的主程序员，我带着一位去年入职的校招生。虽然没有主动去了解过校招的工资，但是也大概知道他们的薪资范围，就目前的统一调薪频率来看，如果他们薪资一直不变，我大约再过两年才能有他们现在的工资。总结995虽然是很累，不过在行业里也不算压力最大的，工作重复也其实是大部分工作的特点，或许凑巧遇到合适的工作，这两点也能够有改进，但现在的情况也不是完全不能忍受。我也在主动调整作息，用一些碎片时间进行自我提升。目前房租的剧烈变化和薪水的不可期是我想要换工作最重要的原因。不换 ~主程的技术自由去年下半年做了项目组的主程，技术上有很大的自由性，虽然现在的业务压力确实很忙，但未来的一段时间内应该也有一些机会对我私下抽空研究的一些技术做一些时间。工作年限不高就业自由度低工作年限较低，很多工作对年限的要求都未能达到。总结目前的打算是，先租一间便宜一些的公寓，未来半年内裸辞寻觅新的工作。]]></content>
      <categories>
        <category>闹着玩儿</category>
      </categories>
      <tags>
        <tag>租房</tag>
        <tag>离职</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何判定一个类型支不支持 await 异步等待(代码)]]></title>
    <url>%2F%E5%A6%82%E4%BD%95%E5%88%A4%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E6%94%AF%E4%B8%8D%E6%94%AF%E6%8C%81%E5%BC%82%E6%AD%A5.html</url>
    <content type="text"><![CDATA[最近由于一些业务上的需求,需要在 OnActionExcutionAsync 和 OnActionExcuted 中判断当前请求的接口是否是异步的接口，刚好前几天看过吕毅大佬的文章《.NET 中什么样的类是可使用 await 异步等待的？》，遂封装实现一下判断类型是否为可等待类型的方法。理论总结起来，要想使一个方法可被 await 等待，必须具备以下条件：这个方法返回一个类 A 的实例，这个类 A 必须满足后面的条件。此类 A 有一个可被访问到的 GetAwaiter 方法（扩展方法也行，这算是黑科技吗？），方法返回类 B 的实例，这个类 B 必须满足后面的条件；此类 B 实现 INotifyCompletion 接口，且拥有 bool IsCompleted { get; }属性、GetResult() 方法、void OnCompleted(Action continuation)方法。第三点中，OnCompleted方法本身就是 INotifyCompletion 接口要求实现的，所以只需要校验前三点即可。实践按照要求封装以下扩展方法：123456789101112131415161718192021222324using System.Linq;using System.Reflection;namespace System&#123; public static class ReflectionExtension &#123; public static bool IsAsyncType(this Type type) &#123; var awaiter = type.GetMethod("GetAwaiter"); if (awaiter == null) return false; var retType = awaiter.ReturnType; //.NET Core 1.1及以下版本中没有 GetInterface 方法，为了兼容性使用 GetInterfaces if (retType.GetInterfaces().All(i =&gt; i.Name != "INotifyCompletion")) return false; if (retType.GetProperty("IsCompleted") == null) return false; if (retType.GetMethod("GetResult") == null) return false; return true; &#125; &#125;&#125;借用大佬博客中的测试类：1234567891011121314151617181920212223class Program&#123; static void Main(string[] args) &#123; Console.WriteLine(typeof(Test).IsAsyncType()); Console.ReadLine(); &#125;&#125;public class Test&#123; public Test2 GetAwaiter() &#123; return new Test2(); &#125;&#125;public class Test2 : INotifyCompletion&#123; public bool IsCompleted &#123; get; &#125; public void GetResult() &#123; &#125; public void OnCompleted(Action continuation) &#123; &#125;&#125;在 OnActionExcutionAsync 和 OnActionExcuted 中的使用在 OnActionExcutionAsync 和 OnActionExcuted 中使用时，可以再封装一层扩展方法，方便直接使用事件中的上下文实例调用。12public static bool IsAsyncAction(this FilterContext context) =&gt; ((ControllerActionDescriptor) context.ActionDescriptor).MethodInfo.ReturnType.IsAsyncType();调用方式：12345678910111213141516public override void OnActionExecuted(ActionExecutedContext context)&#123; if (context.IsAsyncAction()) Console.WriteLine("Current action is support async.");&#125;public override void OnActionExecuting(ActionExecutingContext context)&#123; if (context.IsAsyncAction()) Console.WriteLine("Current action is support async.");&#125;public override Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next)&#123; if (context.IsAsyncAction()) Console.WriteLine("Current action is support async."); return base.OnActionExecutionAsync(context, next);&#125;以上↑]]></content>
      <categories>
        <category>踩坑笔记</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>反射</tag>
        <tag>await</tag>
        <tag>异步等待</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聚会合租选点：计算距离多个地铁站点综合时间最少的聚会地点]]></title>
    <url>%2F%E8%81%9A%E4%BC%9A%E5%90%88%E7%A7%9F%E9%80%89%E7%82%B9%EF%BC%9A%E8%AE%A1%E7%AE%97%E8%B7%9D%E7%A6%BB%E5%A4%9A%E4%B8%AA%E5%9C%B0%E7%82%B9%E7%BB%BC%E5%90%88%E6%97%B6%E9%97%B4%E6%9C%80%E5%B0%91%E7%9A%84%E8%81%9A%E4%BC%9A%E5%9C%B0%E7%82%B9.html</url>
    <content type="text"><![CDATA[缘起五人小组的聚会由于最初不知为何定在了体育中心、体育西一带，之后一直延续这个传统，鉴于前几次的聚会高度重复，聚会体验越来越差，便起了一个想法：为什么不做一个小工具来计算相对几位参与人居住地点最划算的聚会地点呢？分析在各大地图APP上都有提供各种行程规划的功能，但是利用这个功能来完成预期的业务希望是相当繁琐的，而这个功能如果要自己实现，需要得到的数据就是地铁路线图上任意两个点之间所需要的时间、购票费用等数据。经过在网上的搜寻，我最终决定的数据来源方案为百度开放平台中的地铁图JS API抓取关键数据在源代码编辑器中将调试的城市名称改为＇广州＇，点击编辑器右上角的运行按钮，在调试窗口中就能找到相关的API请求，所有地铁站数据都可以在这次请求中获得。 实体类:12345678910111213public class Line&#123; public string Name &#123; get; set; &#125; public List&lt;Station&gt; Stations &#123; get; set; &#125; = new List&lt;Station&gt;();&#125;public class Station&#123; public string Name &#123; get; set; &#125; public string UId &#123; get; set; &#125; public List&lt;string&gt; Lines &#123; get; set; &#125;&#125;将Json数据解析转换为实体类型并保存到文件中1234567891011121314151617181920var jobject = JsonHelper.DeserializeObject(json);foreach (var l in jobject["subways"]["l"])&#123; var line = new Line &#123; Name = l["l_xmlattr"]["lb"].Value&lt;string&gt;() &#125;; foreach (var p in l["p"]) &#123; var pname = p["p_xmlattr"]["lb"].Value&lt;string&gt;(); if (!string.IsNullOrWhiteSpace(pname) &amp;&amp; p["p_xmlattr"]["uid"] != null) line.Stations.Add(new Station &#123; Name = pname, Lines = p["p_xmlattr"]["lb"].Value&lt;string&gt;().Split(',').Select(s =&gt; s.Substring(s.IndexOf("|") + 1)).ToList(), UId = p["p_xmlattr"]["uid"].Value&lt;string&gt;() &#125;); &#125; Lines.Add(line);&#125;File.WriteAllText("Data/line.json", Lines.ToFormatedJsonString());那么接下来我们就要获取两点之前的数据的方法：同样，我们找到了页面请求这个数据的API经测试，只要将圈中的数据替换为响应站点的UID和Name，即可获取到相应的数据。实体类:12345678910public class TwoStationInfo&#123; public string[] TwoStationNames &#123; get; set; &#125; public int Distance &#123; get; set; &#125; public int Price &#123; get; set; &#125; public int SubwayPrice &#123; get; set; &#125; public int Time &#123; get; set; &#125; public int WalkDistance &#123; get; set; &#125; public int WalkTime &#123; get; set; &#125;&#125;抓取:123456789101112131415161718192021222324252627282930313233343536373839var stationsList = Lines.Select(l =&gt; l.Stations);var stations = new List&lt;Station&gt;();foreach (var ss in stationsList) stations.AddRange(ss);var client = new HttpClient();for (var i = 0; i &lt; stations.Count; i++)&#123; for (var j = 0; j &lt; stations.Count; j++) &#123; if (i == j) continue; if (TwoStationInfos.Any(ts =&gt; ts.TwoStationNames.Contains(stations[i].Name) &amp;&amp; ts.TwoStationNames.Contains(stations[j].Name))) continue; var result = await client.GetStringAsync( $"https://api.map.baidu.com/?qt=bt2&amp;newmap=1&amp;ie=utf-8&amp;f=%5B1,12,13,14%5D&amp;c=257&amp;sn=0$$&#123;stations[i].UId&#125;$$undefined,undefined$$&#123;stations[i].Name&#125;$$&amp;en=0$$&#123;stations[j].UId&#125;$$undefined,undefined$$&#123;stations[j].Name&#125;$$&amp;m=sbw&amp;ccode=257&amp;from=dtzt&amp;sy=0&amp;t=1552814046118&amp;callback=BMapSub._rd._cbk22197"); var index = result.IndexOf('&#123;'); result = result.Substring(index, result.Length - index - 1); var jResult = JsonHelper.DeserializeObject(result); if (jResult["content"] == null) continue; var two = new TwoStationInfo &#123; Time = jResult["content"][0]["exts"][0]["time"].Value&lt;int&gt;(), Distance = jResult["content"][0]["exts"][0]["distance"].Value&lt;int&gt;(), Price = jResult["content"][0]["exts"][0]["price"].Value&lt;int&gt;(), SubwayPrice = jResult["content"][0]["exts"][0]["subway_price"].Value&lt;int&gt;(), WalkDistance = jResult["content"][0]["exts"][0]["walk_distance"].Value&lt;int&gt;(), WalkTime = jResult["content"][0]["exts"][0]["walk_time"].Value&lt;int&gt;(), TwoStationNames = new[] &#123; stations[i].Name, stations[j].Name &#125; &#125;; TwoStationInfos.Add(two); Console.WriteLine($@"&#123;stations[i].Name&#125; =&gt; &#123;stations[j].Name&#125;"); &#125;&#125;File.WriteAllText("Data/info.json", TwoStationInfos.ToFormatedJsonString());最终得到了所有数据，$C_{224}^2$ 大约25000条：计算得到了数据，那计算就只是体力活了，计算代码如下：123456789101112131415161718192021var strs = listBox1.Items.Cast&lt;string&gt;().ToList();var routeInfos = StationNames.Select(n =&gt; GetRouteInfo(strs, n)).ToList();var minTime = routeInfos.Min(r =&gt; r.Routes.Sum(rr =&gt; rr.Time + rr.WalkTime));var minTimeRoute = routeInfos.First(r =&gt; r.Routes.Sum(rr =&gt; rr.Time + rr.WalkTime) == minTime);var minPrice = routeInfos.Min(r =&gt; r.Routes.Sum(rr =&gt; rr.Price));var minPriceRoute = routeInfos.First(r =&gt; r.Routes.Sum(rr =&gt; rr.Price) == minPrice);textBox3.Clear();textBox3.AppendText($"综合耗时最短：&#123;minTimeRoute.DestStation&#125; 耗时: &#123;Second2Chs(minTime)&#125; \r\n其中地铁时间: &#123;Second2Chs(minTimeRoute.Routes.Sum(rr =&gt; rr.Time))&#125; 步行时间:&#123;Second2Chs(minTimeRoute.Routes.Sum(rr =&gt; rr.WalkTime))&#125;\r\n\r\n");foreach (var info in minTimeRoute.Routes) textBox3.AppendText( $"&#123;info.TwoStationNames[1]&#125;=&gt;&#123;info.TwoStationNames[0]&#125; 耗时: &#123;Second2Chs(info.Time + info.WalkTime)&#125; \r\n其中地铁时间: &#123;Second2Chs(info.Time)&#125; 步行时间:&#123;Second2Chs(info.WalkTime)&#125; \r\n");textBox3.AppendText($"\r\n\r\n");textBox3.AppendText($"综合花费最少：&#123;minPriceRoute.DestStation&#125; 花费：&#123;minPrice/100.0&#125; \r\n\r\n");foreach (var info in minPriceRoute.Routes) textBox3.AppendText( $"&#123;info.TwoStationNames[1]&#125;=&gt;&#123;info.TwoStationNames[0]&#125; 花费: &#123;info.Price / 100.0&#125; \r\n");运行结果截图:代码：包含已抓取到的数据结论首先，软件还比较粗糙，只是简单地数据计算筛选，结果只能做参考。同样也可以用于在不同地点工作的人寻找合租的地点，但在这个应用中缺少权值计算，而且往往时间最短的地点都坐落于两条或者多条线的交界处，通勤时的等待时间往往也比较长。以后考虑为每个地点增加一些美食指数之类的多维度权值，可以按照不同需求求出最优解。]]></content>
      <categories>
        <category>闹着玩儿</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>广州地铁</tag>
        <tag>聚会</tag>
        <tag>合租</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用不安全代码 + 反射修改 String.Empty 的值]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%AE%89%E5%85%A8%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9-String.Empty-%E7%9A%84%E5%80%BC.html</url>
    <content type="text"><![CDATA[前几天的时候看到了 吕毅 大佬写的博客为什么 C# 的 string.Empty 是一个静态只读字段，而不是一个常量呢？，非常感谢吕毅大佬的分享，在文章的末尾大佬提到了通过反射修改 String.Empty 的可能，于是我打算自己实践一下。反射修改首先上一个我自己封装的 ReflectionExtension 类，方便直接进行反射操作（这里只展示部分代码，完整代码会附上下载链接）12345678910111213141516171819202122namespace System.Reflection&#123; public static class ReflectionExtension &#123; public const BindingFlags Flags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance | BindingFlags.DeclaredOnly; /// &lt;summary&gt; /// 通过反射设置字段的值 /// &lt;/summary&gt; /// &lt;param name="instance"&gt;&lt;/param&gt; /// &lt;param name="fieldName"&gt;字段名称&lt;/param&gt; /// &lt;param name="value"&gt;要修改为的值&lt;/param&gt; public static void SetField(this object instance, string fieldName, object value) &#123; var type = instance.GetType(); var field = type.GetField(fieldName) ?? type.GetField(fieldName, Flags); field?.SetValue(instance, value); &#125; &#125;&#125;新建项目的框架为 .NET Framework 3.5，使用以下代码完成反射修改 String.Empty ：12345678910111213static void Main(string[] args)&#123; Console.WriteLine($"Empty : &#123;string.Empty&#125;"); string.Empty.SetField("m_stringLength", 3); "".SetField("Empty","CBA"); Console.WriteLine($"Empty Reflection : &#123;string.Empty&#125;"); Console.ReadLine();&#125;运行结果如图：有效!查看一下 String.cs 的源码.NET Framework 3.5 以下版本中的 String.Empty 就是一个普通的共有只读字段。下面将框架版本升级到 4.0 以上再次尝试：同样的方法在 4.0 以上的版本就行不通了，转到源码看一下：String.Empty 上增加了 __DynamicallyInvokable Attribute，查找资料:12345678910111213141516171819// Each blessed API will be annotated with a "__DynamicallyInvokableAttribute".// This "__DynamicallyInvokableAttribute" is a type defined in its own assembly.// So the ctor is always a MethodDef and the type a TypeDef.// We cache this ctor MethodDef token for faster custom attribute lookup.// If this attribute type doesn't exist in the assembly, it means the assembly// doesn't contain any blessed APIs.Type invocableAttribute = GetType("__DynamicallyInvokableAttribute", false);if (invocableAttribute != null)&#123; Contract.Assert(((MetadataToken)invocableAttribute.MetadataToken).IsTypeDef); ConstructorInfo ctor = invocableAttribute.GetConstructor(Type.EmptyTypes); Contract.Assert(ctor != null); int token = ctor.MetadataToken; Contract.Assert(((MetadataToken)token).IsMethodDef); flags |= (ASSEMBLY_FLAGS)token &amp; ASSEMBLY_FLAGS.ASSEMBLY_FLAGS_TOKEN_MASK;&#125;根据注释中的介绍，这个特性只是某种用于提升速度的标记，看来大约是跟 CLR 有关，与这个 Attribute 并没有什么关系。不安全代码下面加入不安全代码，使用指针来实现我们的设置 String.Empty 。首先打开项目属性，设置生成中的允许不安全代码选项代码：12345678910111213141516171819202122232425using System.Reflection;namespace System&#123; public static class StringHelper &#123; /// &lt;summary&gt; /// 使用反射 + 不安全代码直接修改 string 的值 /// &lt;/summary&gt; /// &lt;param name="str"&gt;原始字符串&lt;/param&gt; /// &lt;param name="newStr"&gt;新字符串&lt;/param&gt; public static unsafe void SetValue(this string str, string newStr) &#123; //使用反射设置字符串的长度属性 str.SetField("m_stringLength", newStr.Length); //指针大法好 fixed (char* pe = str) &#123; for (var i = 0; i &lt; newStr.Length; i++) pe[i] = newStr[i]; pe[newStr.Length] = '\0'; &#125; &#125; &#125;&#125;在 .NET Framework 4.7.2 下重新运行下面的测试代码12345678910111213141516static void Main(string[] args)&#123; Console.WriteLine($"Empty : &#123;string.Empty&#125;"); string.Empty.SetField("m_stringLength", 3); "".SetField("Empty","CBA"); Console.WriteLine($"Empty Reflection : &#123;string.Empty&#125;"); string.Empty.SetValue("ABC"); Console.WriteLine($"Empty Unsafe : &#123;string.Empty&#125;"); Console.ReadLine();&#125;不安全代码可以在最新版 Framework 上实现修改 String.Empty。总结在各个平台下运行测试代码，结论如下：平台反射不安全代码.NET Framework 1.0 - 3.5√√.NET Framework 4.0 - 4.7.2×√.NET Core 1.0 - 2.0×√.NET Core 2.1 - 2.2××.NET Core 3.0 previewFieldAccessExceptionCannot set initonly static field ‘Empty’ after type ‘System.String’ is initialized.×]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>反射</tag>
        <tag>unsafe</tag>
        <tag>String.Empty</tag>
        <tag>不安全代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次失败平衡车破解提速之旅]]></title>
    <url>%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8B%E6%97%85.html</url>
    <content type="text"><![CDATA[记录为期一天的失败破解之旅．缘起最近突然觉得手头的 Ninebot 平衡车速度是确实有几分慢了，想起了刚买到手的时候似乎在论坛看到过一篇帖子是讲如何破解速度上限的，拼着几丝印象找到了当时的帖子：传送门帖子里描述的方法是使用 JLink V8 之类的 ARM模拟器把网友编写的固件刷入主板，对于我一个手残来说，首先是硬件成本，从 JLink ，到铜线、引脚，再到电烙铁和焊锡全都要新买，另外虽然不用担心刷固件把车子搞坏，但是万一手残把主板焊坏，那就死定了。向下翻打算借鉴一下经验看要买哪一款模拟器的时候，发现了一位坛友的分享：咦，居然还有这么清真的方式？虽然不算便宜，但是两百以内也完全可以接受，关键是，不用拆机，省了不少事儿，就顺着这条线继续往下查，找到了这篇帖子：简单看了一下，安卓软件，需要购买 License ，三十刀，界面相当简洁。To change the model, you need an activation code, you can get it from me, you need to send a screenshot of the program screen on the example as in the screenshot below.看来 License 是根据读取了设备的三个 key 和 Sn 经由某种算法计算出来的，一台设备对应一个 License。遂安装到手机试了试，交互十分简单，点击 Set Model 的时候会触发授权码校验。至此，突然萌生了一丝侥幸，这么简陋，我是不是可以自学一下安卓逆向，把它破解掉呢？准备工作首先测试了一下交互，校验失败会直接弹出提示，内容里会包含文本框里的内容。然后抓包尝试了一下，发现校验完全是本地操作，并无在线校验。学习之前在学校的时候简单研究过一些逆向分析的知识，对 .NET 的逆向分析研究多一些，当时学习主要是在吾爱破解，现在想要学安卓逆向，同样也是到吾爱找了一套教程，大佬为兄弟写的一套教程《教我兄弟学Android逆向》。实战祭出 Android Killer :分析主界面的代码 FMXNativeActivity.smali :1234567.field private mStartupGCM:Landroid/os/Bundle;.field private mTextView:Lcom/embarcadero/firemonkey/text/FMXTextEditorProxy;.field private mViewGroup:Landroid/view/ViewGroup;.field private mViewStack:Lcom/embarcadero/firemonkey/ViewStack;1.method public surfaceCreated(Landroid/view/SurfaceHolder;)V1.method public surfaceDestroyed(Landroid/view/SurfaceHolder;)V噗~~~我的天。。。界面的代码里根本没有控件的渲染和事件，有种不祥的预感，再一看 lib 文件夹下：祭出 IDA ：字符串窗口来看，控件逻辑果然是在 so 文件中，再看到处窗口：只有两个校验失败的方法。。。至此。。我大概意识到我的半吊子功夫是搞不定了，也意识到看似简单的界面，实则是作者早有防备。]]></content>
      <categories>
        <category>闹着玩儿</category>
      </categories>
      <tags>
        <tag>安卓</tag>
        <tag>逆向</tag>
        <tag>破解</tag>
        <tag>Ninebot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash脚本错误 Syntax error: else unexpected (expecting then)解决]]></title>
    <url>%2Fbash%E8%84%9A%E6%9C%AC%E9%94%99%E8%AF%AF-Syntax-error-else-unexpected-(expecting-then-)%E8%A7%A3%E5%86%B3.html</url>
    <content type="text"><![CDATA[今天在使用 bash 脚本发布程序时，发生了这样的错误1xxx.sh: Syntax error: "else" unexpected (expecting "then")到处搜索资料尝试无果之后想到会不会是编码问题导致，dos2unix 处理后测试果然可以1sudo apt-get -y install dos2unix处理12dos2unix xxx.shdos2unix: converting file xxx.sh to Unix format ...]]></content>
      <categories>
        <category>踩坑笔记</category>
      </categories>
      <tags>
        <tag>踩坑</tag>
        <tag>编码</tag>
        <tag>dos2unix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【微服务学习】Polly：熔断降级组件]]></title>
    <url>%2Fx%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0xPolly%EF%BC%9A%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7%E7%BB%84%E4%BB%B6.html</url>
    <content type="text"><![CDATA[何为熔断降级“熔断器如同电力过载保护器。它可以实现快速失败，如果它在一段时间内侦测到许多类似的错误，会强迫其以后的多个调用快速失败，不再访问远程服务器，从而防止应用程序不断地尝试执行可能会失败的操作，使得应用程序继续执行而不用等待修正错误，或者浪费时间去等到长时间的超时产生。”降级的目的是当某个服务提供者发生故障的时候，向调用方返回一个替代响应。简单一句话概括，降级就是在调用的下游服务A出现问题（常见超时），提供PLAN-B，返回的效果可能没有服务A好，但是聊胜于无。而熔断器的存在就是要保障何时走到降级方法，何时恢复，以什么样的策略恢复。.NET Core 熔断降级实践简介Polly是一种.NET弹性和瞬态故障处理库，允许我们以非常顺畅和线程安全的方式来执诸如行重试，断路，超时，故障恢复等策略。Polly当前版本可以工作在 .NET Standard 1.1 (包括: .NET Framework 4.5-4.6.1, .NET Core 1.0, Mono, Xamarin, UWP, WP8.1+) 和 .NET Standard 2.0+ (包括: .NET Framework 4.6.1, .NET Core 2.0+, 新版本的 Mono, Xamarin and UWP targets).上，同时也为旧版本的.NET Framework提供了一些可用的旧版本，具体版本对应如下：目标框架最低适配版本最高适配版本.NET&nbsp;Standard&nbsp;2.1for use with IHttpClientFactory6.0.1Current.NET&nbsp;Standard&nbsp;2.0 (dedicated&nbsp;target)6.0.1Current.NET&nbsp;Standard&nbsp;2.05.0.3 via .Net&nbsp;Standard&nbsp;1.0 (upward compatible)Current.NET&nbsp;Standard&nbsp;1.15.0.3 via .Net&nbsp;Standard&nbsp;1.0 (upward compatible)Current.NET&nbsp;Standard&nbsp;1.05.0.35.1.0.NET&nbsp;Framework&nbsp;4.51.0.0Current&nbsp;(via&nbsp;.Net&nbsp;Standard);5.9.0&nbsp;(as&nbsp;dedicated&nbsp;target).NET&nbsp;Framework&nbsp;4.0with Async support4.2.25.9.0.NET&nbsp;Framework&nbsp;4.01.0.05.9.0.NET&nbsp;Framework&nbsp;3.51.0.04.3.0Various PCL targets2.0.0Current&nbsp;(via&nbsp;.Net&nbsp;Standard);4.3.0&nbsp;(as&nbsp;dedicated&nbsp;PCL&nbsp;target)该项目作者现已成为.NET基金会一员，项目一直在不停迭代和更新，项目地址【https://github.com/App-vNext/Polly】。七种恢复策略策略前置条件例此策略解决什么问题?重试策略（Retry）(policy family)(快速开始&nbsp;;&nbsp;深入学习)重试策略针对的前置条件是短暂的故障延迟且在短暂的延迟之后能够自我纠正。“也许这只是昙花一现”允许我们做的是能够自动配置重试机制。断路器（Circuit-breaker）(policy family)(快速开始&nbsp;;&nbsp;深入学习)断路器策略针对的前置条件是当系统繁忙时，快速响应失败总比让用户一直等待更好。保护系统故障免受过载，Polly可以帮其恢复。“痛了，自然就会放下”“让它歇一下”当故障超过某个预先配置的阈值时, 中断电路 (块执行) 一段时间。超时（Timeout）(快速开始&nbsp;;&nbsp;深入学习)超时策略针对的前置条件是超过一定的等待时间，想要得到成功的结果是不可能的。“你不必等待，她不会再来”保证调用者不必等待太长时间。隔板隔离（Bulkhead Isolation）(快速开始&nbsp;;&nbsp;深入学习)隔板隔离针对的前置条件是当进程出现故障时，多个失败一直在主机中对资源（例如线程/ CPU）一直占用。下游系统故障也可能导致上游失败。这两个风险都将造成严重的后果。“一颗老鼠屎坏了一锅汤”将受管制的操作限制在固定的资源池中，避免其他资源受其影响。缓存（Cache）(快速开始&nbsp;;&nbsp;深入学习)数据不会很频繁的进行更新，相同请求的响应是相似的。“听说你还会再来我翘首以盼”首次加载数据时将响应数据进行缓存，请求时若缓存中存在则直接从缓存中读取。回退（Fallback）(快速开始&nbsp;;&nbsp;深入学习)操作将仍然失败 - 但是你可以实现准备好失败后要做的补救措施。“你若安好，我备胎到老。”定义失败时要返回 (或要执行的操作) 的替代值。.策略包装（PolicyWrap）(快速开始&nbsp;;&nbsp;深入学习)不同的故障需要不同的策略，也就意味着弹性灵活使用组合。“谋定而后动”允许灵活地组合上述任何策略。实践故障处理（被动策略）故障处理策略处理通过策略执行的代码所引发的特定的异常或返回结果。第一步：指定希望处理的异常（可选-指定要处理的返回结果）指定希望处理的异常：12345678910111213141516171819202122// 单一异常种类Policy .Handle&lt;HttpRequestException&gt;()// 带条件判断的单一异常Policy .Handle&lt;SqlException&gt;(ex =&gt; ex.Number == 1205)// 多种异常Policy .Handle&lt;HttpRequestException&gt;() .Or&lt;OperationCanceledException&gt;()// 带条件判断的多种异常Policy .Handle&lt;SqlException&gt;(ex =&gt; ex.Number == 1205) .Or&lt;ArgumentException&gt;(ex =&gt; ex.ParamName == "example")// 普通异常或聚合异常的内部异常, 可以带有条件Policy .HandleInner&lt;HttpRequestException&gt;() .OrInner&lt;OperationCanceledException&gt;(ex =&gt; ex.CancellationToken != myToken)指定要处理的返回结果从Polly v4.3.0起，包含返回TResult的调用的策略也可以处理TResult返回值123456789101112131415161718192021222324252627// 带条件判断的单种返回值处理Policy .HandleResult&lt;HttpResponseMessage&gt;(r =&gt; r.StatusCode == HttpStatusCode.NotFound)// 带条件判断的多种返回值处理Policy .HandleResult&lt;HttpResponseMessage&gt;(r =&gt; r.StatusCode == HttpStatusCode.InternalServerError) .OrResult(r =&gt; r.StatusCode == HttpStatusCode.BadGateway)// 原始返回值处理 (隐式调用 .Equals())Policy .HandleResult&lt;HttpStatusCode&gt;(HttpStatusCode.InternalServerError) .OrResult(HttpStatusCode.BadGateway) // 在一个策略中同时处理异常和返回值HttpStatusCode[] httpStatusCodesWorthRetrying = &#123; HttpStatusCode.RequestTimeout, // 408 HttpStatusCode.InternalServerError, // 500 HttpStatusCode.BadGateway, // 502 HttpStatusCode.ServiceUnavailable, // 503 HttpStatusCode.GatewayTimeout // 504&#125;; HttpResponseMessage result = await Policy .Handle&lt;HttpRequestException&gt;() .OrResult&lt;HttpResponseMessage&gt;(r =&gt; httpStatusCodesWorthRetrying.Contains(r.StatusCode)) .RetryAsync(...) .ExecuteAsync( /* Func&lt;Task&lt;HttpResponseMessage&gt;&gt; */ )第二步：指定策略应如何处理这些错误重试（Retry）12345678910111213141516171819202122232425// 重试一次Policy .Handle&lt;SomeExceptionType&gt;() .Retry()// 重试多次Policy .Handle&lt;SomeExceptionType&gt;() .Retry(3)// 重试多次，每次重试触发事件（参数为此次异常和当前重试次数）Policy .Handle&lt;SomeExceptionType&gt;() .Retry(3, onRetry: (exception, retryCount) =&gt; &#123; // do something &#125;);// 重试多次，每次重试触发事件（参数为此次异常、当前重试次数和当前执行的上下文）Policy .Handle&lt;SomeExceptionType&gt;() .Retry(3, onRetry: (exception, retryCount, context) =&gt; &#123; // do something &#125;);不断重试直到成功（Retry forever until succeeds）1234567891011121314151617181920// 不断重试Policy .Handle&lt;SomeExceptionType&gt;() .RetryForever()// 不断重试，每次重试触发事件（参数为此次异常） Policy .Handle&lt;SomeExceptionType&gt;() .RetryForever(onRetry: exception =&gt; &#123; // do something &#125;);// 不断重试，每次重试触发事件（参数为此次异常和当前执行的上下文）Policy .Handle&lt;SomeExceptionType&gt;() .RetryForever(onRetry: (exception, context) =&gt; &#123; // do something &#125;);等待并重试（Wait and retry）WaitAndRetry策略处理HTTP状态代码429的重试后状态1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// 重试多次, 每次重试之间等待指定的持续时间。(失败之后触发等待, 然后再进行下一次尝试。)Policy .Handle&lt;SomeExceptionType&gt;() .WaitAndRetry(new[] &#123; TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(3) &#125;);// 重试并触发事件多次, 每次重试之间等待指定的持续时间。（事件参数为当前异常和时间间隔）Policy .Handle&lt;SomeExceptionType&gt;() .WaitAndRetry(new[] &#123; TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(3) &#125;, (exception, timeSpan) =&gt; &#123; // do something &#125;); // 重试并触发事件多次, 每次重试之间等待指定的持续时间。（事件参数为当前异常、时间间隔和当前执行的上下文）Policy .Handle&lt;SomeExceptionType&gt;() .WaitAndRetry(new[] &#123; TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(3) &#125;, (exception, timeSpan, context) =&gt; &#123; // do something &#125;);// 重试并触发事件多次, 每次重试之间等待指定的持续时间。（事件参数为当前异常、时间间隔、当前重试次数和当前执行的上下文）Policy .Handle&lt;SomeExceptionType&gt;() .WaitAndRetry(new[] &#123; TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(3) &#125;, (exception, timeSpan, retryCount, context) =&gt; &#123; // do something &#125;);// 重试指定的次数, 根据当前重试次数计算等待时间 (允许指数回退)// 当前这种情况下, 等待时间为:// 2 ^ 1 = 2 s// 2 ^ 2 = 4 s// 2 ^ 3 = 8 s// 2 ^ 4 = 16 s// 2 ^ 5 = 32 sPolicy .Handle&lt;SomeExceptionType&gt;() .WaitAndRetry(5, retryAttempt =&gt; TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) );// 重试指定的次数，每次重试时触发事件，根据当前重试次数计算等待时间。（事件参数为当前异常、时间间隔和当前执行的上下文）Policy .Handle&lt;SomeExceptionType&gt;() .WaitAndRetry( 5, retryAttempt =&gt; TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), (exception, timeSpan, context) =&gt; &#123; // do something &#125; );// 重试指定的次数，每次重试时触发事件，根据当前重试次数计算等待时间。（事件参数为当前异常、时间间隔、当前重试次数和当前执行的上下文）Policy .Handle&lt;SomeExceptionType&gt;() .WaitAndRetry( 5, retryAttempt =&gt; TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), (exception, timeSpan, retryCount, context) =&gt; &#123; // do something &#125; );不断等待并重试直到成功（Wait and retry forever until succeeds）如果所有重试都失败, 重试策略将重新引发最后一个异常返回到调用代码。123456789101112131415161718192021222324252627// 不断等待并重试Policy .Handle&lt;SomeExceptionType&gt;() .WaitAndRetryForever(retryAttempt =&gt; TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) );// 不断等待并重试，每次重试时触发事件。（事件参数为当前异常、时间间隔）Policy .Handle&lt;SomeExceptionType&gt;() .WaitAndRetryForever( retryAttempt =&gt; TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), (exception, timespan) =&gt; &#123; // do something &#125;);// 不断等待并重试，每次重试时触发事件。（事件参数为当前异常、时间间隔和当前执行的上下文）Policy .Handle&lt;SomeExceptionType&gt;() .WaitAndRetryForever( retryAttempt =&gt; TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), (exception, timespan, context) =&gt; &#123; // do something &#125;);断路器（Circuit-breaker）断路器策略通过在程序出错时抛出BrokenCircuitException来屏蔽其他异常。文档请注意, 断路器策略将重新引发所有异常, 甚至是已处理的异常。所以使用时通常会将重试策略和断路器策略组合使用。12345678910111213141516171819202122232425262728293031323334// 在指定数量的连续异常后断开程序执行并在之后的一段时间内保持程序执行断开。Policy .Handle&lt;SomeExceptionType&gt;() .CircuitBreaker(2, TimeSpan.FromMinutes(1));// 在指定数量的连续异常后断开程序执行并在之后的一段时间内保持程序执行断开。当程序执行断开或者重新启用时触发事件。（程序执行断开事件参数为当前异常和间隔时间，重新启用事件无参数）Action&lt;Exception, TimeSpan&gt; onBreak = (exception, timespan) =&gt; &#123; ... &#125;;Action onReset = () =&gt; &#123; ... &#125;;CircuitBreakerPolicy breaker = Policy .Handle&lt;SomeExceptionType&gt;() .CircuitBreaker(2, TimeSpan.FromMinutes(1), onBreak, onReset);// 在指定数量的连续异常后断开程序执行并在之后的一段时间内保持程序执行断开。当程序执行断开或者重新启用时触发事件。（程序执行断开事件参数为当前异常、间隔时间和当前执行上下文，重新启用事件参数为当前执行上下文）Action&lt;Exception, TimeSpan, Context&gt; onBreak = (exception, timespan, context) =&gt; &#123; ... &#125;;Action&lt;Context&gt; onReset = context =&gt; &#123; ... &#125;;CircuitBreakerPolicy breaker = Policy .Handle&lt;SomeExceptionType&gt;() .CircuitBreaker(2, TimeSpan.FromMinutes(1), onBreak, onReset);// 程序运行状态, 运行状况。CircuitState state = breaker.CircuitState;/*CircuitState.Closed - 断路器未触发，允许操作执行。CircuitState.Open - 断路器开启，阻止操作执行。CircuitState.HalfOpen - 断路器开启指定时间后重新关闭，此状态允许操作执行，之后的开启或关闭取决于继续执行的结果。CircuitState.Isolated - 断路器被主动开启，阻止操作执行。*/// 手动打开 (并保持打开) 断路器（例如需要主动隔离下游服务时）breaker.Isolate(); // 重置断路器为关闭状态, 再次开始允许操作执行。breaker.Reset(); `高级断路器（Advanced Circuit Breaker）1234567891011121314// 在采样持续时间内, 如果已处理异常的操作的比例超过故障阈值且该时间段内通过请求操作数达到最小吞吐量，主动启动断路器。Policy .Handle&lt;SomeExceptionType&gt;() .AdvancedCircuitBreaker( failureThreshold: 0.5, // 当&gt;=50%的操作会导致已处理的异常时中断程序。 samplingDuration: TimeSpan.FromSeconds(10), // 采样时间区间为10秒 minimumThroughput: 8, // ... 在采样时间区间内进行了至少8次操作。 durationOfBreak: TimeSpan.FromSeconds(30) // 断路30秒. );// 采用状态更改委托的配置重载同样可用于高级断路器。// 电路状态监控和手动控制同样也可用于高级断路器。更多相关资料请参考: 文档有关断路器模式的更多信息, 请参见：改造 Netflix API 增加接口弹性断路器浅谈 (马丁·福勒)断路器模式 (Microsoft)原始断路器链回退策略（Fallback）1234567891011121314151617// 执行错误时提供替代值。Policy .Handle&lt;Whatever&gt;() .Fallback&lt;UserAvatar&gt;(UserAvatar.Blank)// 执行错误时使用回调函数提供替代值。Policy .Handle&lt;Whatever&gt;() .Fallback&lt;UserAvatar&gt;(() =&gt; UserAvatar.GetRandomAvatar()) // where: public UserAvatar GetRandomAvatar() &#123; ... &#125;// 执行错误时提供替代值的同时触发事件。（事件参数为当前异常信息和当前运行上下文）Policy .Handle&lt;Whatever&gt;() .Fallback&lt;UserAvatar&gt;(UserAvatar.Blank, onFallback: (exception, context) =&gt; &#123; // do something &#125;);第三步：执行策略123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 执行操作var policy = Policy .Handle&lt;SomeExceptionType&gt;() .Retry();policy.Execute(() =&gt; DoSomething());// 执行传递任意上下文数据的操作var policy = Policy .Handle&lt;SomeExceptionType&gt;() .Retry(3, (exception, retryCount, context) =&gt; &#123; var methodThatRaisedException = context["methodName"]; Log(exception, methodThatRaisedException); &#125;);policy.Execute( () =&gt; DoSomething(), new Dictionary&lt;string, object&gt;() &#123;&#123; "methodName", "some method" &#125;&#125;);// 执行返回结果的函数var policy = Policy .Handle&lt;SomeExceptionType&gt;() .Retry();var result = policy.Execute(() =&gt; DoSomething());// 执行传递任意上下文数据且返回结果的操作var policy = Policy .Handle&lt;SomeExceptionType&gt;() .Retry(3, (exception, retryCount, context) =&gt; &#123; object methodThatRaisedException = context["methodName"]; Log(exception, methodThatRaisedException) &#125;);var result = policy.Execute( () =&gt; DoSomething(), new Dictionary&lt;string, object&gt;() &#123;&#123; "methodName", "some method" &#125;&#125;);// 综合使用Policy .Handle&lt;SqlException&gt;(ex =&gt; ex.Number == 1205) .Or&lt;ArgumentException&gt;(ex =&gt; ex.ParamName == "example") .Retry() .Execute(() =&gt; DoSomething());为了简单起见, 上面的示例显示了策略定义, 然后是策略执行。但是在代码库和应用程序生命周期中, 策略定义和执行可能同样经常被分离。例如, 可以选择在启动时定义策略, 然后通过依赖注入将其提供给使用点。故障处理（主动策略）主动策略添加了不基于当策略被引发或返回时才处理错误的弹性策略。第一步：配置超时（Timeout）乐观超时（Optimistic timeout）乐观超时通过 CancellationToken 运行, 并假定您执行支持合作取消的委托。您必须使用 Execute/Async(...) 重载以获取 CancellationToken, 并且执行的委托必须遵守该 CancellationToken。12345678910111213141516171819202122232425262728293031323334// 如果执行的委托尚未完成，在调用30秒后超时并返回 。 乐观超时: 委托应采取并遵守 CancellationToken。Policy .Timeout(30)// 使用 TimeSpan 配置超时。Policy .Timeout(TimeSpan.FromMilliseconds(2500))// 通过方法提供可变的超时。Policy .Timeout(() =&gt; myTimeoutProvider)) // Func&lt;TimeSpan&gt; myTimeoutProvider// 超时后触发事件。（事件参数为当前执行上下文、执行间隔、当前执行的TASK）Policy .Timeout(30, onTimeout: (context, timespan, task) =&gt; &#123; // do something &#125;);// 示例：在超时后记录日志Policy .Timeout(30, onTimeout: (context, timespan, task) =&gt; &#123; logger.Warn($"&#123;context.PolicyKey&#125; at &#123;context.ExecutionKey&#125;: execution timed out after &#123;timespan.TotalSeconds&#125; seconds."); &#125;);// 示例：在超时任务完成时捕获该任务中的任何异常Policy .Timeout(30, onTimeout: (context, timespan, task) =&gt; &#123; task.ContinueWith(t =&gt; &#123; if (t.IsFaulted) logger.Error($"&#123;context.PolicyKey&#125; at &#123;context.ExecutionKey&#125;: execution timed out after &#123;timespan.TotalSeconds&#125; seconds, with: &#123;t.Exception&#125;."); &#125;); &#125;);示例执行:123456Policy timeoutPolicy = Policy.TimeoutAsync(30);HttpResponseMessage httpResponse = await timeoutPolicy .ExecuteAsync( async ct =&gt; await httpClient.GetAsync(endpoint, ct), // 执行一个有参数且响应 CancellationToken 的委托。 CancellationToken.None // 在这种情况下, CancellationToken.None 将被传递到执行中, 这表明您没有将期望的令牌控制通过超时策略添加。 自定义 CancellationToken 也可以通过，详情请参阅 wiki 中的例子。 );悲观超时（Pessimistic timeout）悲观超时允许调用代码 “离开” 等待执行完成的委托, 即使它不支持取消。在同步执行中, 这是以牺牲一个额外的线程为代价的。有关更多细节, 请参见文档。示例执行:12345Policy timeoutPolicy = Policy.TimeoutAsync(30, TimeoutStrategy.Pessimistic);var response = await timeoutPolicy .ExecuteAsync( async () =&gt; await FooNotHonoringCancellationAsync(), // 执行不接受取消令牌且不响应取消的委托。 );超时策略在发生超时时引发 TimeoutRejectedException。更多详情参见文档。隔板（Bulkhead）1234567891011121314151617181920// 通过该策略将执行限制为最多12个并发操作。Policy .Bulkhead(12)// 将通过策略执行的操作限制为最多12个并发操作, 如果插槽都被占满, 最多可以有两个操作被等待执行。Policy .Bulkhead(12, 2)// 限制并发执行, 如果执行被拒绝, 则调用触发事件。（事件参数为当前执行上下文）Policy .Bulkhead(12, context =&gt; &#123; // do something &#125;);// 查看隔板可用容量, 例如健康负荷。var bulkhead = Policy.Bulkhead(12, 2);// ...int freeExecutionSlots = bulkhead.BulkheadAvailableCount;int freeQueueSlots = bulkhead.QueueAvailableCount;当隔板策略的插槽全部被正在执行的操作占满是，会引发 BulkheadRejectedException。更多详情参见文档。缓存(Cache)12345678910111213141516171819202122232425var memoryCache = new MemoryCache(new MemoryCacheOptions());var memoryCacheProvider = new MemoryCacheProvider(memoryCache);var cachePolicy = Policy.Cache(memoryCacheProvider, TimeSpan.FromMinutes(5));// .NET Core CacheProviders DI 示例 请参照以下文章 https://github.com/App-vNext/Polly/wiki/Cache#working-with-cacheproviders :// - https://github.com/App-vNext/Polly.Caching.MemoryCache// - https://github.com/App-vNext/Polly.Caching.IDistributedCache // 定义每天午夜绝对过期的缓存策略。var cachePolicy = Policy.Cache(memoryCacheProvider, new AbsoluteTtl(DateTimeOffset.Now.Date.AddDays(1));// 定义超时过期的缓存策略: 每次使用缓存项时, 项目的有效期为5分钟。var cachePolicy = Policy.Cache(memoryCacheProvider, new SlidingTtl(TimeSpan.FromMinutes(5));// 定义缓存策略, 并捕获任何缓存提供程序错误以进行日志记录。var cachePolicy = Policy.Cache(myCacheProvider, TimeSpan.FromMinutes(5), (context, key, ex) =&gt; &#123; logger.Error($"Cache provider, for key &#123;key&#125;, threw exception: &#123;ex&#125;."); // (for example) &#125;);// 以直通缓存的身份执行缓存: 首先检查缓存;如果未找到, 请执行基础委托并将结果存储在缓存中。 // 用于特定执行的缓存的键是通过在传递给执行的上下文实例上设置操作键 (v6 之前: 执行键) 来指定的。使用下面显示的窗体的重载 (或包含相同元素的更丰富的重载)。// 示例: "fookey" 是将在下面的执行中使用的缓存密钥。TResult result = cachePolicy.Execute(context =&gt; getFoo(), new Context("FooKey"));有关使用其他缓存提供程序的更丰富的选项和详细信息, 请参阅:文档策略包装（PolicyWrap）12345678910111213141516171819202122// 定义由以前定义的策略构建的组合策略。var policyWrap = Policy .Wrap(fallback, cache, retry, breaker, timeout, bulkhead);// (包装策略执行任何被包装的策略: fallback outermost ... bulkhead innermost)policyWrap.Execute(...)// 定义标准的弹性策略PolicyWrap commonResilience = Policy.Wrap(retry, breaker, timeout);// ... 然后包装在额外的策略特定于一个请求类型:Avatar avatar = Policy .Handle&lt;Whatever&gt;() .Fallback&lt;Avatar&gt;(Avatar.Blank) .Wrap(commonResilience) .Execute(() =&gt; &#123; /* get avatar */ &#125;);// 共享通用弹性, 但将不同的策略包装在另一个请求类型中:Reputation reps = Policy .Handle&lt;Whatever&gt;() .Fallback&lt;Reputation&gt;(Reputation.NotAvailable) .Wrap(commonResilience) .Execute(() =&gt; &#123; /* get reputation */ &#125;);更多详情参见文档无策略(NoOp)123// 定义一个策略, 该策略将简单地导致传递给执行的委托 "按原样" 执行。// 适用于在单元测试中或在应用程序中可能需要策略, 但您只是希望在没有策略干预的情况下通过执行的应用程序。NoOpPolicy noOp = Policy.NoOp();更多详情参见文档第二步：执行策略同上执行后：捕获结果或任何最终异常使用 ExecuteAndCapture(…) 方法可以捕获执行的结果: 这些方法返回一个执行结果实例, 该实例描述的是成功执行还是错误。12345678910var policyResult = await Policy .Handle&lt;HttpRequestException&gt;() .RetryAsync() .ExecuteAndCaptureAsync(() =&gt; DoSomethingAsync());/* policyResult.Outcome - 调用是成功还是失败 policyResult.FinalException - 最后一个异常。如果调用成功, 则捕获的最后一个异常将为 nullpolicyResult.ExceptionType - 定义为要处理的策略的最后一个异常 (如上面的 HttpRequestException) 或未处理的异常 (如 Exception). 如果调用成功, 则为 null。policyResult.Result - 如果执行 func, 调用成功则返回执行结果, 否则为类型的默认值*/处理返回值和 Policy&lt;TResult&gt;如步骤1b 所述, 从 polly v4.3.0 开始, 策略可以组合处理返回值和异常:12345678910111213// 在一个策略中处理异常和返回值HttpStatusCode[] httpStatusCodesWorthRetrying = &#123; HttpStatusCode.RequestTimeout, // 408 HttpStatusCode.InternalServerError, // 500 HttpStatusCode.BadGateway, // 502 HttpStatusCode.ServiceUnavailable, // 503 HttpStatusCode.GatewayTimeout // 504&#125;; HttpResponseMessage result = await Policy .Handle&lt;HttpRequestException&gt;() .OrResult&lt;HttpResponseMessage&gt;(r =&gt; httpStatusCodesWorthRetrying.Contains(r.StatusCode)) .RetryAsync(...) .ExecuteAsync( /* some Func&lt;Task&lt;HttpResponseMessage&gt;&gt; */ )要处理的异常和返回结果可以以任意顺序流畅的表达。强类型 Policy&lt;TResult&gt;配置策略 .HandleResult&lt;TResult&gt;(...) 或.OrResult&lt;TResult&gt;(...) 生成特定强类型策略 Policy&lt;TResult&gt;，例如 Retry&lt;TResult&gt;, AdvancedCircuitBreaker&lt;TResult&gt;。这些策略必须用于执行返回 TResult 的委托, 即:Execute(Func&lt;TResult&gt;) (and related overloads)ExecuteAsync(Func&lt;CancellationToken, Task&lt;TResult&gt;&gt;) (and related overloads)ExecuteAndCapture&lt;TResult&gt;().ExecuteAndCapture(…) 在非泛型策略上返回具有属性的 PolicyResult：1234policyResult.Outcome - 调用是成功还是失败 policyResult.FinalException - 最后一个异常。如果调用成功, 则捕获的最后一个异常将为 nullpolicyResult.ExceptionType - 定义为要处理的策略的最后一个异常 (如上面的 HttpRequestException) 或未处理的异常 (如 Exception). 如果调用成功, 则为 null。policyResult.Result - 如果执行 func, 调用成功则返回执行结果, 否则为类型的默认值.ExecuteAndCapture&lt;TResult&gt;(Func&lt;TResult&gt;)在强类型策略上添加了两个属性:12policyResult.FaultType - 最终的故障是处理异常还是由策略处理的结果？如果委托执行成功, 则为 null。policyResult.FinalHandledResult - 处理的最终故障结果;如果调用成功将为空或类型的默认值。Policy&lt;TResult&gt;策略的状态更改事件在仅处理异常的非泛型策略中, 状态更改事件 (如 onRetry 和 onBreak ) 提供 Exception 参数。在处理 TResult 返回值的通用性策略中, 状态更改委托是相同的, 除非它们采用 DelegateResult参数代替异常。DelegateResult具有两个属性:Exception // 如果策略正在处理异常则为则刚刚引发异常(否则为空),Result // 如果策略正在处理结果则为刚刚引发的 TResult (否则为 default(TResult))BrokenCircuitException&lt;TResult&gt;非通用的循环断路器策略在断路时抛出一个BrokenCircuitException。此 BrokenCircuitException 包含最后一个异常 (导致中断的异常) 作为 InnerException。关于 CircuitBreakerPolicy&lt;TResult&gt; 策略:由于异常而中断将引发一个 BrokenCircuitException, 并将 InnerException 设置为触发中断的异常 (如以前一样)。由于处理结果而中断会引发 ‘BrokenCircuitException&lt;TResult&gt;‘, 其 Result 属性设置为导致电路中断的结果.Policy Keys 与 Context data123456789101112131415161718192021222324252627282930// 用扩展方法 WithPolicyKey() 使用 PolicyKey 识别策略, // (例如, 对于日志或指标中的相关性)var policy = Policy .Handle&lt;DataAccessException&gt;() .Retry(3, onRetry: (exception, retryCount, context) =&gt; &#123; logger.Error($"Retry &#123;retryCount&#125; of &#123;context.PolicyKey&#125; at &#123;context.ExecutionKey&#125;, due to: &#123;exception&#125;."); &#125;) .WithPolicyKey("MyDataAccessPolicy");// 在上下文中传递 ExecutionKey , 并使用 ExecutionKey 标识呼叫站点var customerDetails = policy.Execute(myDelegate, new Context("GetCustomerDetails"));// "MyDataAccessPolicy" -&gt; context.PolicyKey // "GetCustomerDetails -&gt; context.ExecutionKey// 将其他自定义信息从调用站点传递到执行上下文中 var policy = Policy .Handle&lt;DataAccessException&gt;() .Retry(3, onRetry: (exception, retryCount, context) =&gt; &#123; logger.Error($"Retry &#123;retryCount&#125; of &#123;context.PolicyKey&#125; at &#123;context.ExecutionKey&#125;, getting &#123;context["Type"]&#125; of id &#123;context["Id"]&#125;, due to: &#123;exception&#125;."); &#125;) .WithPolicyKey("MyDataAccessPolicy");int id = ... // 客户idvar customerDetails = policy.Execute(context =&gt; GetCustomer(id), new Context("GetCustomerDetails", new Dictionary&lt;string, object&gt;() &#123;&#123;"Type","Customer"&#125;,&#123;"Id",id&#125;&#125;更多资料参考文档PolicyRegistry123456789101112131415161718192021// 创建策略注册表 (例如在应用程序启动时) PolicyRegistry registry = new PolicyRegistry();// 使用策略填充注册表registry.Add("StandardHttpResilience", myStandardHttpResiliencePolicy);// 或者:registry["StandardHttpResilience"] = myStandardHttpResiliencePolicy;// 通过 DI 将注册表实例传递给使用站点public class MyServiceGateway &#123; public void MyServiceGateway(..., IReadOnlyPolicyRegistry&lt;string&gt; registry, ...) &#123; ... &#125; &#125;// (或者, 如果您更喜欢环境上下文模式, 请使用线程安全的单例)// 使用注册表中的策略registry.Get&lt;IAsyncPolicy&lt;HttpResponseMessage&gt;&gt;("StandardHttpResilience") .ExecuteAsync&lt;HttpResponseMessage&gt;(...)策略注册表具有一系列进一步的类似字典的语义, 例如 .ContainsKey(…), .TryGet(…), .Count, .Clear(), 和 Remove(…)，适用于 v5.2.0 以上版本有关详细信息, 请参阅: 文档.NET Core 使用Polly重试机制12345678910111213141516171819202122public class PollyController : ApiController&#123; public readonly RetryPolicy&lt;HttpResponseMessage&gt; _httpRequestPolicy; public PollyController() &#123; _httpRequestPolicy = Policy.HandleResult&lt;HttpResponseMessage&gt;( r =&gt; r.StatusCode == HttpStatusCode.InternalServerError) .WaitAndRetryAsync(3, retryAttempt =&gt; TimeSpan.FromSeconds(retryAttempt)); &#125; public async Task&lt;IHttpActionResult&gt; Get() &#123; var httpClient = new HttpClient(); var requestEndpoint = "http://www.baidu.com"; HttpResponseMessage httpResponse = await _httpRequestPolicy.ExecuteAsync(() =&gt; httpClient.GetAsync(requestEndpoint)); IEnumerable&lt;string&gt; numbers = await httpResponse.Content.ReadAsAsync&lt;IEnumerable&lt;string&gt;&gt;(); return Ok(numbers); &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Polly</tag>
        <tag>熔断降级</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【微服务学习】Consul 服务治理发现]]></title>
    <url>%2FConsul-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E5%8F%91%E7%8E%B0.html</url>
    <content type="text"><![CDATA[Consul 服务治理发现简介Consul 是 HashiCorp 公司推出的开源工具，用于实现分布式系统的服务发现与配置。与其他分布式服务注册与发现的方案，Consul的方案更“一站式”，内置了服务注册与发现框架、分布一致性协议实现、健康检查、Key/Value存储、多数据中心方案，不再需要依赖其他工具（比如ZooKeeper等）。使用起来也较为简单。Consul使用Go语言编写，因此具有天然可移植性(支持Linux、windows和Mac OS X)；安装包仅包含一个可执行文件，方便部署，与Docker等轻量级容器可无缝配合 。service discovery：consul通过DNS或者HTTP接口使服务注册和服务发现变的很容易，一些外部服务，例如saas提供的也可以一样注册。health checking：健康检测使consul可以快速的告警在集群中的操作。和服务发现的集成，可以防止服务转发到故障的服务上面。key/value storage：一个用来存储动态配置的系统。提供简单的HTTP接口，可以在任何地方操作。*multi-datacenter：无需复杂的配置，即可支持任意数量的区域。Consul 是注册中心，服务提供者、服务消费者等都要注册到 Consul 中，这样就可以实现服务提供者、服务消费者的隔离。除了 Consul 之外，还有 Eureka、Zookeeper、Etcd 等类似服务发现框架。Consul 相关概念CLIENTCLIENT表示consul的client模式，就是客户端模式。是consul节点的一种模式，这种模式下，所有注册到当前节点的服务会被转发到SERVER，本身是不持久化这些信息。SERVERSERVER表示consul的server模式，表明这个consul是个server，这种模式下，功能和CLIENT都一样，唯一不同的是，它会把所有的信息持久化的本地，这样遇到故障，信息是可以被保留的。SERVER-LEADER中间那个SERVER下面有LEADER的字眼，表明这个SERVER是它们的老大，它和其它SERVER不一样的一点是，它需要负责同步注册的信息给其它的SERVER，同时也要负责各个节点的健康监测。其它信息其它信息包括它们之间的通信方式，还有一些协议信息，算法。它们是用于保证节点之间的数据同步，实时性要求等等一系列集群问题的解决。这些有兴趣的自己看看官方文档。我的理解Consul 的整体功能其实就类似于互联网中的 DNS 服务器，Consul 服务端根据客户端传入的服务名，返回所有提供该服务的地址，整个流程跟 DNS 服务器将域名转化为 IP 地址有异曲同工之妙。Consul 在 .NET Core 下的实践我是用的开发平台是 Windows 64bit，鉴于 Windows 使用 Docker 的繁琐和诸多问题，以下流程直接下载运行 Consul 而不使用 Docker。下载安装运行从Consul 下载页面下载对应平台的最新版本的 Consul 程序并解压。运行 consul.exe agent -dev （使用开发模式进行测试，如需生产环境集群使用，只要需要一台 Server，多台 Agent）访问自带的 Web 后台查看即时信息.NET Core 下的 Consul 实践Install-Package Consul程序与 Consul 的交互主要有三种：服务注册服务查询服务健康检查服务注册与反注册随机获取一个可用端口123456789101112131415161718192021222324252627282930313233343536using System;using System.Linq;using System.Net.NetworkInformation;namespace ConsulDemo.Extensions&#123; public static class PortHelper &#123; /// &lt;summary&gt; /// 产生一个随机可用端口 /// &lt;/summary&gt; /// &lt;param name="minPort"&gt;&lt;/param&gt; /// &lt;param name="maxPort"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static int GetRandAvailablePort(int minPort = 1024, int maxPort = 65535) &#123; var rand = new Random(); while (true) &#123; var port = rand.Next(minPort, maxPort); if (!IsPortInUsed(port)) return port; &#125; &#125; /// &lt;summary&gt; /// 判断端口是否在使用中 /// &lt;/summary&gt; /// &lt;param name="port"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool IsPortInUsed(int port) =&gt; IPGlobalProperties.GetIPGlobalProperties().GetActiveTcpListeners().Any(p =&gt; p.Port == port) || IPGlobalProperties.GetIPGlobalProperties().GetActiveUdpListeners().Any(p =&gt; p.Port == port) || IPGlobalProperties.GetIPGlobalProperties().GetActiveTcpConnections().Any(conn =&gt; conn.LocalEndPoint.Port == port); &#125;&#125;Program 增加属性 CurrentPort12345678910111213141516171819202122public static IWebHostBuilder using ConsulDemo.Extensions;using Microsoft.AspNetCore;using Microsoft.AspNetCore.Hosting;using Microsoft.Extensions.Configuration;namespace ConsulDemo&#123; public class Program &#123; public static void Main(string[] args) &#123; CreateWebHostBuilder(args).Build().Run(); &#125; public static int CurrentPort &#123; get; set; &#125; public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&gt; WebHost.CreateDefaultBuilder(args) .UseStartup&lt;Startup&gt;() .UseUrls($"http://*:&#123;CurrentPort = PortHelper.GetRandAvailablePort()&#125;"); &#125;&#125;将注册与反注册的方法绑定到生命周期的开始和结束123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public void Configure(IApplicationBuilder app, IHostingEnvironment env, IApplicationLifetime lifetime)&#123; if (env.IsDevelopment()) app.UseDeveloperExceptionPage(); app.UseMvc(); const string ip = "127.0.0.1"; var port = Program.CurrentPort; var serviceID = $"ConsulDemo_&#123;Environment.TickCount&#125;"; //Consul 客户端 var client = new ConsulClient((obj) =&gt; &#123; obj.Address = new Uri("http://127.0.0.1:8500"); obj.Datacenter = "dc1"; &#125;); // 在生命周期开始时注册服务 lifetime.ApplicationStarted.Register(() =&gt; &#123; var result = client.Agent.ServiceRegister(new AgentServiceRegistration &#123; ID = serviceID, Name = "ConsulDemo", Address = ip, Port = port, Check = new AgentServiceCheck &#123; DeregisterCriticalServiceAfter = TimeSpan.FromSeconds(5), Interval = TimeSpan.FromSeconds(5), HTTP = $"http://&#123;ip&#125;:&#123;port&#125;/api/values/0", Timeout = TimeSpan.FromSeconds(5) &#125; &#125;); Console.WriteLine($"Consul-ServiceRegister:&#123;result.Result.StatusCode&#125; - &#123;result.Result.RequestTime&#125;"); &#125;); // 在生命周期结束时反注册服务 lifetime.ApplicationStopping.Register(() =&gt; &#123; var result = client.Agent.ServiceDeregister(serviceID); Console.WriteLine($"Consul-ServiceDeregister:&#123;result.Result.StatusCode&#125; - &#123;result.Result.RequestTime&#125;"); &#125;);&#125;结果视图启动五个服务提供程序，图中可以看得到连接成功后的打印以及 Consul 健康检查得请求日志。从 Consul 的后台可以清楚的看到已经成功注册了五个 ConsulDemo 服务提供程序。服务消费程序首先我们新建一个 RestTemplateRestTemplate（模仿 Spring Cloud 中的）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788using Consul;using Newtonsoft.Json;using System;using System.Linq;using System.Net;using System.Net.Http;using System.Net.Http.Headers;using System.Threading.Tasks;namespace ConsulTemplate&#123; public class RestTemplate &#123; private readonly string _consulServerUrl; public RestTemplate(string consulServerUrl = "http://127.0.0.1:8500") &#123; _consulServerUrl = consulServerUrl; &#125; /// &lt;summary&gt; /// 获取服务的第一个实现地址 /// &lt;/summary&gt; /// &lt;param name="serviceName"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private async Task&lt;string&gt; ResolveRootUrlAsync(string serviceName) &#123; using (var consulClient = new ConsulClient(c =&gt; c.Address = new Uri(_consulServerUrl))) &#123; var services = (await consulClient.Agent.Services()).Response; Console.WriteLine("当前所有服务"); foreach (var service in services) Console.WriteLine($"Service:&#123;service.Value.Service&#125;Address:&#123;service.Value.Address&#125;Port:&#123;service.Value.Port&#125;"); var agentServices = services.Where(s =&gt; s.Value.Service.Equals(serviceName, StringComparison.CurrentCultureIgnoreCase)).Select(s =&gt; s.Value).ToArray(); //根据当前TickCount对服务器个数取模，“随机”取一个机器出来，避免“轮询”的负载均衡策略需要计数加锁问题 var agentService = agentServices.ElementAt(Environment.TickCount % agentServices.Length); Console.WriteLine($"随机选取 Service:&#123;agentService.Service&#125;Address:&#123;agentService.Address&#125;Port:&#123;agentService.Port&#125;"); return agentService.Address + ":" + agentService.Port; &#125; &#125; /// &lt;summary&gt; /// 转化到实际接口地址 /// &lt;/summary&gt; /// &lt;param name="url"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private async Task&lt;string&gt; ResolveUrlAsync(string url) &#123; var uri = new Uri(url); var serviceName = uri.Host; var realRootUrl = await ResolveRootUrlAsync(serviceName); return uri.Scheme + "://" + realRootUrl + uri.PathAndQuery; &#125; public async Task&lt;ResponseEntity&lt;T&gt;&gt; GetForEntityAsync&lt;T&gt;(string url, HttpRequestHeaders requestHeaders = null) &#123; using (var httpClient = new HttpClient()) &#123; var requestMsg = new HttpRequestMessage(); if (requestHeaders != null) foreach (var header in requestHeaders) requestHeaders.Add(header.Key, header.Value); requestMsg.Method = HttpMethod.Get; requestMsg.RequestUri = new Uri(await ResolveUrlAsync(url)); var result = await httpClient.SendAsync(requestMsg); var respEntity = new ResponseEntity&lt;T&gt; &#123; StatusCode = result.StatusCode &#125;; var bodyStr = await result.Content.ReadAsStringAsync(); respEntity.Body = JsonConvert.DeserializeObject&lt;T&gt;(bodyStr); respEntity.Headers = respEntity.Headers; return respEntity; &#125; &#125; &#125;&#125;public class ResponseEntity&lt;T&gt;&#123; public HttpStatusCode StatusCode &#123; get; set; &#125; public T Body &#123; get; set; &#125;//返回的json反序列化出来的对象 public HttpResponseHeaders Headers &#123; get; set; &#125;//响应的报文头&#125;调用代码12345678910111213static void Main(string[] args)&#123; while (true) &#123; Console.WriteLine("请求开始"); var rest = new RestTemplate(); var data = rest.GetForEntityAsync&lt;DateTime&gt;("http://ConsulDemo/api/Values").Result; Console.WriteLine(data.StatusCode); Console.WriteLine(string.Join(",", data.Body)); Console.WriteLine("请求结束\r\n\r\n"); Console.ReadKey(); &#125;&#125;手动关掉一个服务端关掉的程序成功消失(反注册)资源管理器杀掉一个程序源码 ConsulDemo.7z]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>服务治理发现</tag>
        <tag>.NET</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何修改 .NET Core Kestrel 下的端口]]></title>
    <url>%2F%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9-.NET-Core.html</url>
    <content type="text"><![CDATA[今天在尝试 Consul 的时候需要动态改变 .NET Core Kestrel 下的端口以方便测试，故而查了查，发现原来除了最常使用的 UseUrls 之外，还有许多其他方法，故而总结一下。实现方法ASPNETCORE_URLS 环境变量使用环境变量可以配置 Kestrel 使用的端口CODE1set ASPNETCORE_URLS=http://127.0.0.1:5008;http://0.0.0.0:5009RESULT–urls 命令行参数使用 –urls 命令行参数可以配置 Kestrel 使用的端口CODE1set dotnet EndpointConfigurationTest2.0.dll --urls http://0.0.0.0:5698;https://127.0.0.1:6936RESULTUseUrls使用 IWebHostBuilder 的扩展方法 UseUrls() 可以为 Kestrel 绑定一个或者多个 url ，支持 http 与 https，支持多个 string 参数或者单个 string 中使用分号分割。CODE1234public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&gt; WebHost.CreateDefaultBuilder(args) .UseUrls("http://localhost:4411","https://localhost:4412","http://0.0.0.0:4413;https://localhost:4414") .UseStartup&lt;Startup&gt;();RESULT配置文件在配置文件中增加 Kestrel 节点来配置 Kestrel 使用的端口CODE123456789101112131415161718&#123; "Logging": &#123; "LogLevel": &#123; "Default": "Warning" &#125; &#125;, "AllowedHosts": "*", "Kestrel": &#123; "EndPoints": &#123; "Http": &#123; "Url": "http://localhost:5000" &#125;, "Https": &#123; "Url": "https://localhost:5006" &#125; &#125; &#125;&#125;RESULTUseKestrel 或者 ConfigureKestrel使用 IWebHostBuilder 的扩展方法 UseKestrel() 可以更精确的设置 Kestrel 的更多配置信息 ，在 .NET Core 2.1 版本以上也可以为 ConfigureKestrel()。CODE123456789101112public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&gt; WebHost.CreateDefaultBuilder(args) .UseUrls("http://localhost:4411","https://localhost:4412","http://0.0.0.0:4413;https://localhost:4414") .UseStartup&lt;Startup&gt;() .UseKestrel((context, options) =&gt; &#123; options.Listen(IPAddress.Any, 5620); options.Listen(IPAddress.Loopback, 5588, listenOptions =&gt; &#123; listenOptions.UseHttps(); &#125;); &#125;);RESULT总结以上几种方法就是我根据官方文档整理的修改 Kestrel 端口的方法，实测优先级由上到下依次增高，使用优先级更高的方式可以覆盖掉优先级低的方式。综上，需要测试 Consul 服务治理时，更合适的方式是使用命令行 –urls 方式.]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Kestrel</tag>
        <tag>端口修改</tag>
        <tag>终结点配置</tag>
        <tag>Endpoint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两种软件开发模式：瀑布与敏捷]]></title>
    <url>%2F%E4%B8%A4%E7%A7%8D%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%80%91%E5%B8%83%E4%B8%8E%E6%95%8F%E6%8D%B7.html</url>
    <content type="text"><![CDATA[瀑布开发模式瀑布模式是一种前几年在国内各大项目中比较流行的开发模式，特点是分阶段进行，每个阶段都很清晰，只有阶段对应的人员才会参与当前阶段的开发，每个阶段必须有产出物才可以开始下个阶段，整个周期较长，早期需求分析和设计的时间消耗较多，整个流程会尽量避免需求的改动，更适用于B端产品的开发。瀑布 VS 敏捷瀑布敏捷开发流程里程碑迭代开发文档强调文档可以工作的胜过面面俱到的文档开发人员强调分工协助、沟通开发需求避免变化拥抱变化需求变更谈判与计划与客户合作敏捷模式典型框架 Scrum结构Scrum 角色Product Owner：产品负责人，主要提需求的人，一般为老板。Scrum Master：Scrum 主管，保证Scrum模式的顺利执行（禁止在开发阶段该需求，督促开展会议等），一般为项目经理，或者项目之外的人担任。Team：开发团队，包含所有的开发人员。工件UserStory：用户故事，不必有清晰文档的产品需求。Product Backlog：产品订单，所有待开发的UserStory的集合。Sprint Backlog：冲刺订单，本周期内待开发的UserStory。Burndown Chat：冲刺燃尽图，周期内UserStory的变化曲线。活动Sprint Planning Meeting：计划会，周期末开展，总结冲刺燃尽图，评估冲刺订单。Daily Standuy Meeting：每日例会，每天早上开展，十五分钟内的短会，所有开发人员对昨天的工作成果，今天的工作内容，现在遇到的问题这三个问题进行描述，方便会议之后解决问题和让开发团队每一个成员了解到当前进度。Review Meeting：评审会，评审UserStory的可行性和工期。Retrospective Meeting：回顾会，每个迭代上线之后，以匿名的方式投票总结成员各自看到的问题，并在下一个迭代尝试解决。Scrum 流程]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>开发模式</tag>
        <tag>瀑布模式</tag>
        <tag>敏捷开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVP——最小可行化产品]]></title>
    <url>%2F%E6%9C%80%E5%B0%8F%E5%8F%AF%E8%A1%8C%E5%8C%96%E4%BA%A7%E5%93%81MVP.html</url>
    <content type="text"><![CDATA[最简可行产品：概念最简可行产品（minimum viable product，简称MVP）是新产品开发中的名词，是指有部分机能，恰好可以让设计者表达其核心设计概念的产品。设计者可以进行验证式学习，根据使用者的回馈，进一步了解使用情形，并且继续开发此产品 。由最简可行产品来搜集相关想法常常会比开发有更多机能的产品要便宜。开发更多机能产品的的费用较高，也会有产品失败的风险（例如产品基本假设有误的情形）。最简可行产品一词是由法兰克·罗宾生（Frank Robinson）创建，因史蒂夫·布兰克及埃里克·莱斯的使用而流行。“要贩售愿景及提供最简可行产品给有远见的人，不是给所有的人。”——史蒂夫·布兰克MVP具有以下三个特点：是一种避免开发出客户并不真正需要的产品的开发策略。快速地构建出符合产品预期功能的最小功能集合，通过迭代来完善。是让开发团队用最小的代价实现一个产品，以此最大程度上了解和验证对用户问题的解决程度。设计技巧定位一致，满足核心需求体现核心竞争力/亮点只做核心功能（人无我有，人有我精）快速试验亮点功能并获得第一批用户例：支付宝初期核心功能为支付和担保交易成本尽可能低使用“轮子”，尽可能套用现有方案以快速实现示例假设客户需要一辆汽车，我们应该使用什么样的流程完成骑车的开发呢？传统软件开发流程中如上半部分图片的流程，我们会慢慢的将汽车的每一个部件按顺序制造出来，最终得到整个骑车。MVP最小可行化产品设计流程中，我们应该意识到，客户需要一辆汽车的本质其实是需要一个出行工具，应该用最小的可以满足客户需求的方式实现用户出行的需求，然后再不断对工具进行迭代，最终得到一辆汽车。图示如下：最小可行化，即，不断获取可行化与最小化交集：注意事项避免粗糙造成印象分扣减（注重MVP的体验，而不只是功能）避免切分范围太小达不到验证效果（需要完整的表达出需求）保持与主要定位一致避免影响核心理念（体现出正确的价值）总结以用户问题为中心，而不是以解决方案为中心。首先着眼于基本的客户需求，通过客户反馈，逐步修正产品设计和实现。在各个迭代过程中，做出来的产品始终是可为客户所用的产品。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>产品</tag>
        <tag>MVP</tag>
        <tag>最小可行化</tag>
        <tag>最简可行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Selenium PhantomJS 巧妙过渡到 Firefox/Chrome]]></title>
    <url>%2FSelenium-PhantomJS-%E5%B7%A7%E5%A6%99%E8%BF%87%E6%B8%A1%E5%88%B0-Firefox-Chrome.html</url>
    <content type="text"><![CDATA[PhantomJS ObsoleteOrigin前段时间因为一些个人爱好，想要对某网站的数据进行整站采集，其中需要对某些页面的一些区块进行截图采集，整个采集任务中还涉及一些验证码识别之类的工作。学艺不精，我当前掌握的 Scrapy 知识很难完成这样一个爬虫，就使用了 Selenium + PhantomJS 制作了一个模拟浏览器访问来爬取数据的小爬虫，完成了整套抓取任务。然而上个月手误格掉了整块数据硬盘，之前的代码也没留下备份，我还仍然有同样的数据采集需要，只能准备按照原有思路重新做一个爬虫，这本来应该只是个体力活，只要重新抓样本，做好验证码识别，之后就应该一马平川，一泻千里了。然而就在我开始动手的时候，PhantomJSDriver 类型下的蓝色下划线成功吸引了有强迫症的程序员本尊的注意运用我考了三遍都没过的四级英语定睛一看，这个意思是说， PhantomJSDriver 类型已经被弃用，PhantomJS 的开发工作已经停止，PhantomJS 的驱动将会在未来的某个 release 版本上被移除。天哪~！告诉我不是真的！Selenium 居然放弃了他的好基友 PhantomJS！（这个声明颇有 “不是我他跟不上我的进步被我抛弃，而是他渣，他抛弃了我” 的戏剧性，让我不由得想要查证一下）Investigate不敢相信的我祭出了谷歌神器Chrome 59 将支持 Headless 模式。而在 Chrome 未提供原生 Headless 模式前，Web 开发者可以使用 PhantomJS 等第三方 Headless 浏览器。现在官方准备提供 Headless 了，PhantomJS 主要的贡献者 Vitaly Slobodin 随即在邮件列表上宣布辞职。因为这半年都没有过写新爬虫的需求，而最近一直在跑着的爬虫用的是老版本 Selenium 开发，所以还 PhantomJS 玩得很嗨，殊不知已经 Out 了。查了一下，去年四月份的 Chrome 59 版本和六月份的 Firefox 56 版本都引入了 Headless 模式，PhantomJS 的独领风骚地位瞬间丧失，开发者流失，仅剩的一位开发者 Vitaly Slobodin 看不到 PhantomJS 的未来，选择了停止开发，然后 “不思进取” 的 PhantomJS 逐渐消失在历史的尘埃中…… 小厂出的创新产品，大厂做出类似产品之后，小厂 GG，大概也就是这么一回事吧……（虽然果真是 PhantomJS 做了负心汉，但还是莫名悲壮，有种丈夫不思进取，觉得配不上努力上进妻子然后自我了断给妻子自由的既视感）Headless Chrome/Firefox想要使用 Selenium 控制 Firefox 进行页面浏览，需要先做以下的准备工作：Headless FirefoxPrepare安装最新版本的 Firefox 浏览器。下载最新版本的适应当前系统的 GeckoDriver。将步骤 2 下载的 GeckoDriver 的程序文件移动到 Firefox 的程序目录中，使两个程序的执行文件处于同一目录中，并将程序所在的目录加入到环境变量中。然后引入官方的四个 Nuget 包：Install-Package Selenium.WebDriverInstall-Package Selenium.WebDriverBackedSeleniumInstall-Package Selenium.SupportInstall-Package Selenium.RCCoding随意拉一个窗体用于测试，然后敲入以下代码：1234567var firefoxOption = new FirefoxOptions();firefoxOption.AddArguments("-headless");var firefoxDriver = new FirefoxDriver(firefoxOption);firefoxDriver.Navigate().GoToUrl("http://www.baidu.com/");textBox1.Text = firefoxDriver.PageSource;运行结果：Headless ChromePrepare想要使用 Selenium 控制 Chrome 进行页面浏览，需要做的准备工作和上面的 Firefox 大同小异：安装最新版本的 Chrome 浏览器（也可以考虑像我一样使用国内大牛写的 Chrome 绿色化工具 MyChrome 安装绿色版 Chrome ，在版本控制、用户文件本地化方面更具优势）。下载最新版本的适应当前系统的 ChromeDriver。将步骤 2 下载的 ChromeDriver 的程序文件移动到 Chrome 的程序目录中，使两个程序的执行文件处于同一目录中，并将程序所在的目录加入到环境变量中。依然是官方的四个 Nuget 包（如果已经安装过，则直接跳过）：Install-Package Selenium.WebDriverInstall-Package Selenium.WebDriverBackedSeleniumInstall-Package Selenium.SupportInstall-Package Selenium.RCCoding随意拉一个窗体用于测试，然后敲入以下代码：1234567var chromeOption = new ChromeOptions();chromeOption.AddArguments("--headless", "--disable-gpu");var chromeDriver = new ChromeDriver(chromeOption);chromeDriver.Navigate().GoToUrl("http://www.baidu.com/");textBox1.Text = chromeDriver.PageSource;运行结果：Full Page ScreenShot无头模式是已经实现了，在打开时间上效率略差于 PhantomJS，但是执行页面抓取是却要更优于 PhantomJS ，无愧于老牌浏览器的称号。可是接下来就遇到了新的问题，上面提到的，我的爬虫求有截取页面某一区域图片的需求，而 Selenium 的驱动 API 标准获取图片的只有 GetScreenShot ，在之前使用 PhantomJS 时，由于 PhantomJS 从从诞生时起就是一个为爬虫服务的没有界面的浏览器，所以截图 API 截到的就是整个页面的图片，在获取某一区域的渲染图片时，只需要从截到的全页面图中将区域所在的矩形取出来，就可以完成要求。但是对于 Chrome 和 Firefox 这样的浏览器，虽然有 Headless 模式，但是窗口的概念是一只存在的， GetScreenShot 截到的只会是浏览器窗口显示的部分页面的截图，所以我们需要找到一种可以截全图的方法。Thinking想要在每次只能截到浏览器显示区域截图的情况下得到整个页面的截图，有如下两个思路：控制浏览器滚动条移动，将所有区域的截图全都获取到，再根据每次截图时滚动条所处的位置信息，将所有截图合并到一起，最终得到全页面的截图。把浏览器的窗口大小设置到页面一样大，甚至比页面稍大些，再进行截图，就可以得到全页面的截图。比较而言无疑是思路 2 更为简单高效，而且在 Headless 模式下，浏览器窗口的变化也完全不会有什么影响，故我们选用第二种思路来实现全页面截图。Coding这里我们使用. NET 知名开源图片处理组件 ImageProcessor 来进行图片裁剪。Install-Package ImageProcessor并非专业前端的我开始觉得 html 标签的尺寸应该就是整个页面的尺寸了，所以有了如下的代码：123456789101112131415161718public static Image GetElementImage(this RemoteWebDriver driver, IWebElement element)&#123; driver.Manage().Window.Size = driver.FindElementByTagName("html").Size; var photoBytes = driver.GetScreenshot().AsByteArray; using (var inStream = new MemoryStream(photoBytes)) &#123; using (var outStream = new MemoryStream()) &#123; using (var imageFactory = new ImageFactory(true)) &#123; imageFactory.Load(inStream) .Crop(new Rectangle(element.Location, element.Size)) .Save(outStream); &#125; return Image.FromStream(outStream); &#125; &#125;&#125;但是在测试过程中发现并非如此，具体测试页面为 “Selenium 的维基百科关键词主页”https://en.wikipedia.org/wiki/Selenium_(software)调用代码：123pictureBox1.Image = chromeDriver.GetElementImage( chromeDriver.FindElementByXPath(@"//*[@id=""footer-copyrightico""]/a/img"));调用代码中的 XPath 命中的标签为页面底部的维基百科 logo 图片，调试信息可知，该标签的 Y 坐标远大于 Html 标签的 Height ，故 Html 的尺寸应该和页面实际尺寸并不完全吻合。居然不对？！查询资料大法：1234567891011121314151617//页面尺寸var pageWidth = Math.max( document.body.scrollWidth, document.documentElement.scrollWidth, document.body.offsetWidth, document.documentElement.offsetWidth, document.documentElement.clientWidth);var pageHeight = Math.max( document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.documentElement.clientHeight);于是我决定改用执行 JS 代码来获取页面实际尺寸：封装 JS 执行方法：12public static T Execute&lt;T&gt;(this IWebDriver driver, string script) =&gt; (T)((IJavaScriptExecutor)driver).ExecuteScript(script);获取实际尺寸12var height = driver.Execute&lt;long&gt;("return Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight);");var width = driver.Execute&lt;long&gt;("return Math.max(document.body.scrollWidth, document.body.offsetWidth, document.documentElement.clientWidth, document.documentElement.scrollWidth, document.documentElement.offsetWidth);");使用新思路重新封装方法12345678910111213141516171819202122232425public static Image GetElementImage(this RemoteWebDriver driver, IWebElement element)&#123; //driver.Manage().Window.Size = driver.FindElementByTagName("html").Size; var height = driver.Execute&lt;long&gt;("return Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight);"); var width = driver.Execute&lt;long&gt;("return Math.max(document.body.scrollWidth, document.body.offsetWidth, document.documentElement.clientWidth, document.documentElement.scrollWidth, document.documentElement.offsetWidth);"); driver.Manage().Window.Size = new Size((int)width + 100, (int)height + 100); var photoBytes = driver.GetScreenshot().AsByteArray; using (var inStream = new MemoryStream(photoBytes)) &#123; using (var outStream = new MemoryStream()) &#123; using (var imageFactory = new ImageFactory(true)) &#123; imageFactory.Load(inStream) .Crop(new Rectangle(element.Location, element.Size)) .Save(outStream); &#125; return Image.FromStream(outStream); &#125; &#125;&#125;代码执行结果如下：成功！]]></content>
      <categories>
        <category>踩坑笔记</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>selenium</tag>
        <tag>full page screenshot</tag>
        <tag>全页面截图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EFCore MySQL System.TypeLoadException occurred 问题解决]]></title>
    <url>%2FNet-Core-2-0-EFCore-MySQL-System-TypeLoadException-occurred-%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3.html</url>
    <content type="text"><![CDATA[今天在使用 EFCore + MySQL 搭一个小Demo的时候,在 Migration 环节遇到了这样一个问题。System.TypeLoadException occurredHResult=0x80131522Message=Method ‘Clone’ in type ‘MySQL.Data.EntityFrameworkCore.Infraestructure.Internal.MySQLOptionsExtension’ from assembly ‘MySql.Data.EntityFrameworkCore, Version=8.0.8.0, Culture=neutral, PublicKeyToken=c5687fc88969c44d’ does not have an implementation.几经排查无果之后求助了Google，发现了一条状况相同的 Issue项目作者的回复如下@lixiandai Hi, yes, this is frustrating - Oracle’s MySQL does not yet fully support .NET Core 2.In the interim, I suggest using Pomelo, which can be installed by executing the following command:$ dotnet add package Pomelo.EntityFrameworkCore.MySql –version 2.0.0-rtm-10062Or, add the following line to your .csproj ItemGroup所以其实是MySQL的官方驱动包的锅喽?按照作者的推荐选择了一位国内大佬的项目Pomelo.EntityFrameworkCore.MySql，成功解决问题。]]></content>
      <categories>
        <category>踩坑笔记</category>
      </categories>
      <tags>
        <tag>EFCore</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试·网站后台开发工程师·总结]]></title>
    <url>%2F%E5%85%B3%E4%BA%8E20180313.html</url>
    <content type="text"><![CDATA[关于2018年3月9日面试某公司网站后台开发工程师的一些总结。面试问题总结面试官非常nice，可能是因为之前通过同学跟他有过一些间接交流，所以开场时问了我：“我让XXX告诉你去学习一下.NET Core，你学的怎么样了。”瞬间整个人就不那么紧张了。之后面试官首先问了我一些我目前主要使用的C#桌面软件开发的一些知识，之后在逐渐的把问题转到.NET Core，从中可以感觉得出面试官对于基础知识即为擅长，问的问题大量的都是非常细节性的，由于我在.NET Core上并没有付出很多的学习时间，而且主要是“自定向下”的学习，主要学习怎么使用，这些细节就了解的不那么清楚了，所以整个面试确实有不少问题没能回答得上来。下面是具体没能答上来问题的具体分析。桌面开发Winform 多线程状态下应该怎样保持界面响应当时回答了可以使用.Net Framework 4.5版本以上支持的语法糖await\asnyc来进行多线程请求，或者是新开线程完成操作，或者使用Application.DoEvent()这样的函数强行保持界面响应。当时应该是有些紧张，没有准确get到面试官真正想要问的问题，事后思考感觉面试官真正想问的应该是使用委托解决方法的跨线程调用问题这种类型的委托问题，所以这道题也算是没有回答好。数据库数据库横表、纵表转换这道题确实是忘记了大学学习的知识，也没反应过来横纵表转换到底是什么概念，下面直接写一个例子吧。横表结构: AchievementID姓名语文数学英语1张三8090702李四9085953王五887590转换后的表结构ID姓名科目成绩1张三语文802张三数学903张三英语704李四语文905李四数学806李四英语997王五语文858王五数学969王五英语881234SELECT 姓名,'语文' AS 科目,语文 AS 成绩 FROM Achievement UNION ALLSELECT 姓名,'数学' AS 科目,数学 AS 成绩 FROM Achievement UNION ALL SELECT 姓名,'英语' AS 科目,英语 AS 成绩 FROM AchievementORDER BY 姓名,科目 DESC;.NET Core下面题目中的一些.NET Core的细节，我会引用来自本人购买的 张剑桥 先生的《ASP.NET Core 跨平台开发从入门到实战》一书中的内容，如果希望获得更多的知识请直接在各大平台购买本书，若侵犯了您的权利，请联系删除。.NET Core 程序增加中间件在什么位置在 ASP.NET Core 中，你可以使用中间件构建你的请求处理管道。ASP.NET Core 中间件为一个HttpContext 执行异步逻辑，然后按顺序调用下一个中间件或者直接终止请求。一般来说，要使用一个中间件，只需在Configure方法里调用 IApplicationBuilder 上一个对应的扩展方法即可。静态文件访问开启为了能够使用静态文件服务，必须配置中间件，把静态文件中间件加入到管道内。静态文件中间件可通过下述方法来配置：在项目中增加 Microsoft.AspNetCore.StaticFiles包依赖，然后从 Startup.Configure 中调用.UseStaticFiles扩展方法：12345// This method gets called by the runtime. Use this method to configure the HTTP request pipeline.public void Configure(IApplicationBuilder app, IHostingEnvironment env)&#123; app.UseStaticFiles();&#125;配置使用Session与上面的静态文件相同，需要首先依赖 Microsoft.AspNetCore.Session 包，然后从Startup.Configure 中调用.UseSession方法。12345// This method gets called by the runtime. Use this method to configure the HTTP request pipeline.public void Configure(IApplicationBuilder app, IHostingEnvironment env)&#123; app.UseSession();&#125;EF Core如何启用懒加载EF6中是默认开启懒加载的，可以通过修改配置文件来进行修改，而到了EF Core中，则可以在 DbContext 的 OnConfiguring 方法中添加对 UseLazyLoadingProxies() 扩展方法调用即可。123456789101112131415161718public class WayneContext : DbContext&#123; protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) &#123; var sqlConnectionStringBuilder = new SqlConnectionStringBuilder &#123; DataSource = "****", InitialCatalog = "Wayne", UserID = "sa", Password = "sa" &#125;; optionsBuilder.UseSqlServer(sqlConnectionStringBuilder.ConnectionString); optionsBuilder.UseLazyLoadingProxies(); base.OnConfiguring(optionsBuilder); &#125;&#125;Asp.NET Core的热部署是怎么实现的以MVC模板为例，其实是在 Program 类中的 CreateWebHostBuilder 方法中实现的。1234567891011121314151617using Microsoft.AspNetCore;using Microsoft.AspNetCore.Hosting;namespace TestCore&#123; public class Program &#123; public static void Main(string[] args) &#123; CreateWebHostBuilder(args).Build().Run(); &#125; public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&gt; WebHost.CreateDefaultBuilder(args) .UseStartup&lt;Startup&gt;(); &#125;&#125;第十四行，WebHost.CreateDefaultBuilder(args)方法中巨硬封装了读取配置文件的操作。F12反编译转到源码。123456789101112131415161718192021222324252627282930313233343536373839404142434445/// &lt;summary&gt;/// Initializes a new instance of the &lt;see cref="T:Microsoft.AspNetCore.Hosting.WebHostBuilder" /&gt; class with pre-configured defaults./// &lt;/summary&gt;/// &lt;remarks&gt;/// The following defaults are applied to the returned &lt;see cref="T:Microsoft.AspNetCore.Hosting.WebHostBuilder" /&gt;:/// use Kestrel as the web server and configure it using the application's configuration providers,/// set the &lt;see cref="P:Microsoft.AspNetCore.Hosting.IHostingEnvironment.ContentRootPath" /&gt; to the result of &lt;see cref="M:System.IO.Directory.GetCurrentDirectory" /&gt;,/// load &lt;see cref="T:Microsoft.Extensions.Configuration.IConfiguration" /&gt; from 'appsettings.json' and 'appsettings.[&lt;see cref="P:Microsoft.AspNetCore.Hosting.IHostingEnvironment.EnvironmentName" /&gt;].json',/// load &lt;see cref="T:Microsoft.Extensions.Configuration.IConfiguration" /&gt; from User Secrets when &lt;see cref="P:Microsoft.AspNetCore.Hosting.IHostingEnvironment.EnvironmentName" /&gt; is 'Development' using the entry assembly,/// load &lt;see cref="T:Microsoft.Extensions.Configuration.IConfiguration" /&gt; from environment variables,/// load &lt;see cref="T:Microsoft.Extensions.Configuration.IConfiguration" /&gt; from supplied command line args,/// configures the &lt;see cref="T:Microsoft.Extensions.Logging.ILoggerFactory" /&gt; to log to the console and debug output,/// enables IIS integration,/// and enables the ability for frameworks to bind their options to their default configuration sections./// &lt;/remarks&gt;/// &lt;param name="args"&gt;The command line args.&lt;/param&gt;/// &lt;returns&gt;The initialized &lt;see cref="T:Microsoft.AspNetCore.Hosting.IWebHostBuilder" /&gt;.&lt;/returns&gt;public static IWebHostBuilder CreateDefaultBuilder(string[] args)&#123; IWebHostBuilder hostBuilder = new WebHostBuilder().UseKestrel((Action&lt;WebHostBuilderContext, KestrelServerOptions&gt;)((builderContext, options) =&gt; options.Configure((IConfiguration)builderContext.Configuration.GetSection("Kestrel")))).UseContentRoot(Directory.GetCurrentDirectory()).ConfigureAppConfiguration((Action&lt;WebHostBuilderContext, IConfigurationBuilder&gt;)((hostingContext, config) =&gt; &#123; IHostingEnvironment hostingEnvironment = hostingContext.HostingEnvironment; config.AddJsonFile("appsettings.json", true, true).AddJsonFile(string.Format("appsettings.&#123;0&#125;.json", (object)hostingEnvironment.EnvironmentName), true, true); if (hostingEnvironment.IsDevelopment()) &#123; Assembly assembly = Assembly.Load(new AssemblyName(hostingEnvironment.ApplicationName)); if (assembly != (Assembly)null) config.AddUserSecrets(assembly, true); &#125; config.AddEnvironmentVariables(); if (args == null) return; config.AddCommandLine(args); &#125;)) .ConfigureLogging((Action&lt;WebHostBuilderContext, ILoggingBuilder&gt;)((hostingContext, logging) =&gt; &#123; logging.AddConfiguration((IConfiguration)hostingContext.Configuration.GetSection("Logging")); logging.AddConsole(); logging.AddDebug(); &#125;)) .UseIISIntegration().UseDefaultServiceProvider((Action&lt;WebHostBuilderContext, ServiceProviderOptions&gt;)((context, options) =&gt; options.ValidateScopes = context.HostingEnvironment.IsDevelopment())); if (args != null) hostBuilder.UseConfiguration((IConfiguration)new ConfigurationBuilder().AddCommandLine(args).Build()); return hostBuilder;&#125;第23行 中1config.AddJsonFile("appsettings.json", true, true).AddJsonFile(string.Format("appsettings.&#123;0&#125;.json", (object)hostingEnvironment.EnvironmentName), true, true);继续查看config扩展方法AddJsonFile的源码12345678910111213/// &lt;summary&gt;/// Adds the JSON configuration provider at &lt;paramref name="path" /&gt; to &lt;paramref name="builder" /&gt;./// &lt;/summary&gt;/// &lt;param name="builder"&gt;The &lt;see cref="T:Microsoft.Extensions.Configuration.IConfigurationBuilder" /&gt; to add to.&lt;/param&gt;/// &lt;param name="path"&gt;Path relative to the base path stored in/// &lt;see cref="P:Microsoft.Extensions.Configuration.IConfigurationBuilder.Properties" /&gt; of &lt;paramref name="builder" /&gt;.&lt;/param&gt;/// &lt;param name="optional"&gt;Whether the file is optional.&lt;/param&gt;/// &lt;param name="reloadOnChange"&gt;Whether the configuration should be reloaded if the file changes.&lt;/param&gt;/// &lt;returns&gt;The &lt;see cref="T:Microsoft.Extensions.Configuration.IConfigurationBuilder" /&gt;.&lt;/returns&gt;public static IConfigurationBuilder AddJsonFile(this IConfigurationBuilder builder, string path, bool optional, bool reloadOnChange)&#123; return builder.AddJsonFile((IFileProvider) null, path, optional, reloadOnChange);&#125;形参中的第四个参数为1/// &lt;param name="reloadOnChange"&gt;Whether the configuration should be reloaded if the file changes.&lt;/param&gt;当这个参数被设置为 true 时即可实现热更新。怎样修改绑定的地址在 Program 类的 CreateWebHostBuilder 中增加 UseUrls 方法的调用1234public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&gt; WebHost.CreateDefaultBuilder(args) .UseUrls("http://localhost:5001") .UseStartup&lt;Startup&gt;();更改实体类后怎样同步更改到数据库主要要使用EF的cli命令提交更改1dotnet ef migrations Add InitialCreate同步到数据库1dotnet ef database update回滚到之前的某一次提交1dotnet ef migrations update InitialCreate回滚后同步代码回滚1dotnet ef migrations remove将更改生成SQL脚本（一般是为了方便部署到正式环境）1dotnet ef migrations script]]></content>
      <categories>
        <category>踩坑笔记</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【51NOD刷题】1182 完美字符串]]></title>
    <url>%2Fx51NOD%E5%88%B7%E9%A2%98x1182-%E5%AE%8C%E7%BE%8E%E5%AD%97%E7%AC%A6%E4%B8%B2.html</url>
    <content type="text"><![CDATA[1182 完美字符串题目来源： Facebook Hacker Cup选拔基准时间限制：1 秒 空间限制：131072 KB 分值: 5 难度：1级算法题约翰认为字符串的完美度等于它里面所有字母的完美度之和。每个字母的完美度可以由你来分配，不同字母的完美度不同，分别对应一个1-26之间的整数。约翰不在乎字母大小写。（也就是说字母F和f）的完美度相同。给定一个字符串，输出它的最大可能的完美度。例如：dad，你可以将26分配给d，25分配给a，这样整个字符串完美度为77。输入输出Input输入一个字符串S(S的长度 &lt;= 10000)，S中没有除字母外的其他字符。Output由你将1-26分配给不同的字母，使得字符串S的完美度最大，输出这个完美度。Input示例dadOutput示例77题目分析这道题很简单，可以自主赋予权值，则吧字符串中每个字母出现的次数统计出来，再按照次数降序排序，从第一个元素开始到次数不为0的最后一个元素n分别讲数量乘以26-n+1，之后将所有运算结果相加即为最终结果。Accepted```csharpusing System;using System.Collections.Generic;using System.Linq;public class Sum{public static void Main(){var str = Console.ReadLine();var countDic = new Dictionary(); foreach (var c in str.ToCharArray()) if (countDic.ContainsKey(c)) countDic[c]++; else countDic.Add(c, 1); var countE = countDic.Where(i =&gt; i.Key &gt; 0).Select(i =&gt; i.Value).OrderByDescending(i =&gt; i).ToArray(); var s = 0; for (var i = 0; i &lt; countE.Count(); i++) s += countE[i] * (26 - i); Console.WriteLine(s); } }```]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>51NOD</tag>
        <tag>刷题</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【下载】C# 调用迅雷、IDM下载方法汇总]]></title>
    <url>%2FCx%E8%B0%83%E7%94%A8%E8%BF%85%E9%9B%B7%E3%80%81IDM%E4%B8%8B%E8%BD%BD%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB.html</url>
    <content type="text"><![CDATA[在开发桌面软件时常常有下载文件的需求，小文件、少文件可以自己做相应的网络请求，但是当文件的大小或者数量达到一定规模时，自己封装网络请求就不是很划算的事情了，这时我们可以采取调用迅雷或者IDM、aria2c之类的专业下载软件来进行下载。迅雷直接调用迅雷安装迅雷后可以再引用的com组件中找到名为 “ThunderAgent 1.0 Type Library” 的com组件，勾选引用之后，把类库属性中的嵌入互操作类型修改为false。使用代码调用AgentLib直接在迅雷中增加新任务1new ThunderAgentLib.AgentClass().AddTask("http://s1.static.haoke258.info/attach_2/2018-1-30-5ZD6R0BZZ.rar");以上为最简单的调用方式，只是传入了下载地址，其他的属性为默认值，传入后续的几个参数或者才用AddTask2方法就可以手动修改任务属性。123public virtual extern void AddTask([MarshalAs(UnmanagedType.BStr), In] string bstrUrl, [MarshalAs(UnmanagedType.BStr), In] string bstrFileName = "", [MarshalAs(UnmanagedType.BStr), In] string bstrPath = "", [MarshalAs(UnmanagedType.BStr), In] string bstrComments = "", [MarshalAs(UnmanagedType.BStr), In] string bstrReferUrl = "", [In] int nStartMode = -1, [In] int nOnlyFromOrigin = 0, [In] int nOriginThreadCount = -1);public virtual extern void AddTask2([MarshalAs(UnmanagedType.BStr), In] string bstrUrl, [MarshalAs(UnmanagedType.BStr), In] string bstrFileName = "", [MarshalAs(UnmanagedType.BStr), In] string bstrPath = "", [MarshalAs(UnmanagedType.BStr), In] string bstrComments = "", [MarshalAs(UnmanagedType.BStr), In] string bstrReferUrl = "", [In] int nStartMode = -1, [In] int nOnlyFromOrigin = 0, [In] int nOriginThreadCount = -1, [MarshalAs(UnmanagedType.BStr), In] string bstrCookie = "");迅雷开放平台迅雷官方曾经开放过一个mini版下载SDK，相当于一个无界面版本的mini迅雷，可以供程序直接调用，现在虽然已经停止服务，但是网上仍然有它的传说，优点是不用下载迅雷，软件+dll总共只有1mb+，缺点就是没有迅雷完整版的那些加速功能，没有那么快。我按照自己的理解把SDK封装了一下：https://github.com/WayneShao/ThunderSdk下面是调用代码：123456789101112131415161718192021222324252627282930using System;using ThunderSdk;namespace ThunderSdkDemo&#123; class Program &#123; static void Main(string[] args) &#123; var manager = new DownloadManager(1, @"D:\"); manager.CreateNewTask("https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=770549720,375505130&amp;fm=173&amp;s=612A66F94AA394CE4A84E71B030050D7&amp;w=218&amp;h=146&amp;img.JPEG", "2018-1-30-5ZD6R0BZZ.jpg"); manager.TaskDownload += (s, e) =&gt; &#123; if (!(s is DownFileInfo info)) return; Console.WriteLine(info.TaskInfo.Percent); &#125;; manager.TaskCompleted += (s, e) =&gt; &#123; if (!(s is DownFileInfo info)) return; Console.WriteLine(info.FileName + "下载完成"); &#125;; manager.StartAllTask(); Console.ReadKey(); &#125; &#125;&#125;Internet Download Manager这个是我用过之后体验最好的，推荐使用。使用方法如下：获取DLL文件下载 IDMCOMAPI.zip。解压 IDManTypeInfo.tlb 文件到任意位置。打开 Visual Studio安装时附带的命令行工具。（任选一个即可，推荐第一个）使用 类型库导入程序 (Tlbimp.exe)将tlb文件转换成dll文件。1TlbImp IDManTypeInfo.tlbMicrosoft (R) .NET Framework Type Library to Assembly Converter 3.5.30729.1Copyright (C) Microsoft Corporation. All rights reserved.Type library imported to ![IDManLib.dll]This will create an IDManLib.dll如果懒得完成上面的步骤，也可以直接下载我已经导入好的文件IDManLib.7z引用DLL文件手动选择 IDManLib.dll 文件进行引用，引用后同样也要把类库属性中的嵌入互操作类型修改为false，编译平台最好选择x86。调用方法和迅雷的类似，将下载地址、文件路劲、文件名等参数传入方法中即可成功在IDM中建立新任务。1new IDManLib.CIDMLinkTransmitterClass().SendLinkToIDM("http://s1.static.haoke258.info/attach_2/2018-1-30-5ZD6R0BZZ.rar", "http://ailushe95.info/", "", "", "", "", @"D:\Backup\Downloads\LULULU", "【感謝擼友投稿】無名小姐姐 2V.rar", 0);]]></content>
      <categories>
        <category>踩坑笔记</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>下载</tag>
        <tag>IDM</tag>
        <tag>迅雷</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在IIS中托管.NET Core应用]]></title>
    <url>%2F%E5%A6%82%E4%BD%95%E5%9C%A8IIS%E4%B8%AD%E6%89%98%E7%AE%A1Asp.Net-Core%E5%BA%94%E7%94%A8.html</url>
    <content type="text"><![CDATA[Asp.NET Core 应用如果需要托管在IIS下，需要为IIS下载安装 AspNetCoreModule 模块。下面以最新的.NET Core Runtime 2.1.0-preview1版本为例：安装 Server Hosting Installer首先访问微软的.Net下载中心，并找到我们要下载的版本。点击进入详情页后，找到 Windows 分类下的 Server Hosting Installer 链接，并点击下载下载安装完成以后即可在IIS的模块中找到托管.NET Core 应用所需的 AspNetCoreModule 模块。发布程序1dotnet publish -o D:\Web\aspnetcoredemo]]></content>
      <categories>
        <category>踩坑笔记</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>IIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【51NOD刷题】1283 最小周长]]></title>
    <url>%2F1283-%E6%9C%80%E5%B0%8F%E5%91%A8%E9%95%BF.html</url>
    <content type="text"><![CDATA[1283 最小周长题目来源： Codility基准时间限制：1 秒 空间限制：131072 KB 分值: 5 难度：1级算法题一个矩形的面积为S，已知该矩形的边长都是整数，求所有满足条件的矩形中，周长的最小值。例如：S = 24，那么有{1 24} {2 12} {3 8} {4 6}这4种矩形，其中{4 6}的周长最小，为20。输入输出Input输入1个数S(1 &lt;= S &lt;= 10^9)。Output输出最小周长。Input示例24Output示例20题目分析这个题可以说是相当眼熟了，相比在过去的义务教育期间一定做过类似的题目，只不过题目并没有要求矩形的边长是整数。我们按照边长不一定是整数做一次推倒：设矩形的长和宽分别是x、y，已知举行的面积为S，求周长l的最小值。$S=x*y$$l=2(x+y)&gt;=4\sqrt{xy}=4\sqrt{S}$$l&gt;=4\sqrt{S}$所以若不要求边长为整数，则最小周长为$4\sqrt{S}$。当要求边长为整数时，对S开二次根的到数字w，找到在比w小的整数中，用S可以整除的最大的数，此时的w和S/w组成的矩形则为最小周长。Accepted123456789101112131415161718using System;public class Sum&#123; public static void Main() &#123; var s = Convert.ToInt32(Console.ReadLine()); var w = Math.Sqrt(s); for (var i = (int)w; i &gt; 0; i--) &#123; var res = s * 1.0 / i; if (!(Math.Abs(res - (int) res) &lt; 0.000001)) continue; Console.WriteLine((int)((i + res) * 2)); return; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>51NOD</tag>
        <tag>刷题</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.Net 讯飞语音识别Demo]]></title>
    <url>%2F%E8%AE%AF%E9%A3%9E%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%ABDemo.html</url>
    <content type="text"><![CDATA[讯飞语音识别官方号称具有以下六个优势：超过95%的准确率支持多种语种和方言方便快捷的信息沟通个性的语音识别中文标点智能预测支持垂直领域和应用级听写获得APPID和调用Dll在讯飞开放平台的控制台新建一个应用，平台选择Windows，新建完成后为应用添加语音听写服务。下载SDK解压出你下载的压缩包bin目录中的msc.dll等待使用注意：下面步骤里的Dll必须使用自行下载的版本，此Dll并不通用Coding识别文件实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/// &lt;summary&gt;/// 执行语音识别的异步方法/// &lt;/summary&gt;/// &lt;param name="inFile"&gt;音频文件，pcm无文件头，采样率16k，数据16位，单声道&lt;/param&gt;/// &lt;param name="outFile"&gt;输出识别结果到文件&lt;/param&gt;public void Audio2TxtAsync(string inFile, string outFile = null)&#123; var dlt = new DltSpeek(Audio2Txt); dlt.BeginInvoke(inFile, outFile, null, null);&#125;/// &lt;summary&gt;/// 进行声音识别/// &lt;/summary&gt;/// &lt;param name="inFile"&gt;音频文件，pcm无文件头，采样率16k，数据16位，单声道&lt;/param&gt;/// &lt;param name="outFile"&gt;输出识别结果到文件&lt;/param&gt;public void Audio2Txt(string inFile, string outFile = null)&#123; var ret = 0; var result = ""; try &#123; //模拟录音，输入音频 if (!File.Exists(inFile)) throw new Exception("文件" + inFile + "不存在！"); if (inFile.Substring(inFile.Length - 3, 3).ToUpper() != "WAV" &amp;&amp; inFile.Substring(inFile.Length - 3, 3).ToUpper() != "PCM") throw new Exception("音频文件格式不对！"); var fp = new FileStream(inFile, FileMode.Open); if (inFile.Substring(inFile.Length - 3, 3).ToUpper() == "WAV") fp.Position = 44; var buff = new byte[BufferNum]; var bp = Marshal.AllocHGlobal(BufferNum); int len; var status = AudioStatus.IsrAudioSampleContinue; var epStatus = EpStatus.IsrEpNull; var recStatus = RecogStatus.IsrRecNull; var rsltStatus = RecogStatus.IsrRecNull; //ep_status 端点检测（End-point detected）器所处的状态 //rec_status 识别器所处的状态 //rslt_status 识别器所处的状态 while (fp.Position != fp.Length) &#123; len = fp.Read(buff, 0, BufferNum); Marshal.Copy(buff, 0, bp, buff.Length); //开始向服务器发送音频数据 ret = AsrDll.QISRAudioWrite(_sessID, bp, (uint)len, status, ref epStatus, ref recStatus); if (ret != 0) &#123; fp.Close(); throw new Exception("QISRAudioWrite err,errCode=" + ((ErrorCode)ret).ToString("G")); &#125; //服务器返回部分结果 if (recStatus == RecogStatus.IsrRecStatusSuccess) &#123; var p = AsrDll.QISRGetResult(_sessID, ref rsltStatus, WaitTime, ref ret); if (p != IntPtr.Zero) &#123; var tmp = FlyTts.Ptr2Str(p); DataArrived?.Invoke(this, new DataArrivedEventArgs(tmp)); result += tmp; Console.WriteLine(@"返回部分结果！:" + tmp); &#125; &#125; Thread.Sleep(500); &#125; fp.Close(); //最后一块数据 status = AudioStatus.IsrAudioSampleLast; ret = AsrDll.QISRAudioWrite(_sessID, bp, 1, status, ref epStatus, ref recStatus); if (ret != 0) throw new Exception("QISRAudioWrite write last audio err,errCode=" + ((ErrorCode)ret).ToString("G")); Marshal.FreeHGlobal(bp); var loopCount = 0; //最后一块数据发完之后，循环从服务器端获取结果 //考虑到网络环境不好的情况下，需要对循环次数作限定 do &#123; var p = AsrDll.QISRGetResult(_sessID, ref rsltStatus, WaitTime, ref ret); if (p != IntPtr.Zero) &#123; var tmp = FlyTts.Ptr2Str(p); DataArrived?.Invoke(this, new DataArrivedEventArgs(tmp)); //激发识别数据到达事件 result += tmp; Console.WriteLine(@"传完音频后返回结果！:" + tmp); &#125; if (ret != 0) throw new Exception("QISRGetResult err,errCode=" + ((ErrorCode)ret).ToString("G")); Thread.Sleep(200); &#125; while (rsltStatus != RecogStatus.IsrRecStatusSpeechComplete &amp;&amp; loopCount++ &lt; 30); if (outFile != null) &#123; var fout = new FileStream(outFile, FileMode.OpenOrCreate); fout.Write(Encoding.Default.GetBytes(result), 0, Encoding.Default.GetByteCount(result)); fout.Close(); &#125; &#125; catch (Exception ex) &#123; Console.WriteLine(ex.Message); &#125; finally &#123; ret = AsrDll.QISRSessionEnd(_sessID, string.Empty); ret = AsrDll.MSPLogout(); IsrEnd?.Invoke(this, new EventArgs()); //通知识别结束 &#125;&#125;录音实现1234567891011121314151617181920212223public void StartRecoding()&#123; WaveMonitor = new WaveInEvent &#123; WaveFormat = new WaveFormat(16000, 16, 1) &#125;; if (!Directory.Exists("temp")) Directory.CreateDirectory("temp"); _fileName = Path.Combine("temp", Guid.NewGuid() + ".wav"); Writer = new WaveFileWriter(_fileName, WaveMonitor.WaveFormat); WaveMonitor.DataAvailable += (s, a) =&gt; Writer.Write(a.Buffer, 0, a.BytesRecorded); WaveMonitor.RecordingStopped += (s, a) =&gt; &#123; Writer?.Dispose(); WaveMonitor?.Dispose(); &#125;; WaveMonitor.StartRecording();&#125;public void StopRecoding()&#123; WaveMonitor.StopRecording(); Writer?.Close(); Audio2Txt(_fileName);&#125;完整源码托管在GitHub结论讯飞语音识别实测识别率其实并没有比百度好多少，准确率在服务提供商看来是越精确越好，但在实际应用中90%和95%差距并不大，故虽然讯飞看起来在数据上更好一些，但是API易用性实在比较差，还是更推荐百度一些。]]></content>
      <categories>
        <category>踩坑笔记</category>
      </categories>
      <tags>
        <tag>语音识别</tag>
        <tag>ASR</tag>
        <tag>TTS</tag>
        <tag>NAudio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法复习】贪心算法之最小生成树Prim算法]]></title>
    <url>%2FPrim%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[最小生成树的Prim算法也是贪心算法的一大经典应用。Prim算法的特点是时刻维护一棵树，算法不断加边，加的过程始终是一棵树。简述Prim算法过程：一条边一条边地加， 维护一棵树。初始 E ＝ ｛｝空集合， V = ｛任意节点｝循环（n – 1）次，每次选择一条边（v1,v2）， 满足：v1属于V , v2不属于V。且（v1,v2）权值最小。E = E + （v1,v2）V = V + v2最终E中的边是一棵最小生成树， V包含了全部节点。执行过程以下图为例介绍Prim算法的执行过程。Prim算法的过程从A开始 V = {A}, E = {}选中边AF , V = {A, F}, E = {(A,F)}选中边FB, V = {A, F, B}, E = {(A,F), (F,B)}选中边BD, V = {A, B, F, D}, E = {(A,F), (F,B), (B,D)}选中边DE, V = {A, B, F, D, E}, E = {(A,F), (F,B), (B,D), (D,E)}选中边BC, V = {A, B, F, D, E, c}, E = {(A,F), (F,B), (B,D), (D,E), (B,C)}, 算法结束。算法证明Prim算法的证明：假设Prim算法得到一棵树P，有一棵最小生成树T。假设P和T不同，我们假设Prim算法进行到第(K – 1)步时选择的边都在T中，这时Prim算法的树是P’, 第K步时,Prim算法选择了一条边e = (u, v)不在T中。假设u在P’中，而v不在。因为T是树，所以T中必然有一条u到v的路径，我们考虑这条路径上第一个点u在P’中，最后一个点v不在P’中，则路径上一定有一条边f = (x,y)，x在P’中，而且y不在P’中。我们考虑f和e的边权w(f)与w(e)的关系：若w(f) &gt; w(e)，在T中用e换掉f （T中加上e去掉f)，得到一个权值和更小的生成树，与T是最小生成树矛盾。若w(f) &lt; w(e), Prim算法在第K步时应该考虑加边f，而不是e,矛盾。因此只有w(f) = w(e),我们在T中用e换掉f，这样Prim算法在前K步选择的边在T中了，有限步之后把T变成P,而树权值和不变， 从而Prim算法是正确的。请仔细理解Prim算法——时刻维护一棵生成树。我们的证明构造性地证明了所有地最小生成树地边权（多重）集合都相同！题目测试最后，我们来提供输入输出数据，由你来写一段程序，实现这个算法，只有写出了正确的程序，才能继续后面的课程。输入第1行：2个数N,M中间用空格分隔，N为点的数量，M为边的数量。（2 &lt;= N &lt;= 1000, 1 &lt;= M &lt;= 50000)第2 - M + 1行：每行3个数S E W，分别表示M条边的2个顶点及权值。(1 &lt;= S, E &lt;= N，1 &lt;= W &lt;= 10000)输出输出最小生成树的所有边的权值之和。输入示例9 141 2 42 3 83 4 74 5 95 6 106 7 27 8 18 9 72 8 113 9 27 9 63 6 44 6 141 8 8输出示例37请选取你熟悉的语言，并在下面的代码框中完成你的程序，注意数据范围，最终结果会造成Int32溢出，这样会输出错误的答案。不同语言如何处理输入输出，请查看下面的语言说明。题目分析声明一个结构类型储存“边”的信息。123456789101112struct Side&#123; public int[] Endpoints; public int Weight; public Side(int endpoint1, int endpoint2, int weight) &#123; Endpoints = new int[2] &#123; endpoint1, endpoint2 &#125;; Weight = weight; &#125;&#125;首先读入总边数和总点数123var line1 = Console.ReadLine().Split(' ');var n = Convert.ToInt32(line1[0]);var m = Convert.ToInt32(line1[1]);读入所有“边”，储存在数组中12345678var sides = new Side[m];var points = new List&lt;int&gt;();var totalWeight = 0L;for (var i = 0; i &lt; m; i++)&#123; var line = Console.ReadLine().Split(' '); sides[i] = new Side(Convert.ToInt32(line[0]), Convert.ToInt32(line[1]), Convert.ToInt32(line[2]));&#125;将所有边按照权值排序1var orderSides = sides.OrderBy(s =&gt; s.Weight加入起点123points.AddRange(orderSides[0].Endpoints);totalWeight += orderSides[0].Weight;orderSides.RemPrim：按权值从小到大循环遍历数组里的边，如果发现某一个边的一个端点在端点数组里有，另一个端点在端点数组里没有，就把另一端点也加入，然后累加权值。直到端点数组内端点个数等于总端点数。1234567891011while (points.Count != n)&#123; for (var i = 0; i &lt; orderSides.Count; i++) &#123; if ((!points.Contains(orderSides[i].Endpoints[0]) &amp;&amp; !points.Contains(orderSides[i].Endpoints[1]))||(points.Contains(orderSides[i].Endpoints[0]) &amp;&amp; points.Contains(orderSides[i].Endpoints[1]))) continue; points.Add(points.Contains(orderSides[i].Endpoints[0]) ? orderSides[i].Endpoints[1] : orderSides[i].Endpoints[0]); totalWeight += orderSides[i].Weight; orderSides.RemoveAt(i); break; &#125;&#125;Accepted12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455using System;using System.Collections.Generic;using System.Linq;public class Sum&#123; struct Side &#123; public int[] Endpoints; public int Weight; public Side(int endpoint1, int endpoint2, int weight) &#123; Endpoints = new int[2] &#123; endpoint1, endpoint2 &#125;; Weight = weight; &#125; &#125; public static void Main() &#123; var line1 = Console.ReadLine().Split(' '); var n = Convert.ToInt32(line1[0]); var m = Convert.ToInt32(line1[1]); var sides = new Side[m]; var points = new List&lt;int&gt;(); var totalWeight = 0L; for (var i = 0; i &lt; m; i++) &#123; var line = Console.ReadLine().Split(' '); sides[i] = new Side(Convert.ToInt32(line[0]), Convert.ToInt32(line[1]), Convert.ToInt32(line[2])); &#125; var orderSides = sides.OrderBy(s =&gt; s.Weight).ToList(); points.AddRange(orderSides[0].Endpoints); totalWeight += orderSides[0].Weight; orderSides.RemoveAt(0); while (points.Count != n) &#123; for (var i = 0; i &lt; orderSides.Count; i++) &#123; if ((!points.Contains(orderSides[i].Endpoints[0]) &amp;&amp; !points.Contains(orderSides[i].Endpoints[1]))||(points.Contains(orderSides[i].Endpoints[0]) &amp;&amp; points.Contains(orderSides[i].Endpoints[1]))) continue; points.Add(points.Contains(orderSides[i].Endpoints[0]) ? orderSides[i].Endpoints[1] : orderSides[i].Endpoints[0]); totalWeight += orderSides[i].Weight; orderSides.RemoveAt(i); break; &#125; &#125; Console.WriteLine(totalWeight); &#125;&#125;]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>51NOD</tag>
        <tag>刷题</tag>
        <tag>C#</tag>
        <tag>Prim</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【51NOD刷题】1284 2 3 5 7的倍数]]></title>
    <url>%2Fx51NOD%E5%88%B7%E9%A2%98x1284-2-3-5-7%E7%9A%84%E5%80%8D%E6%95%B0.html</url>
    <content type="text"><![CDATA[1284 2 3 5 7的倍数基准时间限制：1 秒 空间限制：131072 KB 分值: 5 难度：1级算法题给出一个数N，求1至N中，有多少个数不是2 3 5 7的倍数。 例如N = 10，只有1不是2 3 5 7的倍数。输入输出Input输入1个数N(1 &lt;= N &lt;= 10^18)。Output输出不是2 3 5 7的倍数的数共有多少。Input示例10Output示例1题目分析求取1到数字N之间共有多少个数不是2 3 5 7的倍数，只需要求取1到2 3 5 7的最小公倍数210之间不是的个数48，然后再求出1到N / 210之间不是的个数mCount，即可得出最终结果N / 210 * 48 + mCount。Accepted12345678910111213141516171819using System;public class Sum&#123; public static void Main() &#123; var input = Convert.ToInt64(Console.ReadLine()); var m = input % 210; var mCount = 0; if (m &gt; 0) for (var i = 1; i &lt;= m; i++) &#123; if (i % 2 == 0 || i % 3 == 0 || i % 5 == 0 || i % 7 == 0) continue; mCount++; &#125; Console.WriteLine(input / 210 * 48 + mCount); &#125;&#125;]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>51NOD</tag>
        <tag>刷题</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【51NOD刷题】1289 大鱼吃小鱼]]></title>
    <url>%2Fx51NOD%E5%88%B7%E9%A2%98x1289-%E5%A4%A7%E9%B1%BC%E5%90%83%E5%B0%8F%E9%B1%BC.html</url>
    <content type="text"><![CDATA[1289 大鱼吃小鱼题目来源： Codility基准时间限制：1 秒 空间限制：131072 KB 分值: 5 难度：1级算法题有N条鱼每条鱼的位置及大小均不同，他们沿着X轴游动，有的向左，有的向右。游动的速度是一样的，两条鱼相遇大鱼会吃掉小鱼。从左到右给出每条鱼的大小和游动的方向（0表示向左，1表示向右）。问足够长的时间之后，能剩下多少条鱼？输入输出Input第1行：1个数N，表示鱼的数量(1 &lt;= N &lt;= 100000)。第2 - N + 1行：每行两个数A[i], B[i]，中间用空格分隔，分别表示鱼的大小及游动的方向(1 &lt;= A[i] &lt;= 10^9，B[i] = 0 或 1，0表示向左，1表示向右）。Output输出1个数，表示最终剩下的鱼的数量。Input示例54 03 12 01 05 0Output示例2题目分析本题目确切来讲有点不太严谨，比如每条鱼的起始位置、相同大小的鱼相遇后的情况就并未提供，这两个条件也会影响最终的结果。我们按照从左到右依次摆放所有鱼、两条相同的鱼相遇后只会有一条胜出来计算，则可以使用Stack完美的解决这个问题。如果鱼向右走则入栈，如果鱼向左走则循环判断它和栈顶元素的大小关系，若比栈顶元素大，则移除元素继续循环，如果栈内无元素则记录左鱼幸存条数++并跳出循环，如果比栈顶元素小则直接跳出循环。最终统计栈内元素个数和左鱼幸存条数的和即为最终幸存的鱼的数量。Accepted123456789101112131415161718192021222324252627282930313233343536373839using System;using System.Collections.Generic;using System.IO;public class Sum&#123; public static void Main() &#123; var sr = new StreamReader(Console.OpenStandardInput()); var sw = new StreamWriter(Console.OpenStandardOutput()); var count = Convert.ToInt32(sr.ReadLine()); var leftFishs = new Stack&lt;long&gt;(); var left = 0; for (var i = 0; i &lt; count; i++) &#123; var input = sr.ReadLine().Split(' '); var dx = Convert.ToInt64(input[0]); var fx = Convert.ToInt32(input[1]); if (fx == 1) leftFishs.Push(dx); else while (true) if (leftFishs.Count &gt; 0 &amp;&amp; leftFishs.Peek() &lt;= dx) leftFishs.Pop(); else &#123; if (leftFishs.Count == 0) left++; break; &#125; &#125; sw.WriteLine(leftFishs.Count + left); sw.Flush(); sr.Close(); sw.Close(); &#125;&#125;]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>51NOD</tag>
        <tag>刷题</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【51NOD刷题】1305 Pairwise Sum and Divide]]></title>
    <url>%2Fx51NOD%E5%88%B7%E9%A2%98x1305-Pairwise-Sum-and-Divide.html</url>
    <content type="text"><![CDATA[1305 Pairwise Sum and Divide题目来源： HackerRank基准时间限制：1 秒&#8195;空间限制：131072 KB&#8195;分值: 5&#8195;难度：1级算法题有这样一段程序，fun会对整数数组A进行求值，其中Floor表示向下取整：123456fun(A) sum = 0 for i = 1 to A.length for j = i+1 to A.length sum = sum + Floor((A[i]+A[j])/(A[i]*A[j])) return sum给出数组A，由你来计算fun(A)的结果。例如：A = {1, 4, 1}，fun(A) = [5/4] + [2/1] + [5/4] = 1 + 2 + 1 = 4。输入输出Input第1行：1个数N，表示数组A的长度(1 &lt;= N &lt;= 100000)。第2 - N + 1行：每行1个数A[i]（1 &lt;= A[i] &lt;= 10^9)。Output输出fun(A)的计算结果。Input示例3141Output示例4题目分析因为题目给出的已经是近乎伪代码了，所以初始很容易直接按照程序中给出的逻辑来提交，然而可能是C#的效率问题，差不多一般的测试都超时了，下面是第一版的代码：12345678910111213141516171819202122232425using System;using System.IO;public class Sum&#123; public static void Main() &#123; var sr = new StreamReader(Console.OpenStandardInput()); var sw = new StreamWriter(Console.OpenStandardOutput()); var count = Convert.ToInt32(sr.ReadLine()); var sum = 0L; var list = new long[count]; for (var i = 0; i &lt; count; i++) list[i] = Convert.ToInt64(sr.ReadLine()); for (var i = 0; i &lt; count; i++) for (var j = i + 1; j &lt; count; j++) sum += (list[i] + list[j]) / (list[i] * list[j]); sw.WriteLine(sum); sw.Flush(); sr.Close(); sw.Close(); &#125;&#125;这个时候返回来分析题目，100,000次输入操作，之后双层循环差不多10,000,000,000次循环内操作，C#在1.5s内确实不大可能完的成，只能从题目入手重新分析了。题目总的来分析就是每个数和集合中的所有其他数做一次和除以积取整的操作后的和。仔细考虑后不难发现，其实所有的数里只有1和2是可以做有效贡献的，其他数做上述运算一定是0，所以其实只需要统计1和2的数量即可。其中，1和1的运算结果为2，1和其他数的计算结果是1，2和2的计算结果是1。设一个长度为n的集合里，1的个数为a，2的个数为b，则这个集合的运算结果公式为：$C_a^2+a(n-a)+C_b^2$化简可得：$a(a-1)+a(n-a)+\frac{1}{2}(b*(b-1))$PS.因为每个数的范围最大可达$10^9$，所以我们使用64位的long类型来接收和运算。Accepted1234567891011121314151617181920212223242526272829303132333435using System;using System.IO;public class Sum&#123; public static void Main() &#123; var sr = new StreamReader(Console.OpenStandardInput()); var sw = new StreamWriter(Console.OpenStandardOutput()); var count = Convert.ToInt32(sr.ReadLine()); var sum = 0L; var a = 0L; var b = 0L; for (var i = 0; i &lt; count; i++) &#123; var s = Convert.ToInt64(sr.ReadLine()); switch (s) &#123; case 1: a++; break; case 2: b++; break; &#125; &#125; sum = a * (a - 1) + a * (count - a) + (b * (b - 1) / 2); sw.WriteLine(sum); Console.ReadLine(); sw.Flush(); sr.Close(); sw.Close(); &#125;&#125;]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>51NOD</tag>
        <tag>刷题</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【51NOD刷题】1344 走格子]]></title>
    <url>%2Fx51NOD%E5%88%B7%E9%A2%98x1344-%E8%B5%B0%E6%A0%BC%E5%AD%90.html</url>
    <content type="text"><![CDATA[1344 走格子基准时间限制：1 秒&#8195;空间限制：131072 KB&#8195;分值: 5&#8195;难度：1级算法题有编号1-n的n个格子，机器人从1号格子顺序向后走，一直走到n号格子，并需要从n号格子走出去。机器人有一个初始能量，每个格子对应一个整数A[i]，表示这个格子的能量值。如果A[i] &gt; 0，机器人走到这个格子能够获取A[i]个能量，如果A[i] &lt; 0，走到这个格子需要消耗相应的能量，如果机器人的能量 &lt; 0，就无法继续前进了。问机器人最少需要有多少初始能量，才能完成整个旅程。例如：n = 5。{1，-2，-1，3，4} 最少需要2个初始能量，才能从1号走到5号格子。途中的能量变化如下3 1 0 3 7。输入输出Input第1行：1个数n，表示格子的数量。(1 &lt;= n &lt;= 50000)第2 - n + 1行：每行1个数A[i]，表示格子里的能量值(-1000000000 &lt;= A[i] &lt;= 1000000000)Output输出1个数，对应从1走到n最少需要多少初始能量。Input示例51-2-134Output示例2题目分析这道题的主要问题主要是需要考虑到精度问题，格子数最多为50,000，每个格子能量范围为 -1,000,000,000 &lt;= NL &lt;= 1,000,000,000，总能量范围则为 -50,000,000,000,000 &lt;= MaxNL &lt;= 50,000,000,000,000，超出了Int32类型的范围-2147483648 &lt;= Int32 &lt;= 2147483647。需要使用Int64类型。Accepted1234567891011121314151617using System;public class Sum&#123; public static void Main() &#123; var count = Convert.ToInt64(Console.ReadLine()); var nl = 0L; var zxnl = 0L; for (var i = 0; i &lt; count; i++) &#123; nl += Convert.ToInt64(Console.ReadLine()); zxnl = nl &lt; zxnl ? nl : zxnl; &#125; Console.WriteLine(zxnl &gt; 0 ? 0 : 0 - zxnl); &#125;&#125;]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>51NOD</tag>
        <tag>刷题</tag>
        <tag>C#</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【51NOD刷题】1381 硬币游戏]]></title>
    <url>%2Fx51NOD%E5%88%B7%E9%A2%98x1381%20%E7%A1%AC%E5%B8%81%E6%B8%B8%E6%88%8F.html</url>
    <content type="text"><![CDATA[1381 硬币游戏基准时间限制：1 秒&#8195;空间限制：131072 KB&#8195;分值: 5&#8195;难度：1级算法题有一个简单但是很有趣的游戏。在这个游戏中有一个硬币还有一张桌子，这张桌子上有很多平行线（如下图所示）。两条相邻平行线之间的距离是1，硬币的半径是R，然后我们来抛硬币到桌子上，抛下之后硬币有时候会和一些直线相交（相切的情况也算是相交），有时候不会。请你来计算一下抛一次硬币之后，该硬币和直线相交数目的期望。输入输出Input第一行给出一个整数T，表示有T组数据(1&lt;=T&lt;=10000)。第2行到T+1，每行给出一个整数R。(0&lt; R &lt;= 10,000,000,000)Output对于每一个数据，在一行中输出答案的整数部分即可。Input示例11Output示例2题目解析由题目可知，输入的R是整数，所以分析硬币落桌之后只有两种情况：硬币边缘和某两条线相切，这个时候会有一条线经过圆心，总共有2R+1条线与圆相交，这种情况的概率非常低。硬币和所有线都没有相切，总共有2R条线与圆相交。所以总体的期望为2RAccepted123456789101112using System;public class Sum&#123; public static void Main() &#123; var count = Convert.ToInt32(Console.ReadLine()); for (var i = 0; i &lt; count; i++) Console.WriteLine(Convert.ToInt32(Console.ReadLine()) * 2); &#125;&#125;]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>51NOD</tag>
        <tag>刷题</tag>
        <tag>C#</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【51NOD刷题】1347 旋转字符串]]></title>
    <url>%2Fx51NOD%E5%88%B7%E9%A2%98x1347%20%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html</url>
    <content type="text"><![CDATA[1347 旋转字符串基准时间限制：1 秒&#8195;空间限制：131072 KB&#8195;分值: 5&#8195;难度：1级算法题S[0…n-1]是一个长度为n的字符串，定义旋转函数Left(S)=S[1…n-1]+S[0].比如S=”abcd”,Left(S)=”bcda”.一个串是对串当且仅当这个串长度为偶数，前半段和后半段一样。比如”abcabc”是对串,”aabbcc”则不是。现在问题是给定一个字符串，判断他是否可以由一个对串旋转任意次得到。输入输出Input第1行：给出一个字符串（字符串非空串，只包含小写字母，长度不超过1000000）Output对于每个测试用例，输出结果占一行，如果能，输出YES，否则输出NO。Input示例aaabOutput示例YESNOC#的运行时限为：1500 ms ，空间限制为：196608 KB题目解析从旋转函数定义来看，将字符串第一个字符移动到字符串的末尾，很容易想当然的以为需要进行Length-1次循环判断完所有旋转后的结果。题目中输入字符串长度最多为1,000,000，最多需要500,000次判断才能得出该字符串是否为对串，如果进行Length-1次循环，那计算次数最多会达到500,000,000,000，结果必然是超时。而实际上，当一个字符串是对串（即前半段和后半段完全相同的字符串）时，它无论经过多少次旋转都依然还是对串，所以只需要对输入字符串进行一次判断即可。Accepted12345678910111213141516171819202122using System;public class Sum&#123; public static void Main() &#123; var str = Console.ReadLine(); if (str.Length % 2 != 0) &#123; Console.WriteLine("NO"); return; &#125; var strQueue = str.ToCharArray(); for (var j = 0; j &lt; strQueue.Length / 2; j++) &#123; if (strQueue[j] == strQueue[strQueue.Length / 2 + j]) continue; Console.WriteLine("NO"); ; return; &#125; Console.WriteLine("YES"); &#125;&#125;]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>51NOD</tag>
        <tag>刷题</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【51NOD刷题】2020 排序相减]]></title>
    <url>%2Fx51NOD%E5%88%B7%E9%A2%98x2020%20%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%87%8F.html</url>
    <content type="text"><![CDATA[2020 排序相减题目来源： syu练习题基准时间限制：1 秒&#8195;空间限制：131072 KB&#8195;分值: 5&#8195;难度：1级算法题“排序相减”操作是指对于任意一个四位数n，将四个数字分别进行顺序排序和逆序排序，得到两个数取相减后结果的绝对值n1，然后继续将n1中的四个数字进行顺序排序和逆序排序，得到两个数取相减后结果的绝对值n2,以此类推，最后总会得到一个数字黑洞，无法跳出。例如:样例2中4176 = 6532 - 2356输入输出Input第一行输入一个整数T，表示数据组数（1&lt;T&lt;10000）；第二行输入一个正整数n(1000&lt;=n&lt;=9999)和一个正整数k（1&lt;=k&lt;=100）,表示操作次数；Output对于每组数据，输出对于开始的数据n在第k次“排序相减”后结果绝对值。Input示例21234 23562 1Output示例83524176Accepted12345678910111213141516171819202122232425262728293031323334using System;using System.IO;public class Sum&#123; public static void Main() &#123; var sr = new StreamReader(Console.OpenStandardInput()); var sw = new StreamWriter(Console.OpenStandardOutput()); var count = Convert.ToInt32(sr.ReadLine()); for (var i = 0; i &lt; count; i++) &#123; var tokens = sr.ReadLine().Split(' '); var n = Convert.ToInt32(tokens[0]); var t = Convert.ToInt32(tokens[1]); for (var j = 0; j &lt; t; j++) &#123; var intArray = n.ToString().ToCharArray(); Array.Sort(intArray); var z = Convert.ToInt32(new string(intArray)); Array.Reverse(intArray); var f = Convert.ToInt32(new string(intArray)); n = Math.Abs(z - f); &#125; sw.WriteLine(n); &#125; sw.Flush(); sr.Close(); sw.Close(); &#125;&#125;]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>51NOD</tag>
        <tag>刷题</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.Net 百度语音Demo(语音识别、语音合成）]]></title>
    <url>%2F%E7%99%BE%E5%BA%A6%E8%AF%AD%E9%9F%B3%E6%B5%8B%E8%AF%95.html</url>
    <content type="text"><![CDATA[百度语音，面向广大开发者永久免费开放语音合成技术。所采用的离在线融合技术，根据当前网络状况，自动判断使用本地引擎或者云端引擎，进行语音合成，再也不用担心流量消耗了！本Demo将使用官方提供的C#版本RestApi SDK制作一个Winfrom软件，实现以下两个功能。TTS语音合成：可选择语速、音调、音量及发言人ASR语音识别：使用NAudio进行语音录制并识别Prepare在正式使用之前，我们需要在百度语音获取API key以及SDK文件。获取API Key在百度语音应用管理页面创建新应用。按照创建引导一步步来即可，注意在选择服务时同时勾选语音识别和语音合成，这样API Key就可以同时用于TTS和ASR了。下载离线SDK下载C#版本的RestApi SDK。Coding使用Nuget安装Newtonsoft.Json和NAudio、手动引用官方提供的ApiSdk.dll文件。接下来查看官方Demo中有关语音的SpeechDemo.cs文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556using System;using System.Collections.Generic;using System.IO;using Baidu.Aip.Speech;namespace Baidu.Aip.Demo&#123; class SpeechDemo &#123; private readonly Asr _asrClient; private readonly Tts _ttsClient; public SpeechDemo() &#123; _asrClient = new Asr("Api Key", "Secret Key"); _ttsClient = new Tts("Api Key", "Secret Key"); &#125; // 识别本地文件 public void AsrData() &#123; var data = File.ReadAllBytes("语音pcm文件地址"); var result = _asrClient.Recognize(data, "pcm", 16000); Console.Write(result); &#125; // 识别URL中的语音文件 public void AsrUrl() &#123; var result = _asrClient.Recoginze( "http://xxx.com/待识别的pcm文件地址", "http://xxx.com/识别结果回调地址", "pcm", 16000); Console.WriteLine(result); &#125; // 合成 public void Tts() &#123; // 可选参数 var option = new Dictionary&lt;string, object&gt;() &#123; &#123;"spd", 5&#125;, // 语速 &#123;"vol", 7&#125;, // 音量 &#123;"per", 4&#125; // 发音人，4：情感度丫丫童声 &#125;; var result = _ttsClient.Synthesis("众里寻他千百度", option); if (result.ErrorCode == 0) // 或 result.Success &#123; File.WriteAllBytes("合成的语音文件本地存储地址.mp3", result.Data); &#125; &#125; &#125;&#125;从代码示例中，我们可以看出语音识别API需要的源语音文件为pcm格式，我们使用NAudio来获取麦克风数据并保存为pcm格式以使用API，同样的也使用NAudio实时预览录制的数据和播放TTS合成的数据。将官方Demo封装成SpeechHelper12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758using System.Collections.Generic;using System.IO;using Baidu.Aip.Speech;namespace BaiduSpeechDemo&#123; static class SpeechHelper &#123; private static readonly Asr AsrClient; private static readonly Tts TtsClient; static SpeechHelper() &#123; AsrClient = new Asr("BWf8AWrvS5h6Y45NAOP3zaGp", "490737eca7a6ff4d20375d1696c7e548"); TtsClient = new Tts("BWf8AWrvS5h6Y45NAOP3zaGp", "490737eca7a6ff4d20375d1696c7e548"); &#125; // 识别本地文件 public static AsrResult AsrData(string path) &#123; var data = File.ReadAllBytes(path); var result = AsrClient.Recognize(data, "pcm", 8000); return result.ToObject&lt;AsrResult&gt;(); &#125; // 识别URL中的语音文件 public static AsrResult AsrUrl(string url, string callback = "") &#123; var result = AsrClient.Recoginze( url, callback, "pcm", 16000); return result.ToObject&lt;AsrResult&gt;(); &#125; // 合成 public static bool Tts(string input, string path, int spd = 5, int pit = 5, int vol = 6, int per = 4) &#123; // 可选参数 var option = new Dictionary&lt;string, object&gt; &#123; &#123;"spd", spd&#125;, // 语速，取值0-9，默认为5中语速 &#123;"pit", pit&#125;, // 音调，取值0-9，默认为5中语调 &#123;"vol", vol&#125;, // 音量，取值0-15，默认为5中音量 &#123;"per", per&#125; // 发音人选择, 0为普通女声，1为普通男生，3为情感合成-度逍遥，4为情感合成-度丫丫，默认为普通女声 &#125;; var result = TtsClient.Synthesis(input, option); if (result.Success) File.WriteAllBytes(path, result.Data); //Console.WriteLine(result.Serialize()); return result.Success; &#125; &#125;&#125;NAudio录制麦克风数据为pcm格式并实时预览NAudio提供了同时进行录制和播放的Demo，其中的SavingWaveProvider可以直接拿来使用，只要传入合适的参数即可将保存文件的格式由示例中的wav改为pcm，下面是修改后的调用代码。具体则是修改WaveIn的声明：123// 设置记录器// WaveFormat.CreateCustomFormat 参数依次为 格式\采样率\声道\每秒平均码率\单位采样点的字节数\采样位数_recorder = new WaveIn &#123; WaveFormat = WaveFormat.CreateCustomFormat(WaveFormatEncoding.Pcm, 8000, 1, 16000, 2, 16) &#125;;下面给出修改后的开始录制和结束录制的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344private WaveIn _recorder;private BufferedWaveProvider _bufferedWaveProvider;private SavingWaveProvider _savingWaveProvider;private WaveOut _player;private void OnStartRecordingClick(object sender, EventArgs e)&#123; // 设置记录器 // 参数依次为 格式\采样率\声道\每秒平均码率\单位采样点的字节数\采样位数 _recorder = new WaveIn &#123; WaveFormat = WaveFormat.CreateCustomFormat(WaveFormatEncoding.Pcm, 8000, 1, 16000, 2, 16) &#125;; _recorder.DataAvailable += RecorderOnDataAvailable; // 建立我们的信号链 _bufferedWaveProvider = new BufferedWaveProvider(_recorder.WaveFormat); _fileName = Path.Combine("temp", Guid.NewGuid() + ".pcm"); _savingWaveProvider = new SavingWaveProvider(_bufferedWaveProvider, _fileName); //设置播放 _player = new WaveOut(); _player.Init(_savingWaveProvider); // 开始播放和录制 _player.Play(); _recorder.StartRecording();&#125;private void RecorderOnDataAvailable(object sender, WaveInEventArgs waveInEventArgs)&#123; _bufferedWaveProvider.AddSamples(waveInEventArgs.Buffer, 0, waveInEventArgs.BytesRecorded);&#125;private void OnStopRecordingClick(object sender, EventArgs e)&#123; // 停止录制 _recorder.StopRecording(); // 停止播放 _player.Stop(); // 最终完成 WAV 文件 _savingWaveProvider.Dispose(); // 请求百度ASR API var a = SpeechHelper.AsrData(_fileName);&#125;TTS完成窗体界面拖好TTS选项的布局完成按钮点击事件的逻辑12345678910111213141516171819202122232425private void btnTts_Click(object sender, EventArgs e)&#123; // 临时保存路径 var musicPath = Path.Combine("temp", Guid.NewGuid() + ".mp3"); // 发言人 var per = cbPer.SelectedIndex &gt;= 2 ? cbPer.SelectedIndex + 1 : cbPer.SelectedIndex; //调用Baidu TTS Api if (!SpeechHelper.Tts(tbContext.Text, musicPath, (int)nudSpd.Value, (int)nudPit.Value, (int)nudVol.Value, per)) return; //播放请求得到的结果 IWavePlayer waveOutDevice = new WaveOut(); var audioFileReader = new AudioFileReader(musicPath); waveOutDevice.Init(audioFileReader); waveOutDevice.Play(); //播放结束后销毁播放对象 waveOutDevice.PlaybackStopped += delegate &#123; waveOutDevice?.Stop(); waveOutDevice?.Dispose(); waveOutDevice = null; &#125;;&#125;Complete最终成品如下：完整代码托管在GitHub代码中我自己的Api Key并没有删除，望手下留情，别给我搞封了。]]></content>
      <categories>
        <category>踩坑笔记</category>
      </categories>
      <tags>
        <tag>语音识别</tag>
        <tag>ASR</tag>
        <tag>TTS</tag>
        <tag>NAudio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.Net 使用GeoIP2获取IP的地理位置信息]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8GeoIP2%E8%8E%B7%E5%8F%96IP%E7%9A%84%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%E4%BF%A1%E6%81%AF.html</url>
    <content type="text"><![CDATA[GeoIP® 数据库&amp;服务：业界领先的IP智能，MaxMind GeoIP2 服务能识别互联网用户的地点位置与其他特征，应用广泛，包括个性化定制内容、诈欺检测、广告定向、网站流量分析、执行规定、地理目标定位、地理围栏定位 (geo-fencing)以及数字版权管理。MaxMind是IP地理定位准确性的行业领导者.按照不同国家，比较MaxMind GeoIP2数据服务与数据库的准确性。GeoIP2精准版服务向您提供本公司最准确的数据，为您省去在您服务器上托管数据或部署更新项目的麻烦。 我们的精准版服务产品可通过API或文件手动上传方式使用，为您提供最新的数据。MaxMind的GeoIP2数据库为大容量环境提供IP智能数据。 通过在本地托管我们的数据库，您既可避免网络延迟问题，又可避免按每次查询计价的费用。GeoIP 分为商业版和免费版，免费版比商业版精度差了许多，经测试对于城市定位确实有差距，能否接受看你的精度要求！免费版介绍免费版仅有数据库服务，目前有两个版本1、GeoLite 版本，网上流传较广，数据库类型为 dat 格式文件，库文件较小、未进行精准度测试且不再更新。2、GeoLite2版本，目前最新版本，数据库文件为 mmdb 格式或csv格式。GeoLite2 特性下载数据库GeoIP数据库GeoIP2数据库本地维护的数据库适用于容量大、延迟性低的环境，购买机构可以获取站点许可证，即可在公司内进行无限次使用。对于选定地点，含有简体中文、法文、德文、日文、西班牙文、巴西葡萄牙文及俄文版的本地化名称为多数常用语言提供开放源代码的API可提供自动更新GeoLite2 开源数据库数据库GeoLite2数据库是 GeoLite 数据库的开源版，GeoIP2的免费版，准确率稍低于付费版，其前身 GeoLite 现行数据库已于 2019年1月2日 不再提供服务)技术支持MaxMind 不为免费数据库提供技术支持。如果您有问题请前往stackoverflow’s GeoIP问题以及解答。许可证GeoLite2使用的是开源许可证：Creative Commons Attribution-ShareAlike 3.0 Unported License. 您只需要在页面中添加如下代码即可：12该产品使用MaxMind公司的GeoLite2数据，可以在此获取：&lt;a href="http://www.maxmind.com"&gt;http://www.maxmind.com&lt;/a&gt;.官方提供 二次销售许可证.下载数据库MaxMind DB 二进制格式, 压缩CSV 格式, 压缩GeoLite2 城市Download (md5 校验)Download (md5 校验)GeoLite2 国家Download (md5 校验)Download (md5 校验)GeoLite2 ASN（自治系统）Download (md5 校验)Download (md5 校验)更新数据库你可以使用 GeoIP 更新来自动更新您的数据库。MaxMind API 接口参阅 GeoIP2 可下载数据库 以下载API。付费版和免费版API互通。.Net调用MaxMind API.Net调用MaxMind API可以使用官方发布的nuget包，官方提供了文档和源码地址。安装Nuget包1Install-Package MaxMind.GeoIP2代码调用因GeoLite2只提供了City和Country两个数据库版本。故只能进行这两种调用方式，调用方式非常简单City1234using (var reader = new DatabaseReader("GeoLite2-City.mmdb"))&#123; var city = reader.City("65.49.134.29");&#125;city即为查询结果，结构如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&#123; "city": &#123; "geoname_id": 5125591, "names": &#123; "en": "Macedon" &#125; &#125;, "continent": &#123; "code": "NA", "geoname_id": 6255149, "names": &#123; "de": "Nordamerika", "en": "North America", "es": "Norteamérica", "fr": "Amérique du Nord", "ja": "北アメリカ", "pt-BR": "América do Norte", "ru": "Северная Америка", "zh-CN": "北美洲" &#125; &#125;, "country": &#123; "geoname_id": 6252001, "is_in_european_union": false, "iso_code": "US", "names": &#123; "de": "USA", "en": "United States", "es": "Estados Unidos", "fr": "États-Unis", "ja": "アメリカ合衆国", "pt-BR": "Estados Unidos", "ru": "США", "zh-CN": "美国" &#125; &#125;, "location": &#123; "accuracy_radius": 20, "latitude": 43.1089, "longitude": -77.3226, "metro_code": 538, "time_zone": "America/New_York" &#125;, "maxmind": &#123;&#125;, "postal": &#123; "code": "14502" &#125;, "registered_country": &#123; "geoname_id": 6252001, "is_in_european_union": false, "iso_code": "US", "names": &#123; "de": "USA", "en": "United States", "es": "Estados Unidos", "fr": "États-Unis", "ja": "アメリカ合衆国", "pt-BR": "Estados Unidos", "ru": "США", "zh-CN": "美国" &#125; &#125;, "represented_country": &#123; "is_in_european_union": false, "names": &#123;&#125; &#125;, "subdivisions": [ &#123; "geoname_id": 5128638, "iso_code": "NY", "names": &#123; "de": "New York", "en": "New York", "es": "Nueva York", "fr": "New York", "ja": "ニューヨーク州", "pt-BR": "Nova Iorque", "ru": "Нью-Йорк", "zh-CN": "纽约州" &#125; &#125; ], "traits": &#123; "ip_address": "66.66.66.66", "is_anonymous": false, "is_anonymous_proxy": false, "is_anonymous_vpn": false, "is_hosting_provider": false, "is_legitimate_proxy": false, "is_public_proxy": false, "is_satellite_provider": false, "is_tor_exit_node": false &#125;&#125;其中包含了比较详细的信息，有具体的经纬度。Country1234using (var reader = new DatabaseReader("GeoLite2-Country.mmdb"))&#123; var country = reader.Country("66.66.66.66");&#125;country即为查询结果，结构如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&#123; "continent": &#123; "code": "NA", "geoname_id": 6255149, "names": &#123; "de": "Nordamerika", "en": "North America", "es": "Norteamérica", "fr": "Amérique du Nord", "ja": "北アメリカ", "pt-BR": "América do Norte", "ru": "Северная Америка", "zh-CN": "北美洲" &#125; &#125;, "country": &#123; "geoname_id": 6252001, "is_in_european_union": false, "iso_code": "US", "names": &#123; "de": "USA", "en": "United States", "es": "Estados Unidos", "fr": "États-Unis", "ja": "アメリカ合衆国", "pt-BR": "Estados Unidos", "ru": "США", "zh-CN": "美国" &#125; &#125;, "maxmind": &#123;&#125;, "registered_country": &#123; "geoname_id": 6252001, "is_in_european_union": false, "iso_code": "US", "names": &#123; "de": "USA", "en": "United States", "es": "Estados Unidos", "fr": "États-Unis", "ja": "アメリカ合衆国", "pt-BR": "Estados Unidos", "ru": "США", "zh-CN": "美国" &#125; &#125;, "represented_country": &#123; "is_in_european_union": false, "names": &#123;&#125; &#125;, "traits": &#123; "ip_address": "66.66.66.66", "is_anonymous": false, "is_anonymous_proxy": false, "is_anonymous_vpn": false, "is_hosting_provider": false, "is_legitimate_proxy": false, "is_public_proxy": false, "is_satellite_provider": false, "is_tor_exit_node": false &#125;&#125;country数据库中的信息的详细程度较之city就差了很多，但数据库大小仅为city的 1/20，视使用场景来决定使用对应的数据库。]]></content>
      <categories>
        <category>踩坑笔记</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>GeoIP2</tag>
        <tag>IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查看当前IP和归属地的方法]]></title>
    <url>%2F%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8DIP%E5%92%8C%E5%BD%92%E5%B1%9E%E5%9C%B0%E7%9A%84%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[可以通过http协议进行get请求来获得当前IP及归属地信息。ip138Xpath获取文字信息1//centerwhatismyipXpath获取信息:IP地址1//body/span[1]来源地区1//body/span[2]优劣二者网页大小差不多，均为300+KB。ip138 为国内服务商，对国内IP地址可以精确到市级，并且会包含运营商信息，不过信息包含在一个标签中，需要获取之后自行截取。whatismyip 为台湾网站，只能精确到国家，但是比较方便的是IP地址和来源是包含在两个标签中的，获取更为方便。]]></content>
      <categories>
        <category>踩坑笔记</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>IP</tag>
        <tag>软件心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#读取CPU序列号、硬盘ID、网卡MAC地址，生成机器码]]></title>
    <url>%2FCx%E8%AF%BB%E5%8F%96CPU%E5%BA%8F%E5%88%97%E5%8F%B7%E3%80%81%E7%A1%AC%E7%9B%98ID%E3%80%81%E7%BD%91%E5%8D%A1MAC%E5%9C%B0%E5%9D%80%EF%BC%8C%E7%94%9F%E6%88%90%E6%9C%BA%E5%99%A8%E7%A0%81.html</url>
    <content type="text"><![CDATA[话不多说，直接上代码，类库中的机器码使用序列号、硬盘ID、网卡MAC地址组合取MD5生成。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283using System;using System.Linq;using System.Management;using System.Security.Cryptography;using System.Text;namespace WayneShao.Common&#123; internal static class MachineCode &#123; private static string _machineCodeString; public static string Value &#123; get &#123; if (string.IsNullOrWhiteSpace(_machineCodeString)) _machineCodeString = GetMD5($"&#123;CPUCode&#125;_&#123;HDId&#125;_&#123;MacAddress&#125;"); return _machineCodeString; &#125; &#125; private static string _cpuCode; public static string CPUCode =&gt; _cpuCode ?? (_cpuCode = GetCPUInfo()); private static string _hdId; public static string HDId =&gt; _hdId ?? (_hdId = GetHDid()); private static string _macAddress; public static string MacAddress =&gt; _macAddress ?? (_macAddress = GetMACAddress()); /// &lt;summary&gt; /// 获取cpu序列号 /// &lt;/summary&gt; /// &lt;returns&gt; string &lt;/returns&gt; private static string GetCPUInfo() &#123; using (var cimobject = new ManagementClass("Win32_Processor")) &#123; var hdids = cimobject.GetInstances().Cast&lt;ManagementObject&gt;().Select(o =&gt; o.Properties["ProcessorId"].Value).Cast&lt;string&gt;().ToArray(); return hdids.Any() ? hdids.First() : string.Empty; &#125; &#125; /// &lt;summary&gt; /// 获取硬盘ID /// &lt;/summary&gt; /// &lt;returns&gt; string &lt;/returns&gt; private static string GetHDid() &#123; using (var cimobject1 = new ManagementClass("Win32_DiskDrive")) &#123; var hdids = cimobject1.GetInstances().Cast&lt;ManagementObject&gt;().Select(o =&gt; o.Properties["Model"].Value).Cast&lt;string&gt;().ToArray(); return hdids.Any() ? hdids.First() : string.Empty; &#125; &#125; /// &lt;summary&gt; /// 获取网卡硬件地址 /// &lt;/summary&gt; /// &lt;returns&gt; string &lt;/returns&gt; private static string GetMACAddress() &#123; using (var mc = new ManagementClass("Win32_NetworkAdapterConfiguration")) &#123; var macs = mc.GetInstances().Cast&lt;ManagementObject&gt;().Where(o =&gt; (bool)o["IPEnabled"]).Select(o =&gt; o["MacAddress"].ToString()).ToArray(); return macs.Any() ? macs.First() : string.Empty; &#125; &#125; /// &lt;summary&gt; /// 获取字符串的MD5值 /// &lt;/summary&gt; /// &lt;returns&gt; string &lt;/returns&gt; public static string GetMD5(string source) &#123; var result = Encoding.Default.GetBytes(source); var md5 = new MD5CryptoServiceProvider(); var output = md5.ComputeHash(result); return BitConverter.ToString(output).Replace("-", "").ToLower(); &#125; &#125;&#125;另附MSDN中关于 WMI Class 的文档供大家参考https://msdn.microsoft.com/zh-cn/library/aa394173(VS.85).aspx]]></content>
      <categories>
        <category>踩坑笔记</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>硬件信息</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【单例】使用同步基元变量来检测程序是否已运行]]></title>
    <url>%2Fx%E5%8D%95%E4%BE%8Bx%E4%BD%BF%E7%94%A8%E5%90%8C%E6%AD%A5%E5%9F%BA%E5%85%83%E5%8F%98%E9%87%8F%E6%9D%A5%E6%A3%80%E6%B5%8B%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%90%A6%E5%B7%B2%E8%BF%90%E8%A1%8C.html</url>
    <content type="text"><![CDATA[1234567891011121314151617181920static class Program&#123; /// &lt;summary&gt; /// 应用程序的主入口点。 /// &lt;/summary&gt; [STAThread] static void Main() &#123; var instance = new Mutex(true, "SingleStart", out bool createdNew); //同步基元变量 if (createdNew) &#123; Application.Run(new Form()); instance.ReleaseMutex(); &#125; else &#123; Application.Exit(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>踩坑笔记</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Winform</tag>
        <tag>单例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用委托解决方法的跨线程调用问题]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8%E5%A7%94%E6%89%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E7%9A%84%E8%B7%A8%E7%BA%BF%E7%A8%8B%E8%B0%83%E7%94%A8%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[123456789101112131415161718//声明和需进行跨线程调用的方法相同形参表的委托public delegate void AddStatusInfoToFormCallback(string str);private void AddStatusInfoToForm(string str)&#123; //检测调用控件的线程和创建控件的线程是否相同 //如果调用控件的线程和创建创建控件的线程不是同一个则为True if (InvokeRequired) &#123; //使用委托调用本方法 var d = new AddStatusInfoToFormCallback(AddStatusInfoToForm); Invoke(d, str); &#125; else &#123; //当前线程调用 Controls.Clear(); &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Winform</tag>
        <tag>跨线程</tag>
        <tag>委托</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rtmp/Hls直播、点播服务器部署与配置]]></title>
    <url>%2FRtmp-Hls%E7%9B%B4%E6%92%AD%E3%80%81%E7%82%B9%E6%92%AD%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E4%B8%8E%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[测试使用的系统为CentOS7.3、所有文章中涉及到的包打包在以下地址:链接：http://pan.baidu.com/s/1nuF3gLV 密码：fo8qNginx-Rtmp-Module 安装1). 安装依赖包1yum -y install gcc glibc glibc-devel make nasm pkgconfig openssl-devel expat-devel gettext-devel libtool perl-Digest-SHA1.x86_642). yum 安装相关工具包及 ffmpeg 依赖包1yum -y install git zlib pcre openssl3). 手动编译安装工具包和依赖包a). yadmi1234tar xzvf yamdi-1.9.tar.gzcd yamdi-1.9make &amp;&amp; make installcd ..b). yasm12345tar xzvf yasm-1.3.0.tar.gzcd yasm-1.3.0./configuremake &amp;&amp; make installcd ..c). x26412345tar -xjvf x264.tar.bz2cd x264-snapshot-20170111-2245./configure --enable-shared make &amp;&amp; make installcd ..d). lame12345 tar xzvf lame-3.99.5.tar.gz cd lame-3.99.5./configure --enable-nasm make &amp;&amp; make install cd ..e). faad212345tar zxvf faad2-2.7.tar.gzcd faad2-2.7./configuremake &amp;&amp; make installcd ..f). faac12345tar zxvf faac-1.28.tar.gzcd faac-1.28./configuremake &amp;&amp; make installcd ..g). xvid12345tar zxvf xvidcore-1.3.3.tar.gzcd xvidcore/build/generic./configuremake &amp;&amp; make installcd ..h). ffmpeg12345tar -xjvf ffmpeg-3.2.4.tar.bz2cd ffmpeg-3.2.4./configure --prefix=/opt/ffmpeg/ --enable-version3 --enable-libvpx --enable-libmp3lame --enable-libvorbis --enable-libx264 --enable-libxvid --enable-shared --enable-gpl --enable-postproc--enable-nonfree --enable-avfilter --enable-pthreadsmake &amp;&amp; make installcd ..i). 修改/etc/ld.so.conf如下:123456789include ld.so.conf.d/*.conf/lib/lib64/usr/lib/usr/lib64/usr/local/lib/usr/local/lib64/opt/ffmpeg/libldconfig4). 安装 Nginx1234567tar zxvf nginx-1.9.9.tar.gzunzip nginx-rtmp-module-master.ziptar zxvf openssl-1.0.2k.tar.gzcd nginx-1.9.9./configure --add-module=../nginx-rtmp-module-master --without-http_rewrite_module --with-openssl=../openssl-1.0.2kmake &amp; make installcd ..nginx.conf配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108 # nginx.conf Startworker_processes 1; # nginx对外提供 web 服务时的 worker 进程数error_log logs/error.log debug; # 错误日志路径pid logs/nginx.pid; # pid 文件路径worker_rlimit_nofile 51200; # worker 进程的最大打开文件数限制events &#123; # events 模块中包含 nginx 中所有处理连接的设置。 use epoll; # 设置用于复用客户端线程的轮询方法。 worker_connections 51200; #由一个 worker 进程同时打开的最大连接数。&#125;rtmp_auto_push on; # 切换自动推送(多 worker 直播流)模式rtmp_auto_push_reconnect 1s; # 当 worker 被干掉时设置自动推送连接超时时间。默认为 100 毫秒。rtmp &#123; # 保存所有 RTMP 配置的块。 server &#123; # 声明一个 RTMP 实例。 listen 1935; # 监听的端口号 chunk_size 4096; # 流整合的最大的块大小。默认值为 4096。 application vod &#123; # 创建一个 RTMP 应用。 play /opt/media/nginxrtmp/flv; # 点播文件路径 &#125; application live &#123; # 创建一个 RTMP 应用。 live on; # 是否直播 hls on; # 是否开启hls hls_path /usr/local/nginx/html/live; # 设置 HLS 播放列表和分段目录。 hls_fragment 1s; # 设置 HLS 分段长度。 max_connections 1024; # 最大连接数 hls_playlist_length 30s; # HLS 播放列表长度 hls_sync 100ms; # HLS 时间戳同步阈值 meta copy; # 是否发送元数据到客户端 recorder manual &#123; # 创建一个录制应用 record all manual; # 设置录制模式 record_suffix %Y-%m-%d-%H_%M_%S.flv; # 设置录制文件名 record_max_size 6200000K; # 设置录制文件的最大值 record_path /usr/local/nginx/html/Rec; # 指定录制的 flv 文件存放目录 &#125; #record keyframes; #record_path /tmp; #record_max_size 128K; #record_interval 30s; #record_suffix .this.is.flv; #on_publish http://localhost:8080/publish; #on_play http://localhost:8080/play; #on_record_done http://localhost:8080/record_done; &#125; # application hls &#123; # live on; # hls on; # hls_path /tmp/app; # hls_fragment 5s; # &#125; # application hls&#123; # live on; # hls on; # hls_path /usr/local/nginx/html/hls; # hls_fragment 5s; # &#125; &#125;&#125;http &#123; server &#123; listen 5000; keepalive_timeout 65; location /stat &#123; rtmp_stat all; rtmp_stat_stylesheet stat.xsl; &#125; location /stat.xsl &#123; root /opt/nginx-rtmp-server/nginx-rtmp-module/; &#125; location /control &#123; rtmp_control all; &#125; location /rtmp-publisher &#123; root /opt/nginx-rtmp-server/nginx-rtmp-module/test; &#125; location / &#123; root /opt/nginx-rtmp-server/nginx-rtmp-module/test/www; &#125; location /crplayer &#123; root /opt/nginx-rtmp-server/nginx-rtmp-module/test; &#125; location /live &#123; #server hls fragments types&#123; application/vnd.apple.mpegurl m3u8; video/mp2t ts; &#125; root html; expires -1; &#125; &#125;&#125;# nginx.conf End运行Nginx服务1/usr/local/nginx/sbin/nginx -c /root/nginx/nginx.conf]]></content>
      <categories>
        <category>踩坑笔记</category>
      </categories>
      <tags>
        <tag>nginx-rtmp</tag>
        <tag>流媒体</tag>
        <tag>hls</tag>
        <tag>点播</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于.Net 调用广州医保HG_Interface.dll调用的一些总结（外部组件异常）]]></title>
    <url>%2F%E5%85%B3%E4%BA%8ECx%E8%B0%83%E7%94%A8%E5%B9%BF%E5%B7%9E%E5%8C%BB%E4%BF%9DHG_Interface.dll%E8%B0%83%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93%EF%BC%88%E5%A4%96%E9%83%A8%E7%BB%84%E4%BB%B6%E5%BC%82%E5%B8%B8%EF%BC%89.html</url>
    <content type="text"><![CDATA[开始做的时候也遇到了奇葩的情况、创智提供的dll只能在有UI的Winform、WPF上使用，WebForm、WPF、WebService完全没办法使用，Console在加上了[STAThread]的线程Attribute之后也可以成功调用，推测和dll使用MFC编写有关、但是各种引入MFC的dll均无果，一筹莫展之际把问题提到了交流群里，吾乐吧的牛总给出了可行的解决方案—-使用WCF来调用。有了具体解决方案一切就顺风顺水了，但是完成程序之后又出现了奇葩的问题，部署到服务器也会出现外部组件异常的问题，本机调试可以部署却不行，很明显就是环境的问题了，由于dll为非托管dll，我们无法从错误中得到有效的错误信息，从环境下手尝试解决，虽然最终成功了，但是目前还并不清楚到底是因为什么，这里的经验是MSSOAP、MSXML、WebMatrix一定要装，如果还是不能成功运行可以考虑安装VS环境试试看。期待能有高手给出具体的解决之道。]]></content>
      <categories>
        <category>踩坑笔记</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>广州医保</tag>
        <tag>HG_Interface.dll</tag>
        <tag>外部组件异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redhat7.3配置163 yum源]]></title>
    <url>%2Fredhat7.3%E9%85%8D%E7%BD%AE163-yum%E6%BA%90.html</url>
    <content type="text"><![CDATA[redhat 的更新包只对注册的用户生效，所以我们需要自己手动更改成CentOS 的更新包，CentOS几乎和redhat是一样的，所以无需担心软件包是否可安装，安装之后是否有问题。删除redhat原有的yum首先删除redhat原有的yum ，因为redhat 原本的yum 没有注册为redhat用户是用不了的。12rpm -aq|grep yum|xargs rpm -e --nodeps rpm -aq|grep python-iniparse|xargs rpm -e --nodeps下载163的yum 安装包1234wget http://mirrors.163.com/centos/7.3.1611/os/x86_64/Packages/yum-3.4.3-150.el7.centos.noarch.rpmwget http://mirrors.163.com/centos/7.3.1611/os/x86_64/Packages/python-iniparse-0.4-9.el7.noarch.rpmwget http://mirrors.163.com/centos/7.3.1611/os/x86_64/Packages/yum-metadata-parser-1.1.4-10.el7.x86_64.rpmwget http://mirrors.163.com/centos/7.3.1611/os/x86_64/Packages/yum-plugin-fastestmirror-1.1.31-40.el7.noarch.rpm安装下载的rpm包1rpm -ivh *.rpm创建文件/etc/yum.repos.d/rhel-debuginfo.repo并写入1234567891011121314151617181920212223242526[base]name=CentOS-$releasever - Basebaseurl=http://mirrors.163.com/centos/7.3.1611/os/$basearch/gpgcheck=1gpgkey=http://mirrors.163.com/centos/7.3.1611/os/x86_64/RPM-GPG-KEY-CentOS-7 #released updates[updates]name=CentOS-$releasever - Updatesbaseurl=http://mirrors.163.com/centos/7.3.1611/updates/$basearch/gpgcheck=1gpgkey=http://mirrors.163.com/centos/7.3.1611/os/x86_64/RPM-GPG-KEY-CentOS-7 [extras]name=CentOS-$releasever - Extrasbaseurl=http://mirrors.163.com/centos/7.3.1611/extras//$basearch/gpgcheck=1gpgkey=http://mirrors.163.com/centos/7.3.1611/os/x86_64/RPM-GPG-KEY-CentOS-7 [centosplus]name=CentOS-$releasever - Plusbaseurl=http://mirrors.163.com/centos/7.3.1611/centosplus//$basearch/gpgcheck=1enabled=0yum clean all1yum clean allyum update 测试。1yum update安装 epel 源1yum install epel-release]]></content>
      <categories>
        <category>踩坑笔记</category>
      </categories>
      <tags>
        <tag>redhat</tag>
        <tag>yum源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块化InnoSetup依赖项安装]]></title>
    <url>%2F%E6%A8%A1%E5%9D%97%E5%8C%96InnoSetup%E4%BE%9D%E8%B5%96%E9%A1%B9%E5%AE%89%E8%A3%85.html</url>
    <content type="text"><![CDATA[原文在这里:http://www.codeproject.com/Articles/20868/NET-Framework-Installer-for-InnoSetup源文件地址:http://www.codeproject.com/KB/install/dotnetfx_innosetup_instal/innodependencyinstaller.zip源文件需要注册登录CodeProject才能下载说明:通过添加模块化innosetup脚本来自动下载和安装各种依赖项 如.NET Framework 、VC++运行环境等。源代码是模块化的，结构如下：setup.iss - 包含基本设置，其中包含所需的模块（产品）。你需要把所需的模块在顶部使用#include命令包含在源代码中,例如：#include “scripts\products\dotnetfx11.iss”然后你只需要在[Code]段调用它们的main函数,如：dotnetfx11();bin - 包含安装程序的最终输出src - 包含您的程序的应用程序文件scriptsproducts.iss - 包含产品脚本的共享代码。 您只需要更改[CustomMessages]部分和[Files]部分（包括isxdl语言文件）isxdl - 包含用于设置（如果有要下载的内容）及其语言文件（例如german.ini）的下载器DLL。 这是您可以放置​​isxdldownloader的语言文件的地方。products - 包含应用程序所需的产品的脚本（例如.NET Framework 2.0）dotnetfx11.iss - .NET Framework 1.1dotnetfx11lp.iss - .NET Framework 1.1 Language Packdotnetfx11sp1.iss - .NET Framework 1.1 + Service Pack 1dotnetfx20.iss - .NET Framework 2.0dotnetfx20lp.iss - .NET Framework 2.0 Language Packdotnetfx20sp1.iss - .NET Framework 2.0 + Service Pack 1dotnetfx20sp1lp.iss - .NET Framework 2.0 Service Pack 1 Language Packdotnetfx20sp2.iss - .NET Framework 2.0 + Service Pack 2dotnetfx20sp2lp.iss - .NET Framework 2.0 Service Pack 2 Language Packdotnetfx35.iss - .NET Framework 3.5dotnetfx35lp.iss - .NET Framework 3.5 Language Packdotnetfx35sp1.iss - .NET Framework 3.5 + Service Pack 1dotnetfx35sp1lp.iss - .NET Framework 3.5 Service Pack 1 Language Packdotnetfx40client.iss - .NET Framework 4.0 Client Profiledotnetfx40full.iss - .NET Framework 4.0 Fulldotnetfx46.iss - .NET Framework 4.6ie6.iss - Internet Explorer 6iis.iss - Internet Information Services (just a check if it is installed)jet4sp8.iss - Jet 4 + Service Pack 8kb835732.iss - Security Update (KB835732) which is required by .NET Framework 2.0 Service Pack 1 on Windows 2000 Service Pack 4mdac28.iss - Microsoft Data Access Components (MDAC) 2.8msi20.iss - Windows Installer 2.0msi31.iss - Windows Installer 3.1msi45.iss - Windows Installer 4.5sql2005express.iss - SQL Server 2005 Express + Service Pack 3sql2008express.iss - SQL Server 2008 Express R2sqlcompact35sp2.iss - SQL Server Compact 3.5 + Service Pack 2vcredist2005.iss - Visual C++ 2005 Redistributablevcredist2008.iss - Visual C++ 2008 Redistributablevcredist2010.iss - Visual C++ 2010 Redistributablevcredist2012.iss - Visual C++ 2012 Redistributablevcredist2013.iss - Visual C++ 2013 Redistributablevcredist2015.iss - Visual C++ 2015 Redistributablewic.iss - Windows Imaging Componentwinversion.iss - helper functions to determine the installed Windows versionfileversion.iss - helper functions to determine the version of a filestringversion.iss - helper functions to correctly parse a version stringdotnetfxversion.iss - helper functions to determine the installed .NET Framework version including service packsmsiproduct.iss - helper functions to check for installed msi products你很可能需要调整setup.iss，以适应不同Windows版本所需的依赖项。如果依赖项没有安装，安装过程会检查相关依赖项的安装文件是否存在于.\MyProgramDependencies.文件夹下。如果不存在那么程序将会自动下载。用于脚本的应用程序包括：Inno Setup - (版本5.5.5)ISTool - Inno Setup的扩展组件。但是我只需要 isxdl.dll downloader (版本5.3.0)]]></content>
      <categories>
        <category>踩坑笔记</category>
      </categories>
      <tags>
        <tag>InnoSetup</tag>
        <tag>安装包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【迷宫中的算法实践】迷宫生成算法——递归分割算法]]></title>
    <url>%2Fx%E8%BF%B7%E5%AE%AB%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5x%E8%BF%B7%E5%AE%AB%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%80%92%E5%BD%92%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[Recursive division methodMazes can be created with recursive division, an algorithm which works as follows: Begin with the maze’s space with no walls. Call this a chamber. Divide the chamber with a randomly positioned wall (or multiple walls) where each wall contains a randomly positioned passage opening within it. Then recursively repeat the process on the subchambers until all chambers are minimum sized. This method results in mazes with long straight walls crossing their space, making it easier to see which areas to avoid.For example, in a rectangular maze, build at random points two walls that are perpendicular to each other. These two walls divide the large chamber into four smaller chambers separated by four walls. Choose three of the four walls at random, and open a one cell-wide hole at a random point in each of the three. Continue in this manner recursively, until every chamber has a width of one cell in either of the two directions.递归分割算法可以用递归分割法创建迷宫，算法的工作原理如下：开始创建迷宫，使整个空间没有壁，我们称之为“室”。在随机位置生成壁将室分割为两个子室，并在壁上随机开孔，使子室联通。重复步骤2，直到所有子室全部不可分割（即子室某一个维度等于1）。例如，在矩形迷宫中，在任意点建立彼此垂直的两个壁。 这两个壁将大腔室分成由四个壁分开的四个较小腔室。 随机选择四个墙壁中的三个，并在三个墙壁的随机点处打开一个单元格的孔。 继续以这种方式递归，直到每个室在两个方向中的任一个方向上具有一个单元的宽度。代码实现下面我们来做C#的代码实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/// &lt;summary&gt;/// 递归回溯法迷宫生成法/// &lt;/summary&gt;/// &lt;param name="startX"&gt;&lt;/param&gt;/// &lt;param name="startY"&gt;&lt;/param&gt;/// &lt;param name="widthLimit"&gt;&lt;/param&gt;/// &lt;param name="heightLimit"&gt;&lt;/param&gt;private void RecursiveBacktrack(int startX, int startY, int widthLimit, int heightLimit)&#123; PathStack = new Stack&lt;Point&gt;(); //周围未连通格坐标 int[] blockPos = new int[4]; //周围未标记格的数量 int blockNum = 0; //将起点作为当前格 int currentX = startX; int currentY = startY; //标记起点 MazeMap[currentX, currentY] = UnBlock; CreateScript.Add(new ScriptPoint(new Point(currentX, currentY), false)); do &#123; //检测周围有没有未连通的格子 blockNum = 0; //检查上方 if (currentY &gt; 1 &amp;&amp; MazeMap[currentX, currentY - 2] == Block) &#123; blockPos[blockNum] = 0; blockNum++; &#125; //检查右侧 if (currentX &lt; widthLimit &amp;&amp; MazeMap[currentX + 2, currentY] == Block) &#123; blockPos[blockNum] = 1; blockNum++; &#125; //检查下方 if (currentY &lt; heightLimit &amp;&amp; MazeMap[currentX, currentY + 2] == Block) &#123; blockPos[blockNum] = 2; blockNum++; &#125; //检查左侧 if (currentX &gt; 1 &amp;&amp; MazeMap[currentX - 2, currentY] == Block) &#123; blockPos[blockNum] = 3; blockNum++; &#125; //选出下一个当前格 if (blockNum &gt; 0) &#123; //随机选择一个邻格 blockNum = _r.Next(0, blockNum); //把当前格入栈 PathStack.Push(new Point(currentX, currentY)); //连通邻格，并将邻格指定为当前格 switch (blockPos[blockNum]) &#123; case 0: MazeMap[currentX, currentY - 1] = UnBlock; CreateScript.Add(new ScriptPoint(new Point(currentX, currentY - 1), false)); currentY -= 2; break; case 1: MazeMap[currentX + 1, currentY] = UnBlock; CreateScript.Add(new ScriptPoint(new Point(currentX + 1, currentY), false)); currentX += 2; break; case 2: MazeMap[currentX, currentY + 1] = UnBlock; CreateScript.Add(new ScriptPoint(new Point(currentX, currentY + 1), false)); currentY += 2; break; case 3: MazeMap[currentX - 1, currentY] = UnBlock; CreateScript.Add(new ScriptPoint(new Point(currentX - 1, currentY), false)); currentX -= 2; break; &#125; //标记当前格 MazeMap[currentX, currentY] = UnBlock; CreateScript.Add(new ScriptPoint(new Point(currentX, currentY), false)); &#125; else if (PathStack.Count &gt; 0) &#123; //将栈顶作为当前格 Point top = PathStack.Pop(); currentY = top.Y; currentX = top.X; &#125; &#125; while (PathStack.Count &gt; 0);&#125;]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>迷宫</tag>
        <tag>递归分割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【新手学Java】使用beanUtils控制javabean]]></title>
    <url>%2Fx%E6%96%B0%E6%89%8B%E5%AD%A6Javax%E4%BD%BF%E7%94%A8beanUtils%E6%8E%A7%E5%88%B6javabean.html</url>
    <content type="text"><![CDATA[使用beanUtils控制javabean使用BeanUtils设置/读取属性的值以及默认支持的自动转化:12345678910111213@Test//使用BeanUtils设置/读取属性的值以及自动转化public void test1() throws IllegalAccessException, InvocationTargetException, NoSuchMethodException&#123; Person p=new Person(); //使用BeanUtils设置属性的值 BeanUtils.setProperty(p, "username", "李四"); //使用BeanUtils读取属性的值 System.out.println(BeanUtils.getProperty(p, "username");); //类型不同依然可以自动转化,BeanUtils默认支持八种基本类型的转换 BeanUtils.setProperty(p,"age", "123"); System.out.println(p.getAge()); &#125;注册已有的转化器来完成复杂类型的自动转化:12345678910111213@Test//注册已有的转化器来完成复杂类型的自动转化public void test3() throws IllegalAccessException, InvocationTargetException&#123; Person p=new Person(); String birthday="1995-05-05"; //注册Apache提供的时间转换器 ConvertUtils.register(new DateLocaleConverter(), Date.class); BeanUtils.setProperty(p, "birthday", birthday); System.out.println(p.getBirthday());&#125;Apache已有的时间转化器中不能很好地过滤空字符串，若待转换字符串为空则会抛出异常；而现实业务非常复杂，Apache无法提供给我们所有的类型转化方法，需要时我们可以注册自己需要的转换器完成业务需求。注册自己的转换器完成时间转化：123456789101112131415161718192021222324252627282930313233@Test//注册自己的转换器完成时间转化public void test2() throws IllegalAccessException, InvocationTargetException&#123; Person p=new Person(); String birthday="1995-05-05"; //为了日期可以赋值到bean的属性,我们给benUtils注册日期转换器 ConvertUtils.register(new Converter()&#123; @SuppressWarnings(&#123; "unchecked", "rawtypes" &#125;) public Object convert(Class type,Object value)&#123; if(value==null)&#123; return null; &#125; if(!(value instanceof String))&#123; throw new ConversionException("只支持String类型的转换"); &#125; String str=(String) value; if(str.trim().equals(""))&#123; return null; &#125; SimpleDateFormat dateformate=new SimpleDateFormat("yyyy-MM-dd"); try &#123; return dateformate.parse(str); &#125; catch (ParseException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125;, Date.class); BeanUtils.setProperty(p, "birthday", birthday); System.out.println(p.getBirthday());&#125;直接使用map对象填充类:```java@Test//直接使用map对象填充类public void test4() throws Exception{HashMapmap=new HashMap();map.put(“username”,”李四”);map.put(“password”,”lisi”);map.put(“age”,”26”);map.put(“birthday”,”1990-05-05”);ConvertUtils.register(new DateLocaleConverter() , Date.class); Person p=new Person(); BeanUtils.populate(p, map); System.out.println(p.getUsername()); System.out.println(p.getPassword()); System.out.println(p.getAge()); System.out.println(p.getBirthday()); }]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>beanUtils</tag>
        <tag>javabean</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【新手学Java】使用内省(Introspector)操作JavaBean属性]]></title>
    <url>%2Fx%E6%96%B0%E6%89%8B%E5%AD%A6Javax%E4%BD%BF%E7%94%A8%E5%86%85%E7%9C%81(Introspector)%E6%93%8D%E4%BD%9CJavaBean%E5%B1%9E%E6%80%A7.html</url>
    <content type="text"><![CDATA[使用内省(Introspector)操作获取类bean中的所有属性:12345678910111213@Test//获取类bean中的所有属性public void test1() throws Exception&#123; BeanInfo info = Introspector.getBeanInfo(Person.class); PropertyDescriptor[] decriptors = info.getPropertyDescriptors(); for(PropertyDescriptor decriptor : decriptors)&#123; //输出属性的名称 System.out.println(decriptor.getName()); //输出属性的类型 System.out.println(decriptor.getPropertyType()); &#125; &#125;读/写bean中某个属性:12345678910111213141516@Test//操纵bean中某个属性public void test2() throws Exception&#123; Person p=new Person(); PropertyDescriptor decriptor = new PropertyDescriptor("username",Person.class); //得到属性的写方法 Method method=decriptor.getWriteMethod(); method.invoke(p, "张三"); //得到属性的读方法 method=decriptor.getReadMethod(); String username= (String) method.invoke(p); System.out.println(username);&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>javabean</tag>
        <tag>Introspector</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【新手学Java】反射学习笔记]]></title>
    <url>%2Fx%E6%96%B0%E6%89%8B%E5%AD%A6Javax%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[示例类代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@SuppressWarnings("unused")public class Person &#123; public String Name; private int Age; public Gender Gender; private static String Species = "人类"; public Person()&#123; Name="佚名"; Age=-1; &#125; public Person(String name)&#123; Name=name; &#125; private Person(String name,int age)&#123; Name=name; Age=age; &#125; private Person(Gender g)&#123; Gender=g; &#125; public void Run()&#123; System.out.println(Name+" 跑!"); &#125; public void Attack()&#123; System.out.println(Name+" 打!"); &#125; public void Attack(String name)&#123; System.out.println(Name+" 打 "+name+"!"); &#125; private void Eat(String food)&#123; System.out.println(Name+" 吃 "+food); &#125; public void Introduce() &#123; System.out.println("我叫"+Name+",我今年"+Age+"岁了。"); &#125; public static void PlayGame(String gameName)&#123; System.out.println("玩 "+gameName+" 游戏"); &#125; public static void main(String[] args)&#123; System.out.println("main"); for(String s:args) System.out.println(s); &#125;&#125;enum Gender&#123; Male,Female&#125;反射类的无参构造函数:123456789101112@Test//反射类的无参构造函数public void constructor1() throws Exception&#123; Class clazz = Class.forName("pro.shaowei.reflect.Person"); Constructor c=clazz.getConstructor(); Person p = (Person) c.newInstance(); Person p1 = (Person) clazz.newInstance(); p.Introduce(); p.Run(); p1.Introduce(); p1.Run();&#125;反射类的有参构造函数:123456789@Test//反射类的有参构造函数public void constructor2() throws Exception&#123; Class clazz=Class.forName("pro.shaowei.reflect.Person"); Constructor c=clazz.getConstructor(String.class); Person p=((Person) c.newInstance("张三")); p.Introduce(); p.Run();&#125;反射类的私有构造函数:1234567891011@Test//反射类的私有构造函数public void constructor3() throws Exception&#123; Class clazz=Class.forName("pro.shaowei.reflect.Person"); //反射私有构造函数时必须从使用 getDeclaredConstructor 方法 Constructor c=clazz.getDeclaredConstructor(String.class,int.class); c.setAccessible(true);//暴力反射 Person p=((Person) c.newInstance("张三",25)); p.Introduce(); p.Run();&#125;反射类的公有无参方法:12345678@Test//反射类的公有无参方法public void method1() throws Exception&#123; Class clazz=Class.forName("pro.shaowei.reflect.Person"); Person p=(Person) clazz.newInstance(); Method method=clazz.getMethod("Run"); method.invoke(p);&#125;反射类的公有有参方法:12345678@Test//反射类的公有有参方法public void method2() throws Exception&#123; Class clazz=Class.forName("pro.shaowei.reflect.Person"); Person p=(Person) clazz.newInstance(); Method method=clazz.getMethod("Attack",String.class); method.invoke(p,"李四");&#125;反射类的私有有参方法:123456789@Test//反射类的私有有参方法public void method3() throws Exception&#123; Class clazz=Class.forName("pro.shaowei.reflect.Person"); Person p=(Person) clazz.newInstance(); Method method=clazz.getDeclaredMethod("Eat",String.class); method.setAccessible(true); method.invoke(p,"香蕉");&#125;反射类的静态有参方法:123456789@Test//反射类的静态有参方法public void method4() throws Exception&#123; Class clazz=Class.forName("pro.shaowei.reflect.Person"); Person p=(Person) clazz.newInstance(); Method method=clazz.getDeclaredMethod("PlayGame",String.class); method.setAccessible(true); method.invoke(p,"扫雷");&#125;反射类的main方法:123456789@Test//反射类的main方法public void method5() throws Exception&#123; Class clazz=Class.forName("pro.shaowei.reflect.Person"); Person p=(Person) clazz.newInstance(); Method method=clazz.getDeclaredMethod("main",String[].class); method.setAccessible(true); method.invoke(p,(Object)new String[]&#123;"1","2"&#125;);&#125;反射类公有的字段:12345678910@Test//反射类公有的字段public void field1() throws Exception&#123; Class clazz=Class.forName("pro.shaowei.reflect.Person"); Person p=(Person) clazz.newInstance(); Field field=clazz.getField("Name"); System.out.println(field.get(p)); field.set(p, "王五"); p.Introduce();&#125;反射类私有的字段:1234567891011@Test//反射类私有的字段public void field2() throws Exception&#123; Class clazz=Class.forName("pro.shaowei.reflect.Person"); Person p=(Person) clazz.newInstance(); Field field=clazz.getDeclaredField("Age"); field.setAccessible(true); System.out.println(field.get(p)); field.set(p, 7); p.Introduce();&#125;反射类私有静态的字段:1234567891011@Test//反射类私有静态的字段public void field3() throws Exception&#123; Class clazz=Class.forName("pro.shaowei.reflect.Person"); Person p=(Person) clazz.newInstance(); Field field=clazz.getDeclaredField("Species"); field.setAccessible(true); System.out.println(field.get(p)); field.set(p, "不死族"); System.out.println(field.get(p));&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缺少google api密钥,因此chromium的部分功能将无法使用”的解决办法]]></title>
    <url>%2F%E7%BC%BA%E5%B0%91google-api%E5%AF%86%E9%92%A5%2C%E5%9B%A0%E6%AD%A4chromium%E7%9A%84%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E5%B0%86%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E2%80%9D%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html</url>
    <content type="text"><![CDATA[使用Chromium时会遇到 “缺少google api密钥,因此chromium的部分功能将无法使用”提示，google了一下 setx Google_API_KEY 和 chromium portable google api keys are missing 找到了解决办法。打开windows的cmd命令提示符，依次输入以下命令：123setx GOOGLE_API_KEY "no" setx GOOGLE_DEFAULT_CLIENT_ID "no" setx GOOGLE_DEFAULT_CLIENT_SECRET "no"当然,这样只是可以去掉chromium开启时的提示,如果需要使用Google API 服务,还是推荐去谷歌申请,然后重新setx为真实api key。]]></content>
      <categories>
        <category>踩坑笔记</category>
      </categories>
      <tags>
        <tag>软件心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【爬虫学习笔记】基于Bloom Filter的url去重模块UrlSeen]]></title>
    <url>%2Fx%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0x%E5%9F%BA%E4%BA%8EBloom-Filter%E7%9A%84url%E5%8E%BB%E9%87%8D%E6%A8%A1%E5%9D%97UrlSeen.html</url>
    <content type="text"><![CDATA[Url Seen用来做url去重。对于一个大的爬虫系统，它可能已经有百亿或者千亿的url，新来一个url如何能快速的判断url是否已经出现过非常关键。因为大的爬虫系统可能一秒钟就会下载几千个网页，一个网页一般能够抽取出几十个url，而每个url都需要执行去重操作，可想每秒需要执行大量的去重操作。因此Url Seen是整个爬虫系统中非常有技术含量的一个部分。为了提高过滤的效率,我们使用有极低误判率但是效率非常高的算法——Bloom Filter，已经有高手写好了Bloom Filter的算法实现，我们这里就直接站在巨人的肩膀上直接使用他写好的类库啦。Nuget:Install-Package BloomFilter代码实现:123456789101112131415161718192021222324252627282930313233using System;using BloomFilterDotNet;namespace Crawler.Processing&#123; /// &lt;summary&gt; /// Url Seen用来做url去重。对于一个大的爬虫系统，它可能已经有百亿或者千亿的url，新来一个url如何能快速的判断url是否已经出现过非常关键。因为大的爬虫系统可能一秒钟就会下载几千个网页，一个网页一般能够抽取出几十个url，而每个url都需要执行去重操作，可想每秒需要执行大量的去重操作。因此Url Seen是整个爬虫系统中非常有技术含量的一个部分。 /// &lt;/summary&gt; public class UrlSeen &#123; private BloomFilter&lt;string&gt; Seen &#123; set; get; &#125; public UrlSeen() &#123; Seen = new BloomFilter&lt;string&gt;(1000000, 0.0001, null); &#125; public UrlSeen(int targetCapacity, double falsePositiveRate) &#123; Seen = new BloomFilter&lt;string&gt;(targetCapacity, falsePositiveRate, null); &#125; public bool MatchUrl(Uri url) &#123; return Seen.Contains(url.ToString()); &#125; public int Count &#123; get &#123; return Seen.Count; &#125; &#125; public void Add(Uri url) &#123; Seen.Add(url.ToString()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Bloom Filter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【爬虫学习笔记】Url过滤模块UrlFilter]]></title>
    <url>%2Fx%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0xUrl%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97UrlFilter.html</url>
    <content type="text"><![CDATA[Url Filter则是对提取出来的URL再进行一次筛选。不同的应用筛选的标准是不一样的，比如对于baidu/google的搜索，一般不进行筛选，但是对于垂直搜索或者定向抓取的应用，那么它可能只需要满足某个条件的url，比如不需要图片的url，比如只需要某个特定网站的url等等。Url Filter是一个和应用密切相关的模块。123456789101112131415161718192021222324252627282930313233343536using System;using System.Collections.Generic;using Crawler.Common;namespace Crawler.Processing&#123; public class UrlFilter &#123; public static List&lt;Uri&gt; RemoveByRegex(List&lt;Uri&gt; uris, params string[] regexs) &#123; var uriList=new List&lt;Uri&gt;(uris); for (var i = 0; i &lt; uriList.Count; i++) &#123; foreach (var r in regexs) &#123; if (!RegexHelper.IsMatch(uriList[i].ToString(), r)) continue; uris.RemoveAt(i); i--; &#125; &#125; return uriList; &#125; public static List&lt;Uri&gt; SelectByRegex(List&lt;Uri&gt; uris, params string[] regexs) &#123; var uriList = new List&lt;Uri&gt;(); foreach (var t in uris) foreach (var r in regexs) if (RegexHelper.IsMatch(t.ToString(), r)) if(!uriList.Contains(t)) uriList.Add(t); return uriList; &#125; &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>UrlFilter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【爬虫学习笔记】用于提取网页中所有链接的 Extractor 模块]]></title>
    <url>%2Fx%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0x%E7%94%A8%E4%BA%8E%E6%8F%90%E5%8F%96%E7%BD%91%E9%A1%B5%E4%B8%AD%E6%89%80%E6%9C%89%E9%93%BE%E6%8E%A5%E7%9A%84-Extractor-%E6%A8%A1%E5%9D%97.html</url>
    <content type="text"><![CDATA[Extractor的工作是从下载的网页中将它包含的所有URL提取出来。这是个细致的工作，你需要考虑到所有可能的url的样式，比如网页中常常会包含相对路径的url，提取的时候需要将它转换成绝对路径。这里我们选择使用正则表达式来完成链接的提取。html标签中的链接地址通常会出现在href属性或者src属性中，所以我们采用两个正则表达式来匹配网页中的所有链接地址。网页链接提取器Extractor类：1234567891011121314151617181920212223242526272829303132333435363738using System;using System.Collections.Generic;using System.Linq;using Crawler.Common;namespace Crawler.Processing&#123; /// &lt;summary&gt; /// Extractor的工作是从下载的网页中将它包含的所有URL提取出来。这是个细致的工作，你需要考虑到所有可能的url的样式，比如网页中常常会包含相对路径的url，提取的时候需要将它转换成绝对路径。 /// &lt;/summary&gt; public class Extractor &#123; public List&lt;Uri&gt; GetAllUrl(string html, string host) &#123; var list = new List&lt;string&gt;(); //匹配href属性 var href = RegexHelper.ExtractStringArray(html, "href *= *['\"]*(\\S+)[\"']"); //去掉匹配到字符串的空格、双引号和前面的href=，得到链接 var temp = from h in href select h.Replace(" ", "").Replace("\"", "").Substring(5); //加入数组 list.AddRange(temp); //匹配src属性 var src = RegexHelper.ExtractStringArray(html, "src *= *['\"]*(\\S+)[\"']"); temp = from s in src select s.Replace(" ", "").Replace("\"", "").Substring(4); list.AddRange(temp); //去重 list = list.Distinct().ToList(); //将链接地址中的相对路径转换为绝对路径 var uriList = list.Select(s =&gt; s.IndexOf("http://", StringComparison.Ordinal) != 0 ? new Uri(new Uri(host), s) : new Uri(s)).ToList(); return uriList.ToList(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Extractor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC学习笔记索引帖]]></title>
    <url>%2FMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B4%A2%E5%BC%95%E5%B8%96.html</url>
    <content type="text"><![CDATA[MVC学习笔记索引帖【MVC学习笔记】1.项目结构搭建及单个类在各个层次中的实现【MVC学习笔记】2.使用T4模板生成其他类的具体实现【MVC学习笔记】3.使用Spring.Net应用IOC（依赖倒置）【MVC学习笔记】4.使用Log4Net来进行错误日志的记录【MVC学习笔记】5.使用Controller来代替Filter完成登录验证（Session校验）【MVC学习笔记】6. 使用Memcache+Cookie解决分布式系统共享登录状态【MVC学习笔记】7.使用极验验证来制作更高逼格的验证码]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MVC</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装DotNetCore.1.0.1-VS2015Tools.Preview2.0.2出现0x80072f8a未指定的错误]]></title>
    <url>%2F%E5%AE%89%E8%A3%85DotNetCore.1.0.1-VS2015Tools.Preview2.0.2%E5%87%BA%E7%8E%B00x80072f8a%E6%9C%AA%E6%8C%87%E5%AE%9A%E7%9A%84%E9%94%99%E8%AF%AF.html</url>
    <content type="text"><![CDATA[最近DotNetCore更新到了1.0.1，Azure tools也更新到了2.9.5，尝试更新时发现，DotNetCore更新失败，提示：0x80072f8a未指定的错误，而Azure Tools中也包含了DotNetCore的更新，0x80072f8a问题，导致两个软件都不能成功地完成更新。研究安装的错误日志后才发现，原来使因为证书过期导致的无法下载微软在线资源，所以无法成功安装，解决证书问题之后就顺利的成功安装啦！和大家分享一下解决的方法：方案一，修改IE选项，取消选项 “检查服务器证书是否已吊销”方案二，修改时间到证书有效期内即可具体证书有效期是什么范围我也不太清楚，不过经我测试直接把年修改为2015即可成功安装]]></content>
      <categories>
        <category>踩坑笔记</category>
      </categories>
      <tags>
        <tag>软件心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【迷宫中的算法实践】迷宫生成算法——Prim算法]]></title>
    <url>%2Fx%E8%BF%B7%E5%AE%AB%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5x%E8%BF%B7%E5%AE%AB%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Prim%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[普里姆算法（Prim算法），图论中的一种算法，可在加权连通图里搜索最小生成树。意即由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点（英语：Vertex (graph theory)），且其所有边的权值之和亦为最小。该算法于1930年由捷克数学家沃伊捷赫·亚尔尼克（英语：Vojtěch Jarník）发现；并在1957年由美国计算机科学家罗伯特·普里姆（英语：Robert C. Prim）独立发现；1959年，艾兹格·迪科斯彻再次发现了该算法。因此，在某些场合，普里姆算法又被称为DJP算法、亚尔尼克算法或普里姆－亚尔尼克算法。——来自百度百科当我们将Prim算法用于迷宫生成时，情况有些不同，维基百科中给出了随机Prim迷宫生成算法(Randomized Prim’s algorithm)的解释及实现过程：我们将算法实现部分翻译成中文让迷宫全都是墙.。选一个格，作为迷宫的通路，然后把它的邻墙放入列表.。当列表里还有墙时:1). 从列表里随机选一个墙，如果它对面的格子不是迷宫的通路:2). 把墙打通，让对面的格子成为迷宫的通路.。把那个格子的邻墙加入列表。如果对面的格子已经是通路了，那就从列表里移除这面墙。简单研究算法实现过程我们可以发现，Prim算法就是不断地从所有可以是通路的位置中随意选一个挖洞，直到没有可能为通路的位置。整个实现过程还是相当于随意为路线附权值的Prim算法。下面我们来做C#下的代码实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/// &lt;summary&gt;/// 普利姆迷宫生成法/// &lt;/summary&gt;/// &lt;param name="startX"&gt;起始点X坐标&lt;/param&gt;/// &lt;param name="startY"&gt;起始点Y坐标&lt;/param&gt;/// &lt;param name="widthLimit"&gt;迷宫宽度&lt;/param&gt;/// &lt;param name="heightLimit"&gt;迷宫高度&lt;/param&gt;/// &lt;param name="haveBorder"&gt;迷宫是否含有墙&lt;/param&gt;private int[,] Prim(int startX, int startY, int widthLimit, int heightLimit,bool haveBorder)&#123; //block:不可通行 unBlock:可通行 const int block = 0,unBlock = 1; var r=new Random(); //迷宫尺寸合法化 if (widthLimit &lt; 1) widthLimit = 1; if (heightLimit &lt; 1) heightLimit = 1; //迷宫起点合法化 if (startX &lt; 0 || startX &gt;= widthLimit) startX = r.Next(0, widthLimit); if (startY &lt; 0 || startY &gt;= heightLimit) startY = r.Next(0, heightLimit); //减去边框所占的格子 if (!haveBorder) &#123; widthLimit--; heightLimit--; &#125; //迷宫尺寸换算成带墙尺寸 widthLimit *= 2; heightLimit *= 2; //迷宫起点换算成带墙起点 startX *= 2; startY *= 2; if (haveBorder) &#123; startX++; startY++; &#125; //产生空白迷宫 var mazeMap = new int[widthLimit + 1, heightLimit + 1]; for (int x = 0; x &lt;= widthLimit; x++) &#123; //mazeMap.Add(new BitArray(heightLimit + 1)); for (int y = 0; y &lt;= heightLimit; y++) &#123; mazeMap[x, y] = block; &#125; &#125; //邻墙列表 var blockPos = new List&lt;int&gt;(); //将起点作为目标格 int targetX = startX, targetY = startY; //将起点标记为通路 mazeMap[targetX, targetY] = unBlock; //记录邻墙 if (targetY &gt; 1) &#123; blockPos.AddRange(new int[] &#123; targetX, targetY - 1, 0 &#125;); &#125; if (targetX &lt; widthLimit) &#123; blockPos.AddRange(new int[] &#123; targetX + 1, targetY, 1 &#125;); &#125; if (targetY &lt; heightLimit) &#123; blockPos.AddRange(new int[] &#123; targetX, targetY + 1, 2 &#125;); &#125; if (targetX &gt; 1) &#123; blockPos.AddRange(new int[] &#123; targetX - 1, targetY, 3 &#125;); &#125; while (blockPos.Count &gt; 0) &#123; //随机选一堵墙 var blockIndex = r.Next(0, blockPos.Count / 3) * 3; //找到墙对面的墙 if (blockPos[blockIndex + 2] == 0) &#123; targetX = blockPos[blockIndex]; targetY = blockPos[blockIndex + 1] - 1; &#125; else if (blockPos[blockIndex + 2] == 1) &#123; targetX = blockPos[blockIndex] + 1; targetY = blockPos[blockIndex + 1]; &#125; else if (blockPos[blockIndex + 2] == 2) &#123; targetX = blockPos[blockIndex]; targetY = blockPos[blockIndex + 1] + 1; &#125; else if (blockPos[blockIndex + 2] == 3) &#123; targetX = blockPos[blockIndex] - 1; targetY = blockPos[blockIndex + 1]; &#125; //如果目标格未连通 if (mazeMap[targetX, targetY] == block) &#123; //联通目标格 mazeMap[blockPos[blockIndex], blockPos[blockIndex + 1]] = unBlock; mazeMap[targetX, targetY] = unBlock; //添加目标格相邻格 if (targetY &gt; 1 &amp;&amp; mazeMap[targetX, targetY - 1] == block &amp;&amp; mazeMap[targetX, targetY - 2] == block) &#123; blockPos.AddRange(new int[] &#123; targetX, targetY - 1, 0 &#125;); &#125; if (targetX &lt; widthLimit &amp;&amp; mazeMap[targetX + 1, targetY] == block &amp;&amp; mazeMap[targetX + 2, targetY] == block) &#123; blockPos.AddRange(new int[] &#123; targetX + 1, targetY, 1 &#125;); &#125; if (targetY &lt; heightLimit &amp;&amp; mazeMap[targetX, targetY + 1] == block &amp;&amp; mazeMap[targetX, targetY + 2] == block) &#123; blockPos.AddRange(new int[] &#123; targetX, targetY + 1, 2 &#125;); &#125; if (targetX &gt; 1 &amp;&amp; mazeMap[targetX - 1, targetY] == block &amp;&amp; mazeMap[targetX - 1, targetY] == block) &#123; blockPos.AddRange(new int[] &#123; targetX - 1, targetY, 3 &#125;); &#125; &#125; blockPos.RemoveRange(blockIndex, 3); &#125; return mazeMap;&#125;]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Prim</tag>
        <tag>迷宫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【MVC学习笔记】7.使用极验验证来制作更高逼格的验证码]]></title>
    <url>%2FxMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0x7.%E4%BD%BF%E7%94%A8%E6%9E%81%E9%AA%8C%E9%AA%8C%E8%AF%81%E6%9D%A5%E5%88%B6%E4%BD%9C%E6%9B%B4%E9%AB%98%E9%80%BC%E6%A0%BC%E7%9A%84%E9%AA%8C%E8%AF%81%E7%A0%81.html</url>
    <content type="text"><![CDATA[在之前的项目中，如果有需要使用验证码，基本都是自己用GDI+画图出来，简单好用，但是却也存在了一些小问题，首先若较少干扰线，则安全性不是很高，验证码容易被机器识别，若多画太多干扰线条，机器人识别率下降的同时，人眼的识别率也同步下降（震惊哭）。更为重要的是，GDI+绘制的验证码一般来说也不会很美观，如果做一个炫酷的登陆界面却配了这样一个验证码，画风诡异，丑到极致。再后来浏览网页的过程中，发现很多很多网站项目中都使用了一种叫极验验证的验证码，采用移动滑块的方式进行验证，方便美观。而一番搜索之后了解到，官方提供的免费版也足以应付我手头的大多数项目了，不禁想把在MVC学习过程中试着使用极验验证来作为登录的验证码。极验官方提供了C#的SDK和Demo供开发者参考，不过是Webform版本的，可读性不是很高，而现在使用Webform进行网站开发的也基本消失了，我将在官方Webform代码的基础上，将其用在ASP.NET MVC程序中。注册极验到极验官网注册账号之后进入后台管理界面，点击添加验证添加后我们可以得到ID和KEY完成验证逻辑首先我们需要引入官方的Geetestlib类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374using System;using System.Collections;using System.Collections.Generic;using System.Linq;using System.Text;using System.Security.Cryptography;using System.Net;using System.IO;namespace PMS.WebApp.Models&#123; /// &lt;summary&gt; /// GeetestLib 极验验证C# SDK基本库 /// &lt;/summary&gt; public class GeetestLib &#123; /// &lt;summary&gt; /// SDK版本号 /// &lt;/summary&gt; public const String version = "3.2.0"; /// &lt;summary&gt; /// SDK开发语言 /// &lt;/summary&gt; public const String sdkLang = "csharp"; /// &lt;summary&gt; /// 极验验证API URL /// &lt;/summary&gt; protected const String apiUrl = "http://api.geetest.com"; /// &lt;summary&gt; /// register url /// &lt;/summary&gt; protected const String registerUrl = "/register.php"; /// &lt;summary&gt; /// validate url /// &lt;/summary&gt; protected const String validateUrl = "/validate.php"; /// &lt;summary&gt; /// 极验验证API服务状态Session Key /// &lt;/summary&gt; public const String gtServerStatusSessionKey = "gt_server_status"; /// &lt;summary&gt; /// 极验验证二次验证表单数据 Chllenge /// &lt;/summary&gt; public const String fnGeetestChallenge = "geetest_challenge"; /// &lt;summary&gt; /// 极验验证二次验证表单数据 Validate /// &lt;/summary&gt; public const String fnGeetestValidate = "geetest_validate"; /// &lt;summary&gt; /// 极验验证二次验证表单数据 Seccode /// &lt;/summary&gt; public const String fnGeetestSeccode = "geetest_seccode"; private String userID = ""; private String responseStr = ""; private String captchaID = ""; private String privateKey = ""; /// &lt;summary&gt; /// 验证成功结果字符串 /// &lt;/summary&gt; public const int successResult = 1; /// &lt;summary&gt; /// 证结失败验果字符串 /// &lt;/summary&gt; public const int failResult = 0; /// &lt;summary&gt; /// 判定为机器人结果字符串 /// &lt;/summary&gt; public const String forbiddenResult = "forbidden"; /// &lt;summary&gt; /// GeetestLib构造函数 /// &lt;/summary&gt; /// &lt;param name="publicKey"&gt;极验验证公钥&lt;/param&gt; /// &lt;param name="privateKey"&gt;极验验证私钥&lt;/param&gt; public GeetestLib(String publicKey, String privateKey) &#123; this.privateKey = privateKey; this.captchaID = publicKey; &#125; private int getRandomNum() &#123; Random rand =new Random(); int randRes = rand.Next(100); return randRes; &#125; /// &lt;summary&gt; /// 验证初始化预处理 /// &lt;/summary&gt; /// &lt;returns&gt;初始化结果&lt;/returns&gt; public Byte preProcess() &#123; if (this.captchaID == null) &#123; Console.WriteLine("publicKey is null!"); &#125; else &#123; String challenge = this.registerChallenge(); if (challenge.Length == 32) &#123; this.getSuccessPreProcessRes(challenge); return 1; &#125; else &#123; this.getFailPreProcessRes(); Console.WriteLine("Server regist challenge failed!"); &#125; &#125; return 0; &#125; public Byte preProcess(String userID) &#123; if (this.captchaID == null) &#123; Console.WriteLine("publicKey is null!"); &#125; else &#123; this.userID = userID; String challenge = this.registerChallenge(); if (challenge.Length == 32) &#123; this.getSuccessPreProcessRes(challenge); return 1; &#125; else &#123; this.getFailPreProcessRes(); Console.WriteLine("Server regist challenge failed!"); &#125; &#125; return 0; &#125; public String getResponseStr() &#123; return this.responseStr; &#125; /// &lt;summary&gt; /// 预处理失败后的返回格式串 /// &lt;/summary&gt; private void getFailPreProcessRes() &#123; int rand1 = this.getRandomNum(); int rand2 = this.getRandomNum(); String md5Str1 = this.md5Encode(rand1 + ""); String md5Str2 = this.md5Encode(rand2 + ""); String challenge = md5Str1 + md5Str2.Substring(0, 2); this.responseStr = "&#123;" + string.Format( "\"success\":&#123;0&#125;,\"gt\":\"&#123;1&#125;\",\"challenge\":\"&#123;2&#125;\"", 0, this.captchaID, challenge) + "&#125;"; &#125; /// &lt;summary&gt; /// 预处理成功后的标准串 /// &lt;/summary&gt; private void getSuccessPreProcessRes(String challenge) &#123; challenge = this.md5Encode(challenge + this.privateKey); this.responseStr ="&#123;" + string.Format( "\"success\":&#123;0&#125;,\"gt\":\"&#123;1&#125;\",\"challenge\":\"&#123;2&#125;\"", 1, this.captchaID, challenge) + "&#125;"; &#125; /// &lt;summary&gt; /// failback模式的验证方式 /// &lt;/summary&gt; /// &lt;param name="challenge"&gt;failback模式下用于与validate一起解码答案， 判断验证是否正确&lt;/param&gt; /// &lt;param name="validate"&gt;failback模式下用于与challenge一起解码答案， 判断验证是否正确&lt;/param&gt; /// &lt;param name="seccode"&gt;failback模式下，其实是个没用的参数&lt;/param&gt; /// &lt;returns&gt;验证结果&lt;/returns&gt; public int failbackValidateRequest(String challenge, String validate, String seccode) &#123; if (!this.requestIsLegal(challenge, validate, seccode)) return GeetestLib.failResult; String[] validateStr = validate.Split('_'); String encodeAns = validateStr[0]; String encodeFullBgImgIndex = validateStr[1]; String encodeImgGrpIndex = validateStr[2]; int decodeAns = this.decodeResponse(challenge, encodeAns); int decodeFullBgImgIndex = this.decodeResponse(challenge, encodeFullBgImgIndex); int decodeImgGrpIndex = this.decodeResponse(challenge, encodeImgGrpIndex); int validateResult = this.validateFailImage(decodeAns, decodeFullBgImgIndex, decodeImgGrpIndex); return validateResult; &#125; private int validateFailImage(int ans, int full_bg_index, int img_grp_index) &#123; const int thread = 3; String full_bg_name = this.md5Encode(full_bg_index + "").Substring(0, 10); String bg_name = md5Encode(img_grp_index + "").Substring(10, 10); String answer_decode = ""; for (int i = 0;i &lt; 9; i++) &#123; if (i % 2 == 0) answer_decode += full_bg_name.ElementAt(i); else if (i % 2 == 1) answer_decode += bg_name.ElementAt(i); &#125; String x_decode = answer_decode.Substring(4); int x_int = Convert.ToInt32(x_decode, 16); int result = x_int % 200; if (result &lt; 40) result = 40; if (Math.Abs(ans - result) &lt; thread) return GeetestLib.successResult; else return GeetestLib.failResult; &#125; private Boolean requestIsLegal(String challenge, String validate, String seccode) &#123; if (challenge.Equals(string.Empty) || validate.Equals(string.Empty) || seccode.Equals(string.Empty)) return false; return true; &#125; /// &lt;summary&gt; /// 向gt-server进行二次验证 /// &lt;/summary&gt; /// &lt;param name="challenge"&gt;本次验证会话的唯一标识&lt;/param&gt; /// &lt;param name="validate"&gt;拖动完成后server端返回的验证结果标识字符串&lt;/param&gt; /// &lt;param name="seccode"&gt;验证结果的校验码，如果gt-server返回的不与这个值相等则表明验证失败&lt;/param&gt; /// &lt;returns&gt;二次验证结果&lt;/returns&gt; public int enhencedValidateRequest(String challenge, String validate, String seccode) &#123; if (!this.requestIsLegal(challenge, validate, seccode)) return GeetestLib.failResult; if (validate.Length &gt; 0 &amp;&amp; checkResultByPrivate(challenge, validate)) &#123; String query = "seccode=" + seccode + "&amp;sdk=csharp_" + GeetestLib.version; String response = ""; try &#123; response = postValidate(query); &#125; catch (Exception e) &#123; Console.WriteLine(e); &#125; if (response.Equals(md5Encode(seccode))) &#123; return GeetestLib.successResult; &#125; &#125; return GeetestLib.failResult; &#125; public int enhencedValidateRequest(String challenge, String validate, String seccode, String userID) &#123; if (!this.requestIsLegal(challenge, validate, seccode)) return GeetestLib.failResult; if (validate.Length &gt; 0 &amp;&amp; checkResultByPrivate(challenge, validate)) &#123; String query = "seccode=" + seccode + "&amp;user_id=" + userID + "&amp;sdk=csharp_" + GeetestLib.version; String response = ""; try &#123; response = postValidate(query); &#125; catch (Exception e) &#123; Console.WriteLine(e); &#125; if (response.Equals(md5Encode(seccode))) &#123; return GeetestLib.successResult; &#125; &#125; return GeetestLib.failResult; &#125; private String readContentFromGet(String url) &#123; try &#123; HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url); request.Timeout = 20000; HttpWebResponse response = (HttpWebResponse)request.GetResponse(); Stream myResponseStream = response.GetResponseStream(); StreamReader myStreamReader = new StreamReader(myResponseStream, Encoding.GetEncoding("utf-8")); String retString = myStreamReader.ReadToEnd(); myStreamReader.Close(); myResponseStream.Close(); return retString; &#125; catch &#123; return ""; &#125; &#125; private String registerChallenge() &#123; String url = ""; if (string.Empty.Equals(this.userID)) &#123; url = string.Format("&#123;0&#125;&#123;1&#125;?gt=&#123;2&#125;", GeetestLib.apiUrl, GeetestLib.registerUrl, this.captchaID); &#125; else &#123; url = string.Format("&#123;0&#125;&#123;1&#125;?gt=&#123;2&#125;&amp;user_id=&#123;3&#125;", GeetestLib.apiUrl, GeetestLib.registerUrl, this.captchaID, this.userID); &#125; string retString = this.readContentFromGet(url); return retString; &#125; private Boolean checkResultByPrivate(String origin, String validate) &#123; String encodeStr = md5Encode(privateKey + "geetest" + origin); return validate.Equals(encodeStr); &#125; private String postValidate(String data) &#123; String url = string.Format("&#123;0&#125;&#123;1&#125;", GeetestLib.apiUrl, GeetestLib.validateUrl); HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url); request.Method = "POST"; request.ContentType = "application/x-www-form-urlencoded"; request.ContentLength = Encoding.UTF8.GetByteCount(data); // 发送数据 Stream myRequestStream = request.GetRequestStream(); byte[] requestBytes = System.Text.Encoding.ASCII.GetBytes(data); myRequestStream.Write(requestBytes, 0, requestBytes.Length); myRequestStream.Close(); HttpWebResponse response = (HttpWebResponse)request.GetResponse(); // 读取返回信息 Stream myResponseStream = response.GetResponseStream(); StreamReader myStreamReader = new StreamReader(myResponseStream, Encoding.GetEncoding("utf-8")); string retString = myStreamReader.ReadToEnd(); myStreamReader.Close(); myResponseStream.Close(); return retString; &#125; private int decodeRandBase(String challenge) &#123; String baseStr = challenge.Substring(32, 2); List&lt;int&gt; tempList = new List&lt;int&gt;(); for(int i = 0; i &lt; baseStr.Length; i++) &#123; int tempAscii = (int)baseStr[i]; tempList.Add((tempAscii &gt; 57) ? (tempAscii - 87) : (tempAscii - 48)); &#125; int result = tempList.ElementAt(0) * 36 + tempList.ElementAt(1); return result; &#125; private int decodeResponse(String challenge, String str) &#123; if (str.Length&gt;100) return 0; int[] shuzi = new int[] &#123; 1, 2, 5, 10, 50&#125;; String chongfu = ""; Hashtable key = new Hashtable(); int count = 0; for (int i=0;i&lt;challenge.Length;i++) &#123; String item = challenge.ElementAt(i) + ""; if (chongfu.Contains(item)) continue; else &#123; int value = shuzi[count % 5]; chongfu += item; count++; key.Add(item, value); &#125; &#125; int res = 0; for (int i = 0; i &lt; str.Length; i++) res += (int)key[str[i]+""]; res = res - this.decodeRandBase(challenge); return res; &#125; private String md5Encode(String plainText) &#123; MD5CryptoServiceProvider md5 = new MD5CryptoServiceProvider(); string t2 = BitConverter.ToString(md5.ComputeHash(UTF8Encoding.Default.GetBytes(plainText))); t2 = t2.Replace("-", ""); t2 = t2.ToLower(); return t2; &#125; &#125;&#125;获取验证码引入Jquery库1&lt;script src="~/Content/plugins/jquery/jquery-1.8.2.min.js"&gt;&lt;/script&gt;添加用于放置验证码的div（需要放到form表单中）123&lt;div id="geetest-container"&gt;&lt;/div&gt;添加JS代码用于获取验证码12345678910111213141516171819202122232425262728293031323334&lt;script&gt; window.addEventListener('load', processGeeTest); function processGeeTest() &#123; $.ajax(&#123; // 获取id，challenge，success（是否启用failback） url: "/Login/GeekTest", type: "get", dataType: "json", // 使用jsonp格式 success: function (data) &#123; // 使用initGeetest接口 // 参数1：配置参数，与创建Geetest实例时接受的参数一致 // 参数2：回调，回调的第一个参数验证码对象，之后可以使用它做appendTo之类的事件 initGeetest(&#123; gt: data.gt, challenge: data.challenge, product: "float", // 产品形式 offline: !data.success &#125;, handler); &#125; &#125;); &#125; var handler = function (captchaObj) &#123; // 将验证码加到id为captcha的元素里 captchaObj.appendTo("#geetest-container"); captchaObj.onSuccess = function (e) &#123; console.log(e); &#125; &#125;;&lt;/script&gt;processGeeTest方法中我们异步请求的地址“/Login/GeekTest”就是获取验证码是后台需要执行的方法123456789101112public ActionResult GeekTest()&#123; return Content(GetCaptcha(),"application/json");&#125;private string GetCaptcha()&#123; var geetest = new GeetestLib("3594e0d834df77cedc7351a02b5b06a4", "b961c8081ce88af7e32a3f45d00dff84"); var gtServerStatus = geetest.preProcess(); Session[GeetestLib.gtServerStatusSessionKey] = gtServerStatus; return geetest.getResponseStr();&#125;校验验证码注意，当提交form表单时，会将三个和极验有关的参数传到后台方法（geetest_challenge、geetest_validate、geetest_seccode），若验证码未验证成功，则参数为空值。后台验证方法为：123456789101112private bool CheckGeeTestResult()&#123; var geetest = new GeetestLib("3594e0d834df77cedc7351a02b5b06a4", "b961c8081ce88af7e32a3f45d00dff84 "); var gtServerStatusCode = (byte)Session[GeetestLib.gtServerStatusSessionKey]; var userId = (string)Session["userID"]; var challenge = Request.Form.Get(GeetestLib.fnGeetestChallenge); var validate = Request.Form.Get(GeetestLib.fnGeetestValidate); var seccode = Request.Form.Get(GeetestLib.fnGeetestSeccode); var result = gtServerStatusCode == 1 ? geetest.enhencedValidateRequest(challenge, validate, seccode, userId) : geetest.failbackValidateRequest(challenge, validate, seccode); return result == 1;&#125;我们可以在表单中判断验证码是否成功校验：123456public ActionResult Login()&#123; if (!CheckGeeTestResult()) return Content("no:请先完成验证操作。"); ....&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MVC</tag>
        <tag>验证码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【迷宫中的算法实践】迷宫问题算法综述]]></title>
    <url>%2Fx%E8%BF%B7%E5%AE%AB%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5x%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98%E7%AE%97%E6%B3%95%E7%BB%BC%E8%BF%B0.html</url>
    <content type="text"><![CDATA[最近听闻数据结构与算法实践课的老师又出了和上年一样的选题，不禁想起了去年自己完成作业时的点点滴滴，遗憾当时没有写博客的习惯，之前的一些心得这一年实践的过去也逐渐淡忘了，突然就有了总结一下的想法，希望能有新的收获吧。由于当时也没注意保存，软件完成过程中的一些文档早已丢失了，幸运的是Winform版源码还在，Unity3D版程序也还幸存，虽然由于时间紧张只完成了大概框架，但美观程度也远非Winform可以相比的，先上几张软件图吧：生成算法软件实现了普利姆算法、递归回溯算法、递归分割算法和深度遍历图算法四种算法来完成迷宫的生成，前两种算法生成的迷宫本质上是一个二维矩阵网络形式的生成树，也就是说其中没有回路，同时从左下角的起点到迷宫中的每一点都有且仅有一条路径，递归分割法虽然不是生成树算法但是同样属于没有回路的迷宫生成算法，深度遍历图算法则来源于知网上的一篇论文，属于图的深度遍历算法，生成的迷宫随机性更强，路径也不止一条，但不得不说的确扮相比较差。普利姆算法迷宫（Prim）递归分割算法（Recursive division）递归回溯（Recursive backtracker）深度遍历图（Deep traversal graph）寻路算法至于寻路算法，软件实现了深度优先遍历、广度优先遍历、和A-Star三种算法，前两种自不必说，A-Star算法是一种启发式搜索算法，移动时会评估向周围八个方向行走的预期代价，实时选出更小代价的移动方向，不过因为生成的迷宫均为正方形迷宫且起点和终点固定为左上和右下，所以在本项目中，A-Star算法并未发挥出它应有的机智，效率与广度优先基本相同。后两种算法可以寻找到最短路径，而深度优先则并不能展示。图中绿色为正确路线，蓝色为寻路过程中经过的路线。。（PS：设定为深度广度四方向移动，A-Star八方向移动）深度优先遍历（DFS）广度优先遍历（BFS）A-Star因为实例中的迷宫入口出口位置的特殊性，广度优先在寻路过程中基本要走完全称，显得有些不太机智，而A-Star的表现也和广度优先近似。本文章属于综述，后面的算法会分篇分别阐述。]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>迷宫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【MVC学习笔记】6. 使用Memcache+Cookie解决分布式系统共享登录状态]]></title>
    <url>%2FxMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0x6.-%E4%BD%BF%E7%94%A8Memcache%2BCookie%E8%A7%A3%E5%86%B3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%85%B1%E4%BA%AB%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81.html</url>
    <content type="text"><![CDATA[为了解决单机处理的瓶颈，增强软件的可用性，我们需要将软件部署在多台服务器上启用多个二级子域名以频道化的方式，根据业务功能将网站分布部署在独立的服务器上，或通过负载均衡技术（如：DNS轮询、Radware、F5、LVS等）让多个频道共享一组服务器。当我们将网站程序分部到多台服务器上后，由于Session受实现原理的局限，无法跨服务器同步更新Session，使得登录状态难以通过Session共享。我们使用MemCache+Cookie方案来解决分布式系统共享登录状态的问题。Memcache服务器本身就是一个Socket服务端，内部数据采用键值对的形式存储在服务器的内存中，本质就是一个大型的哈希表。数据的删除采用惰性删除机制。虽然Memcache并没有提供集群功能，但是通过客户端的驱动程序很容易就可以实现Memcache的集群配置。Memcache使用下载安装Memcache（Windows平台）（1）将程序解压到磁盘任意位置（2）进入cmd窗口，运行Memcached.exe -d install安装服务，安装后打开服务窗口查看服务是否安装成功。（3）直接在服务管理中启动服务，或者使用cmd命令 net start “Memcache Server”（4）使用Telnet连接到Memcache控制台，验证服务是否正常 telnet 127.0.0.1 11211（5）使用stats指令查看当前Memcache服务器状态。程序中的用法（1）在程序中添加 Memcached.ClientLibrary.dll 的引用（2）C#中操作Memcache的代码示例12345678910String[] serverlist = &#123; "192.168.1.100:11211","192.168.1.101:11211" &#125;;// initialize the pool for memcache serversSockIOPool pool = SockIOPool.GetInstance("test");pool.SetServers(serverlist);pool.Initialize();mc = new MemcacheClient();mc.PoolName = "test";mc.EnableCompression = false;pool.Shutdown();//关闭连接池具体实现首先在Common层中引入Memcached.ClientLibrary.dll，并封装Memcache的帮助类，MemcacheHelper1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768using Memcached.ClientLibrary;using System;namespace PMS.Common&#123; public class MemcacheHelper &#123; private static readonly MemcachedClient Mc = null; static MemcacheHelper() &#123; //最好放在配置文件中 string[] serverlist = &#123; "127.0.0.1:11211", "10.0.0.132:11211" &#125;; //初始化池 var pool = SockIOPool.GetInstance(); pool.SetServers(serverlist); pool.InitConnections = 3; pool.MinConnections = 3; pool.MaxConnections = 5; pool.SocketConnectTimeout = 1000; pool.SocketTimeout = 3000; pool.MaintenanceSleep = 30; pool.Failover = true; pool.Nagle = false; pool.Initialize(); // 获得客户端实例 Mc = new MemcachedClient &#123;EnableCompression = false&#125;; &#125; /// &lt;summary&gt; /// 存储数据 /// &lt;/summary&gt; /// &lt;param name="key"&gt;&lt;/param&gt; /// &lt;param name="value"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool Set(string key,object value) &#123; return Mc.Set(key, value); &#125; public static bool Set(string key, object value,DateTime time) &#123; return Mc.Set(key, value,time); &#125; /// &lt;summary&gt; /// 获取数据 /// &lt;/summary&gt; /// &lt;param name="key"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static object Get(string key) &#123; return Mc.Get(key); &#125; /// &lt;summary&gt; /// 删除 /// &lt;/summary&gt; /// &lt;param name="key"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool Delete(string key) &#123; return Mc.KeyExists(key) &amp;&amp; Mc.Delete(key); &#125; &#125;&#125;改变用户登录方法UserLogin，用户登录成功后生成GUID，将此GUID存入Cookie并以GUID为键将登录用户信息序列化存入Memcache服务器。1234567891011121314151617181920212223242526public ActionResult UserLogin()&#123; #region 验证码校验 var validateCode = Session["validateCode"] != null ? Session["validateCode"].ToString() : string.Empty; if (string.IsNullOrEmpty(validateCode)) return Content("no:验证码错误!!"); Session["validateCode"] = null; var txtCode = Request["ValidateCode"]; if (!validateCode.Equals(txtCode, StringComparison.InvariantCultureIgnoreCase)) return Content("no:验证码错误!!"); #endregion var userName = Request["UserName"]; var userPwd = Request["PassWord"]; //查询用户是否存在 var user = UserService.LoadEntities(u =&gt; u.UserName == userName &amp;&amp; u.PassWord == userPwd).FirstOrDefault(); if (user == null) return Content("no:登录失败"); //产生一个GUID值作为Memache的键. var sessionId = Guid.NewGuid().ToString(); //将登录用户信息存储到Memcache中。 MemcacheHelper.Set(sessionId, SerializeHelper.SerializeToString(user), DateTime.Now.AddMinutes(20)); //将Memcache的key以Cookie的形式返回给浏览器。 Response.Cookies["sessionId"].Value = sessionId; return Content("ok:登录成功");&#125;改变登录校验控制器FilterController的OnActionExecuting方法，使其校验方式改为从Memcache服务器中读取Cookie中值为键的对象：12345678910111213141516171819202122protected override void OnActionExecuting(ActionExecutingContext filterContext)&#123; base.OnActionExecuting(filterContext); //if (Session["user"] == null) if (Request.Cookies["sessionId"] != null) &#123; var sessionId = Request.Cookies["sessionId"].Value; //根据该值查Memcache. var obj = MemcacheHelper.Get(sessionId); if (obj == null) &#123; filterContext.Result = Redirect("/Login/Index"); return; &#125; var user = SerializeHelper.DeserializeToObject&lt;User&gt;(obj.ToString()); LoginUser = user; //模拟出滑动过期时间. MemcacheHelper.Set(sessionId, obj, DateTime.Now.AddMinutes(20)); &#125; else filterContext.Result = Redirect("/Login/Index");&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MVC</tag>
        <tag>Memcache</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【MVC学习笔记】5.使用Controller来代替Filter完成登录验证（Session校验）]]></title>
    <url>%2FxMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0x5.%E4%BD%BF%E7%94%A8Controller%E6%9D%A5%E4%BB%A3%E6%9B%BFFilter%E5%AE%8C%E6%88%90%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81%EF%BC%88Session%E6%A0%A1%E9%AA%8C%EF%BC%89.html</url>
    <content type="text"><![CDATA[之前的学习中，在对Session校验完成登录验证时，通常使用Filter来处理，方法类似与前文的错误日志过滤，即新建Filter类继承ActionFilterAttribute类，重写OnActionExecuting方法，之后直接在需要验证的Action前加上Filter标记即可。Filter式实现新建登陆校验类新建登陆校验类CheckLoginAttribute12345678910111213141516using System.Web.Mvc;namespace PMS.WebApp.Models&#123; public class CheckLoginAttribute:ActionFilterAttribute &#123; public override void OnActionExecuting(ActionExecutingContext filterContext) &#123; base.OnActionExecuting(filterContext); if (filterContext.HttpContext.Session == null || filterContext.HttpContext.Session["user"] == null) &#123; filterContext.HttpContext.Response.Redirect("/User/Login"); &#125; &#125; &#125;&#125;增加特性在需要校验的Action增加标记以完成校验12345678910111213141516171819202122232425using System.Web.Mvc;using PMS.IBLL;using PMS.WebApp.Models;namespace PMS.WebApp.Controllers&#123; public class UserController : Controller &#123; // // GET: /User/ //private IUserService _userService; //private IUserService UserService //&#123; // get &#123; return _userService ?? (_userService = new UserService()); &#125; // set &#123; _userService = value; &#125; //&#125; private IUserService UserService &#123; get; set; &#125; [CheckLogin] public ActionResult Index() &#123; return Content("OK"); &#125; &#125;&#125;注意：不要在RegisterGlobalFilters方法中注册校验类，否则则会相当于给所有Action都添加了校验这种方法使用起来需要在每个Action方法前添加过滤标签，且效率并不十分高，我们的项目中使用的是一种更为简单高效的方法：使用Controller进行登录验证Controller式实现新建验证父类新建一个用于验证的Controller父类，并在其内重写OnActionExecuting方法完成登陆校验：1234567891011121314151617using System.Web.Mvc;namespace PMS.WebApp.Controllers&#123; public class FilterController : Controller &#123; protected override void OnActionExecuting(ActionExecutingContext filterContext) &#123; base.OnActionExecuting(filterContext); if (Session["user"] == null) &#123; //filterContext.HttpContext.Response.Redirect("/User/Login"); filterContext.Result = Redirect("/User/Login"); &#125; &#125; &#125;&#125;在Controller校验类的OnActionExecuting方法中，有如下代码12//filterContext.HttpContext.Response.Redirect("/User/Login");filterContext.Result = Redirect("/User/Login");我们使用后者而放弃前者的原因是，ASP.NET MVC中规定，Action必须返回ActionResult，如果使用前者，在完成跳转前会先进入到请求的页面，这样不符合我们使用过滤器的初衷。继承校验父类然后使需要校验的Controller继承于我们定义的校验Controller即可完成全局登录校验操作：123456789101112131415161718192021222324using System.Web.Mvc;using PMS.IBLL;namespace PMS.WebApp.Controllers&#123; public class UserController : FilterController//Controller &#123; // // GET: /User/ //private IUserService _userService; //private IUserService UserService //&#123; // get &#123; return _userService ?? (_userService = new UserService()); &#125; // set &#123; _userService = value; &#125; //&#125; private IUserService UserService &#123; get; set; &#125; //[CheckLogin] public ActionResult Index() &#123; return Content("OK"); &#125; &#125;&#125;下面我们对比两种方法的优缺点:Filter定义过程比较复杂，效率也稍低些，但是却可以对每一个Action进行单独的过滤，同一Action也可以有多条过滤信息，使用比较灵活。Controller定义更为简便，效率高，但是却只能对整个Controller中所有方法进行过滤，同一Controller也不太容易有多个Controller过滤父类。综上所述，实际项目中大多需求都是同一Controller下所有方法都需要完成登陆验证，所以其实使用Controller过滤更为高效，应对复杂需求时，灵活混用两种方法也不失为一种好的策略。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MVC</tag>
        <tag>登录验证</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【MVC学习笔记】4.使用Log4Net来进行错误日志的记录]]></title>
    <url>%2FxMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0x4.%E4%BD%BF%E7%94%A8Log4Net%E6%9D%A5%E8%BF%9B%E8%A1%8C%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97%E7%9A%84%E8%AE%B0%E5%BD%95.html</url>
    <content type="text"><![CDATA[在Web应用运行过程中，我们难免会遇到程序运行异常，这个时候我们就应该将异常信息记录下来，以便开发人员和维护人员对异常原因进行还原，对异常原因进行修复。在ASP.NET平台中进行日志记录的组件也有很多，如Log4Net、CommonLogging等，我们这里选用Log4Net进行异常日志的记录。捕获异常在ASP.NET MVC中提供了一个全局的异常处理过滤器：HandleErrorAttribute，可以通过该过滤器捕获异常信息。我们在Models文件夹下新建类型Log4ExceptionAttribute，继承HandleErrorAttribute类，同时重写OnException方法来捕获异常数据：123456789101112131415161718using System.Web.Mvc;namespace PMS.WebApp.Models&#123; public class Log4ExceptionAttribute:HandleErrorAttribute &#123; /// &lt;summary&gt; /// 重写OnException方法来捕获异常数据 /// &lt;/summary&gt; /// &lt;param name="filterContext"&gt;&lt;/param&gt; public override void OnException(ExceptionContext filterContext) &#123; base.OnException(filterContext); //捕获当前异常数据 var ex = filterContext.Exception; &#125; &#125;&#125;新建过滤器后我们还需要在Global文件中调用的RegisterGlobalFilters方法中完成自己定义异常处理过滤的注册。1234567891011121314using System.Web.Mvc;using PMS.WebApp.Models;namespace PMS.WebApp&#123; public class FilterConfig &#123; public static void RegisterGlobalFilters(GlobalFilterCollection filters) &#123; //filters.Add(new HandleErrorAttribute()); filters.Add(new Log4ExceptionAttribute()); &#125; &#125;&#125;队列处理考虑到多用户并发操作时可能产生的问题，我们需要新建一个队列来进行异常信息的暂存，同时开辟一个线程专门对队列中的异常信息进行处理。在Log4ExceptionAttribute类中新建一个静态的异常类型的队列，在发生异常后，程序自动触发OnException方法，方法中将当前的异常信息入队后，跳转到错误页面。12345678910111213141516171819202122232425using System;using System.Collections.Generic;using System.Web.Mvc;namespace PMS.WebApp.Models&#123; public class Log4ExceptionAttribute:HandleErrorAttribute &#123; public static Queue&lt;Exception&gt; Exceptions=new Queue&lt;Exception&gt;(); /// &lt;summary&gt; /// 重写OnException方法来捕获异常数据 /// &lt;/summary&gt; /// &lt;param name="filterContext"&gt;&lt;/param&gt; public override void OnException(ExceptionContext filterContext) &#123; base.OnException(filterContext); //捕获当前异常数据 var ex = filterContext.Exception; //将异常数据入队 Exceptions.Enqueue(ex); //跳转到错误页面 filterContext.HttpContext.Response.Redirect("/Error.html"); &#125; &#125;&#125;Log4Net的配置是在应用程序配置文件中进行的，我们先在配置文件中进行Log4Net的配置。Log4Net需要配置的节点位置和SpringNet完全相同，首先需要在configSessions中新增子节点,然后在configuration节点中增加log4net节点完成具体配置。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;configuration&gt; &lt;configSections&gt; &lt;section name="entityFramework" type="System.Data.Entity.Internal.ConfigFile.EntityFrameworkSection, EntityFramework, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" requirePermission="false" /&gt; &lt;!-- For more information on Entity Framework configuration, visit http://go.microsoft.com/fwlink/?LinkID=237468 --&gt; &lt;!--↓Log4Net配置↓--&gt; &lt;section name="log4net" type="log4net.Config.Log4NetConfigurationSectionHandler, log4net"/&gt; &lt;!--↑Log4Net配置↑--&gt; &lt;!--↓Spring.Net配置↓--&gt; &lt;sectionGroup name="spring"&gt; &lt;section name="context" type="Spring.Context.Support.MvcContextHandler, Spring.Web.Mvc4"/&gt; &lt;/sectionGroup&gt; &lt;!--↑Spring.Net配置↑--&gt; &lt;/configSections&gt; &lt;!--↓Spring.Net配置↓--&gt; &lt;spring&gt; &lt;context&gt; &lt;resource uri="file://~/Config/controllers.xml"/&gt; &lt;resource uri="file://~/Config/services.xml"/&gt; &lt;/context&gt; &lt;/spring&gt; &lt;!--↑Spring.Net配置↑--&gt; &lt;!--↓Log4Net配置↓--&gt; &lt;log4net&gt; &lt;!-- OFF, FATAL, ERROR, WARN, INFO, DEBUG, ALL --&gt; &lt;!-- Set root logger level to ERROR and its appenders --&gt; &lt;root&gt; &lt;level value="ALL"/&gt; &lt;appender-ref ref="SysAppender"/&gt; &lt;/root&gt; &lt;!-- Print only messages of level DEBUG or above in the packages --&gt; &lt;logger name="WebLogger"&gt; &lt;level value="DEBUG"/&gt; &lt;/logger&gt; &lt;appender name="SysAppender" type="log4net.Appender.RollingFileAppender,log4net" &gt; &lt;param name="File" value="App_Data/" /&gt; &lt;param name="AppendToFile" value="true" /&gt; &lt;param name="RollingStyle" value="Date" /&gt; &lt;param name="DatePattern" value="&amp;quot;Logs_&amp;quot;yyyyMMdd&amp;quot;.txt&amp;quot;" /&gt; &lt;param name="StaticLogFileName" value="false" /&gt; &lt;layout type="log4net.Layout.PatternLayout,log4net"&gt; &lt;param name="ConversionPattern" value="%d [%t] %-5p %c - %m%n" /&gt; &lt;param name="Header" value="&amp;#13;&amp;#10;----------------------header--------------------------&amp;#13;&amp;#10;" /&gt; &lt;param name="Footer" value="&amp;#13;&amp;#10;----------------------footer--------------------------&amp;#13;&amp;#10;" /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;appender name="consoleApp" type="log4net.Appender.ConsoleAppender,log4net"&gt; &lt;layout type="log4net.Layout.PatternLayout,log4net"&gt; &lt;param name="ConversionPattern" value="%d [%t] %-5p %c - %m%n" /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;/log4net&gt; &lt;!--↑Log4Net配置↑--&gt; ...&lt;/configuration&gt;进阶配置在配置文件中可以对日志记录的信息、格式、文件名等作出具体的配置，下面是配置信息的详解12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0"?&gt;&lt;configuration&gt; &lt;configSections&gt; &lt;section name="log4net" type="log4net.Config.Log4NetConfigurationSectionHandler,log4net"/&gt; &lt;/configSections&gt; &lt;!--站点日志配置部分--&gt; &lt;log4net&gt; &lt;root&gt; &lt;!--控制级别，由低到高: ALL|DEBUG|INFO|WARN|ERROR|FATAL|OFF--&gt; &lt;!--比如定义级别为INFO，则INFO级别向下的级别，比如DEBUG日志将不会被记录--&gt; &lt;!--如果没有定义LEVEL的值，则缺省为DEBUG--&gt; &lt;level value="ERROR"/&gt; &lt;appender-ref ref="RollingFileAppender"/&gt; &lt;/root&gt; &lt;appender name="RollingFileAppender" type="log4net.Appender.RollingFileAppender"&gt; &lt;!--日志文件名开头--&gt; &lt;file value="c:\Log\TestLog4net.TXT"/&gt; &lt;!--多线程时采用最小锁定--&gt; &lt;lockingModel type="log4net.Appender.FileAppender+MinimalLock"/&gt; &lt;!--日期的格式，每天换一个文件记录，如不设置则永远只记录一天的日志，需设置--&gt; &lt;datePattern value="(yyyyMMdd)"/&gt; &lt;!--是否追加到文件,默认为true，通常无需设置--&gt; &lt;appendToFile value="true"/&gt; &lt;!--变换的形式为日期，这种情况下每天只有一个日志--&gt; &lt;!--此时MaxSizeRollBackups和maximumFileSize的节点设置没有意义--&gt; &lt;!--&lt;rollingStyle value="Date"/&gt;--&gt; &lt;!--变换的形式为日志大小--&gt; &lt;!--这种情况下MaxSizeRollBackups和maximumFileSize的节点设置才有意义--&gt; &lt;RollingStyle value="Size"/&gt; &lt;!--每天记录的日志文件个数，与maximumFileSize配合使用--&gt; &lt;MaxSizeRollBackups value="10"/&gt; &lt;!--每个日志文件的最大大小--&gt; &lt;!--可用的单位:KB|MB|GB--&gt; &lt;!--不要使用小数,否则会一直写入当前日志--&gt; &lt;maximumFileSize value="2MB"/&gt; &lt;!--日志格式--&gt; &lt;layout type="log4net.Layout.PatternLayout"&gt; &lt;conversionPattern value="%date [%t]%-5p %c - %m%n"/&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;/log4net&gt;&lt;/configuration&gt;在Global文件中的Application_Start方法中开启一个线程，用于将队列中的错误信息写入日志文件。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354using System.Linq;using System.Threading;using System.Web.Http;using System.Web.Mvc;using System.Web.Optimization;using System.Web.Routing;using log4net;using PMS.WebApp.Models;using Spring.Web.Mvc;namespace PMS.WebApp&#123; // 注意: 有关启用 IIS6 或 IIS7 经典模式的说明， // 请访问 http://go.microsoft.com/?LinkId=9394801 public class MvcApplication : SpringMvcApplication//HttpApplication &#123; protected void Application_Start() &#123; log4net.Config.XmlConfigurator.Configure();//读取Log4Net配置信息 AreaRegistration.RegisterAllAreas(); WebApiConfig.Register(GlobalConfiguration.Configuration); FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters); RouteConfig.RegisterRoutes(RouteTable.Routes); BundleConfig.RegisterBundles(BundleTable.Bundles); //开启一个线程,扫描异常信息队列. var filePath = Server.MapPath("/Log/"); ThreadPool.QueueUserWorkItem((a) =&gt; &#123; while (true) &#123; //判断队列中是否有数据 if (Log4ExceptionAttribute.Exceptions.Any()) &#123; //出队一条异常信息 var ex = Log4ExceptionAttribute.Exceptions.Dequeue(); //若异常信息不为空 if (ex == null) continue; //将异常信息写入到日志文件中 var logger = LogManager.GetLogger("errorMsg"); logger.Error(ex.ToString()); &#125; else &#123; //若异常信息队列为空，则线程休息三秒 Thread.Sleep(3000); &#125; &#125; &#125;, filePath); &#125; &#125;&#125;成功完成错误日志的配置。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MVC</tag>
        <tag>Log4Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【MVC学习笔记】3.使用Spring.Net应用IOC（依赖倒置）]]></title>
    <url>%2FxMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0x3.%E4%BD%BF%E7%94%A8Spring.Net%E5%BA%94%E7%94%A8IOC%EF%BC%88%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%EF%BC%89.html</url>
    <content type="text"><![CDATA[本篇我们将使用Spring.Net进行依赖导致。到现在，我们已经基本搭建起了项目的框架，但是项目中还存在一个问题，就是尽管层与层之间使用了接口进行隔离，但实例化接口的时候，还是引入了接口实现类的依赖，如下面的代码：123456private IUserService _userService;private IUserService UserService&#123; get &#123; return _userService ?? (_userService = new UserService()); &#125; set &#123; _userService = value; &#125;&#125;面向接口编程，Controller应该只依赖于站点业务层的接口，而不能依赖于具体的实现，否则，就违背了在层之间设置接口的初衷了。另外，如果上层只依赖于下层的接口，在做单元测试的时候，就可以用Moq，Fakes等Mock工具来按实际需求来模拟接口的实现，就可以灵活的控制接口的返回值来对各种情况进行测试，如果依赖于具体的实现，项目的可测试性将大大减小，不利于进行自动化的单元测试。要不依赖于具体的实现，就不能使用通常的 T t = new T() 的方式来获得一个类的实例了，需要通过IOC容器来对对象生命周期，依赖关系等进行统一的管理，这里，我们将使用Spring.Net应用IOC。Spring.Net在控制台程序中的使用我们将通过一个简单的控制台示例来展示Spring.Net的使用方法创建测试用的类：123456789101112131415161718192021222324namespace SpringNetDemo&#123; public interface IClass &#123; string Name &#123; get; set; &#125; Student Monitor &#123; get; set; &#125; string GetMsg(); &#125; public class Class : IClass &#123; public string Name &#123; get; set; &#125; public Student Monitor &#123; get; set; &#125; public string GetMsg() &#123; return "班级名称：" + Name + "，班长：" + Monitor.Name; &#125; &#125; public class Student &#123; public string Name &#123; get; set; &#125; &#125;&#125;两个类，一个接口，Student类中有一个string类型的属性，为Name，Class类中除了string类型的Name属性外还有一个Student类型的Monitor属性，方法GetMsg可以返回当前Class对象的简介，包括班级名和班长名两个内容。Class类实现IClass接口。先做简单的测试：12345678910IClass c6=new Class()&#123; Monitor = new Student() &#123; Name = "李芙蓉" &#125;, Name = "六班"&#125;;Console.WriteLine(c6.GetMsg());Console.ReadKey();输出为：接下来，我们换用Spring.Net容器来声明对象首先引用dll文件需要核心库Spring.Core.dll和Spring.Net使用的日志记录组件Common.Logging.dll然后我们需要了解当前的程序集名称和命名空间在项目中新建一个xml文件，命名为services.xml：1234567891011&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;objects xmlns="http://www.springframework.net"&gt; &lt;description&gt;An example that demonstrates simple IoC features.&lt;/description&gt; &lt;object name="Class" type="SpringNetDemo.Class,SpringNetDemo"&gt; &lt;property name="Name" value="尖子班"/&gt; &lt;property name="Monitor" ref="Student"/&gt; &lt;/object&gt; &lt;object name="Student" type="SpringNetDemo.Student, SpringNetDemo"&gt; &lt;property name="Name" value="陈二蛋"/&gt; &lt;/object&gt;&lt;/objects&gt;在xml中新建objects根节点，其中加入需要容器生成的object子节点，object子节点的type属性中需要指明类的完整名称（带有程序集）和当前命名空间，如果需要为当前类的属性赋默认值，则可以在object节点中增加property节点，配置其value属性来为类的属性赋初值，若类的属性仍然为其他类对象时，可以新建该类型的object节点，并给予其name属性，再在当前属性的property节点中将ref属性，指向新增object节点的name属性。注意：要把xml文件设置为“如果较新则复制”或者“始终复制”，否则生成时将不会自动复制到程序目录然后在应用程序配置文件中配置Spring.Net的信息：1234567891011121314&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration&gt; &lt;configSections&gt; &lt;sectionGroup name="spring"&gt; &lt;section name="context" type="Spring.Context.Support.ContextHandler, Spring.Core"/&gt; &lt;section name="objects" type="Spring.Context.Support.DefaultSectionHandler, Spring.Core" /&gt; &lt;/sectionGroup&gt; &lt;/configSections&gt; &lt;spring&gt; &lt;context&gt; &lt;resource uri="file://services.xml"/&gt; &lt;/context&gt; &lt;/spring&gt;&lt;/configuration&gt;运行程序，得到输出结果：成功实现IOCSpring.Net在ASP.NET MVC中的使用方法和在控制台程序中大同小异同样，首先要导入dll文件MVC项目中需要引用的dll文件稍多些，需要五个，除了值钱的两个外，还需要三个Web相关的dll。为了便于管理，我们在MVC项目更目录新建Config文件夹来保存配置文件，并在其中新建两个xml文件controllers.xml：123456&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;objects xmlns="http://www.springframework.net"&gt;、 &lt;object type="PMS.WebApp.Controllers.UserController , PMS.WebApp" singleton="false" &gt; &lt;property name="UserService" ref="UserService" /&gt; &lt;/object&gt;&lt;/objects&gt;services.xml：12345&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;objects xmlns="http://www.springframework.net"&gt; &lt;object name="UserService" type="PMS.BLL.UserService, PMS.BLL" singleton="false" &gt; &lt;/object&gt;&lt;/objects&gt;同样是出于方便管理考虑，我们将控制器和业务类分两个文件来保存，文件中节点的规则与控制台示例中完全相同。修改Web.config配置文件在配置文件的configSections节点中增加如图的sectionGrup节点，configuration节点中增加Spring节点，并在spring节点中的context节点中使用resource节点设置配置文件的路径。修改Global文件修改根目录的Global.asax文件，将MvcApplication类的父类由HttpApplication更改为SpringMvcApplication。1public class MvcApplication : SpringMvcApplication//HttpApplication最后，将原来的控制器中代码修改，就成功地在MVC项目中使用Spring.Net实现了IOC1234567//private IUserService _userService;//private IUserService UserService//&#123;// get &#123; return _userService ?? (_userService = new UserService()); &#125;// set &#123; _userService = value; &#125;//&#125;private IUserService UserService &#123; get; set; &#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MVC</tag>
        <tag>Spring.Net</tag>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【MVC学习笔记】2.使用T4模板生成其他类的具体实现]]></title>
    <url>%2FxMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0x2.%E4%BD%BF%E7%94%A8T4%E6%A8%A1%E6%9D%BF%E7%94%9F%E6%88%90%E5%85%B6%E4%BB%96%E7%B1%BB%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0.html</url>
    <content type="text"><![CDATA[在前篇中我们已经将User类中的代码做了具体的实现，但仍然有多个实体类未实现，以后可能还会增加新的数据表，数据表结构也有可能发生变化，所以我们使用T4模板来完成类的生成，这样就算数据库表发生了改变，也会自动根据改变后的实体对类进行重新生成。DAL层下面是数据访问层的T4模板文件 Dal.tt12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;#@ template language="C#" debug="false" hostspecific="true"#&gt;&lt;#@ include file="EF.Utility.CS.ttinclude"#&gt;&lt;#@ output extension=".cs"#&gt; &lt;#CodeGenerationTools code = new CodeGenerationTools(this);MetadataLoader loader = new MetadataLoader(this);CodeRegion region = new CodeRegion(this, 1);MetadataTools ef = new MetadataTools(this);//EF实体文件在项目中的路径string inputFile = @"..\\PMS.Model\\PMS.edmx";EdmItemCollection ItemCollection = loader.CreateEdmItemCollection(inputFile);string namespaceName = code.VsNamespaceSuggestion();EntityFrameworkTemplateFileManager fileManager = EntityFrameworkTemplateFileManager.Create(this);#&gt;&lt;#//这里为命名空间部分，手动更改为相应的命名空间 #&gt;using PMS.IDAL;using PMS.Model;using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace PMS.DAL&#123;&lt;#// Emit Entity Typesforeach (EntityType entity in ItemCollection.GetItems&lt;EntityType&gt;().OrderBy(e =&gt; e.Name))&#123; //fileManager.StartNewFile(entity.Name + "RepositoryExt.cs"); //BeginNamespace(namespaceName, code); #&gt; public partial class &lt;#=entity.Name#&gt;Dal :BaseDal&lt;&lt;#=entity.Name#&gt;&gt;,I&lt;#=entity.Name#&gt;Dal &#123; &#125;&lt;#&#125;#&gt; &#125;我们将EF实体文件路径、命名空间更改为对应的值时，Ctrl+S 保存，即可生成对应的其他类型的数据访问类其他层中也大同小异，只需要做对应的更改即可，下面我将提供相应的代码。IDAL层IDal.tt123456789101112131415161718192021222324252627282930313233343536373839404142&lt;#@ template language="C#" debug="false" hostspecific="true"#&gt;&lt;#@ include file="EF.Utility.CS.ttinclude"#&gt;&lt;#@ output extension=".cs"#&gt; &lt;#CodeGenerationTools code = new CodeGenerationTools(this);MetadataLoader loader = new MetadataLoader(this);CodeRegion region = new CodeRegion(this, 1);MetadataTools ef = new MetadataTools(this);string inputFile = @"..\\PMS.Model\\PMS.edmx";EdmItemCollection ItemCollection = loader.CreateEdmItemCollection(inputFile);string namespaceName = code.VsNamespaceSuggestion();EntityFrameworkTemplateFileManager fileManager = EntityFrameworkTemplateFileManager.Create(this);#&gt;using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using PMS.Model;namespace PMS.IDAL&#123; &lt;#// Emit Entity Typesforeach (EntityType entity in ItemCollection.GetItems&lt;EntityType&gt;().OrderBy(e =&gt; e.Name))&#123; //fileManager.StartNewFile(entity.Name + "RepositoryExt.cs"); //BeginNamespace(namespaceName, code); #&gt; public partial interface I&lt;#=entity.Name#&gt;Dal :IBaseDal&lt;&lt;#=entity.Name#&gt;&gt; &#123; &#125;&lt;#&#125;#&gt; &#125;IDbSession.tt1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;#@ template language="C#" debug="false" hostspecific="true"#&gt;&lt;#@ include file="EF.Utility.CS.ttinclude"#&gt;&lt;#@ output extension=".cs"#&gt; &lt;#CodeGenerationTools code = new CodeGenerationTools(this);MetadataLoader loader = new MetadataLoader(this);CodeRegion region = new CodeRegion(this, 1);MetadataTools ef = new MetadataTools(this);string inputFile = @"..\\PMS.Model\\PMS.edmx";EdmItemCollection ItemCollection = loader.CreateEdmItemCollection(inputFile);string namespaceName = code.VsNamespaceSuggestion();EntityFrameworkTemplateFileManager fileManager = EntityFrameworkTemplateFileManager.Create(this);#&gt;using System;using System.Collections.Generic;using System.Data.Entity;using System.Linq;using System.Text;using System.Threading.Tasks;namespace PMS.IDAL&#123; public partial interface IDbSession &#123;&lt;#// Emit Entity Typesforeach (EntityType entity in ItemCollection.GetItems&lt;EntityType&gt;().OrderBy(e =&gt; e.Name))&#123; //fileManager.StartNewFile(entity.Name + "RepositoryExt.cs"); //BeginNamespace(namespaceName, code); #&gt; I&lt;#=entity.Name#&gt;Dal &lt;#=entity.Name#&gt;Dal&#123;get;set;&#125;&lt;#&#125;#&gt; &#125; &#125;DALFactory层SimpleDalFactory.tt1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;#@ template language="C#" debug="false" hostspecific="true"#&gt;&lt;#@ include file="EF.Utility.CS.ttinclude"#&gt;&lt;#@ output extension=".cs"#&gt; &lt;#CodeGenerationTools code = new CodeGenerationTools(this);MetadataLoader loader = new MetadataLoader(this);CodeRegion region = new CodeRegion(this, 1);MetadataTools ef = new MetadataTools(this);string inputFile =@"..\\PMS.Model\\PMS.edmx";EdmItemCollection ItemCollection = loader.CreateEdmItemCollection(inputFile);string namespaceName = code.VsNamespaceSuggestion();EntityFrameworkTemplateFileManager fileManager = EntityFrameworkTemplateFileManager.Create(this);#&gt;using SW.OA.IDAL;using System;using System.Collections.Generic;using System.Configuration;using System.Linq;using System.Reflection;using System.Text;using System.Threading.Tasks;namespace SW.OA.DALFactory&#123; public partial class AbstractFactory &#123; &lt;#foreach (EntityType entity in ItemCollection.GetItems&lt;EntityType&gt;().OrderBy(e =&gt; e.Name))&#123; #&gt; public static I&lt;#=entity.Name#&gt;Dal Create&lt;#=entity.Name#&gt;Dal() &#123; string fullClassName = NameSpace + ".&lt;#=entity.Name#&gt;Dal"; return CreateInstance(fullClassName) as I&lt;#=entity.Name#&gt;Dal; &#125;&lt;#&#125;#&gt; &#125; &#125;DbSession.tt123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;#@ template language="C#" debug="false" hostspecific="true"#&gt;&lt;#@ include file="EF.Utility.CS.ttinclude"#&gt;&lt;#@ output extension=".cs"#&gt; &lt;#CodeGenerationTools code = new CodeGenerationTools(this);MetadataLoader loader = new MetadataLoader(this);CodeRegion region = new CodeRegion(this, 1);MetadataTools ef = new MetadataTools(this);string inputFile = @"..\\PMS.Model\\PMS.edmx";EdmItemCollection ItemCollection = loader.CreateEdmItemCollection(inputFile);string namespaceName = code.VsNamespaceSuggestion();EntityFrameworkTemplateFileManager fileManager = EntityFrameworkTemplateFileManager.Create(this);#&gt;using PMS.DAL;using PMS.IDAL;using PMS.Model;using System;using System.Collections.Generic;using System.Data.Entity;using System.Linq;using System.Text;using System.Threading.Tasks;namespace PMS.DALFactory&#123; public partial class DBSession : IDBSession &#123;&lt;#// Emit Entity Typesforeach (EntityType entity in ItemCollection.GetItems&lt;EntityType&gt;().OrderBy(e =&gt; e.Name))&#123; //fileManager.StartNewFile(entity.Name + "RepositoryExt.cs"); //BeginNamespace(namespaceName, code); #&gt; private I&lt;#=entity.Name#&gt;Dal _&lt;#=entity.Name#&gt;Dal; public I&lt;#=entity.Name#&gt;Dal &lt;#=entity.Name#&gt;Dal &#123; get &#123; if(_&lt;#=entity.Name#&gt;Dal == null) &#123; _&lt;#=entity.Name#&gt;Dal = AbstractFactory.Create&lt;#=entity.Name#&gt;Dal(); &#125; return _&lt;#=entity.Name#&gt;Dal; &#125; set &#123; _&lt;#=entity.Name#&gt;Dal = value; &#125; &#125;&lt;#&#125;#&gt; &#125; &#125;BLL层Service.tt12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;#@ template language="C#" debug="false" hostspecific="true"#&gt;&lt;#@ include file="EF.Utility.CS.ttinclude"#&gt;&lt;#@ output extension=".cs"#&gt; &lt;#CodeGenerationTools code = new CodeGenerationTools(this);MetadataLoader loader = new MetadataLoader(this);CodeRegion region = new CodeRegion(this, 1);MetadataTools ef = new MetadataTools(this);string inputFile = @"..\\PMS.Model\\PMS.edmx";EdmItemCollection ItemCollection = loader.CreateEdmItemCollection(inputFile);string namespaceName = code.VsNamespaceSuggestion();EntityFrameworkTemplateFileManager fileManager = EntityFrameworkTemplateFileManager.Create(this);#&gt;using PMS.IBLL;using PMS.Model;using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace PMS.BLL&#123;&lt;#// Emit Entity Typesforeach (EntityType entity in ItemCollection.GetItems&lt;EntityType&gt;().OrderBy(e =&gt; e.Name))&#123; //fileManager.StartNewFile(entity.Name + "RepositoryExt.cs"); //BeginNamespace(namespaceName, code); #&gt; public partial class &lt;#=entity.Name#&gt;Service :BaseService&lt;&lt;#=entity.Name#&gt;&gt;,I&lt;#=entity.Name#&gt;Service &#123; public override void SetCurrentDal() &#123; CurrentDal = this.CurrentDbSession.&lt;#=entity.Name#&gt;Dal; &#125; &#125; &lt;#&#125;#&gt; &#125;IBLL层IService.tt123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;#@ template language="C#" debug="false" hostspecific="true"#&gt;&lt;#@ include file="EF.Utility.CS.ttinclude"#&gt;&lt;#@ output extension=".cs"#&gt; &lt;#CodeGenerationTools code = new CodeGenerationTools(this);MetadataLoader loader = new MetadataLoader(this);CodeRegion region = new CodeRegion(this, 1);MetadataTools ef = new MetadataTools(this);string inputFile = @"..\\PMS.Model\\PMS.edmx";EdmItemCollection ItemCollection = loader.CreateEdmItemCollection(inputFile);string namespaceName = code.VsNamespaceSuggestion();EntityFrameworkTemplateFileManager fileManager = EntityFrameworkTemplateFileManager.Create(this);#&gt;using PMS.Model;using PMS.Model.Search;using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace PMS.IBLL&#123;&lt;#// Emit Entity Typesforeach (EntityType entity in ItemCollection.GetItems&lt;EntityType&gt;().OrderBy(e =&gt; e.Name))&#123; //fileManager.StartNewFile(entity.Name + "RepositoryExt.cs"); //BeginNamespace(namespaceName, code); #&gt; public partial interface I&lt;#=entity.Name#&gt;Service : IBaseService&lt;&lt;#=entity.Name#&gt;&gt; &#123; &#125; &lt;#&#125;#&gt; &#125;至此，我们完成了基本框架内容的填充。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【MVC学习笔记】1.项目结构搭建及单个类在各个层次中的实现]]></title>
    <url>%2FxMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0x1.%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%8D%95%E4%B8%AA%E7%B1%BB%E5%9C%A8%E5%90%84%E4%B8%AA%E5%B1%82%E6%AC%A1%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0.html</url>
    <content type="text"><![CDATA[新人刚开始学习ASP.NET MVC，若有不足之处希望能得到您的指点，不胜感激！层级结构先来一张项目的层级结构图:Model：模型层，主要是各种类型、枚举以及ORM框架，框架完成数据库和实体类的映射。项目中选用了微软的开源ORM框架 EntityFramework 6.0 （以下简称EF），数据库则选择了微软的轻量级数据库SQL Server Compact 4.0本地数据库（简称Compact），Compact对EF支持比较完美，又属于文档型数据库，部署起来比较简洁。DAL：数据访问层，主要是对数据库的操作层，为业务逻辑层或表示层提供数据服务。IDAL：数据访问接口层，是数据访问层的接口，降低耦合。DALFactory：数据会话层，封装了所有数据操作类实例的创建，将数据访问层与业务逻辑层解耦。BLL：业务逻辑层，主要负责对数据层的操作，把一些数据层的操作进行组合以完成业务的需要。IBLL：业务逻辑接口层，业务逻辑层的接口，降低耦合。WebApp：表现层，是一个ASP.NET MVC项目，完成具体网站的实现。Common：通用层，用来存放一些工具类。下面是各个层级之间具体的实现，首先创建以 项目名.层级名 命名的各个层次，除WebApp层为ASP.NET MVC项目外，其余均创建为类库项目。各层级搭建模型层的构建先建立模型层，新建ASP.NET 实体数据模型，关联到已经设计好的数据库，EF自动完成模型类的创建。数据访问层的构建DAL层中，我们首先需要一个方法来获取单例的EF数据操纵上下文对象，以保证每个用户访问时只有使用一个上下文对象对数据库进行操作。DbContextFactory.cs123456789101112131415161718192021using System.Data.Entity;using System.Runtime.Remoting.Messaging;using PMS.Model;namespace PMS.DAL&#123; public class DbContextFactory &#123; /// &lt;summary&gt; /// 负责创建EF数据操作上下文实例,必须保证线程内唯一 /// &lt;/summary&gt; public static DbContext CreateContext() &#123; DbContext dbContext = (DbContext)CallContext.GetData("dbContext"); if (dbContext != null) return dbContext; dbContext = new PMSEntities(); CallContext.SetData("dbContext", dbContext); return dbContext; &#125; &#125;&#125;为User类创建DAL层，实现查询、分页查询、增加、删除和修改这五个基本的方法：UserDAL.cs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475using System;using System.Data.Entity;using System.Linq;using PMS.IDAL;namespace PMS.DAL&#123; public partial class UserDal &#123; public DbContext DbEntities = DbContextFactory.CreateContext(); /// &lt;summary&gt; /// 查询过滤 /// &lt;/summary&gt; /// &lt;param name="whereLamada"&gt;过滤条件Lambda表达式&lt;/param&gt; /// &lt;returns&gt;实体集合&lt;/returns&gt; public IQueryable&lt;UserDal&gt; LoadEntities(System.Linq.Expressions.Expression&lt;Func&lt;UserDal, bool&gt;&gt; whereLamada) &#123; return DbEntities.Set&lt;UserDal&gt;().Where(whereLamada); &#125; /// &lt;summary&gt; /// 分页查询 /// &lt;/summary&gt; /// &lt;typeparam name="TS"&gt;排序类型&lt;/typeparam&gt; /// &lt;param name="pageIndex"&gt;查询的页码&lt;/param&gt; /// &lt;param name="pageSize"&gt;每页显示的数目&lt;/param&gt; /// &lt;param name="totalCount"&gt;符合条件的总行数&lt;/param&gt; /// &lt;param name="whereLambda"&gt;过滤条件Lambda表达式&lt;/param&gt; /// &lt;param name="orderbyLambda"&gt;排序Lambda表达式&lt;/param&gt; /// &lt;param name="isAsc"&gt;排序方向&lt;/param&gt; /// &lt;returns&gt;实体集合&lt;/returns&gt; public IQueryable&lt;UserDal&gt; LoadPageEntities&lt;TS&gt;(int pageIndex, int pageSize, out int totalCount, System.Linq.Expressions.Expression&lt;Func&lt;UserDal, bool&gt;&gt; whereLambda, System.Linq.Expressions.Expression&lt;Func&lt;UserDal, TS&gt;&gt; orderbyLambda, bool isAsc) &#123; var temp = DbEntities.Set&lt;UserDal&gt;().Where(whereLambda); totalCount = temp.Count(); temp = isAsc ? temp.OrderBy(orderbyLambda).Skip((pageIndex - 1) * pageSize).Take(pageSize) : temp.OrderByDescending(orderbyLambda).Skip((pageIndex - 1) * pageSize).Take(pageSize); return temp; &#125; /// &lt;summary&gt; /// 删除数据 /// &lt;/summary&gt; /// &lt;param name="entity"&gt;待删数据&lt;/param&gt; /// &lt;returns&gt;删除结果&lt;/returns&gt; public bool DeleteEntity(UserDal entity) &#123; DbEntities.Entry(entity).State = EntityState.Deleted; return true; &#125; /// &lt;summary&gt; /// 编辑数据 /// &lt;/summary&gt; /// &lt;param name="entity"&gt;待编辑数据&lt;/param&gt; /// &lt;returns&gt;编辑结果&lt;/returns&gt; public bool EditEntity(UserDal entity) &#123; DbEntities.Entry(entity).State = EntityState.Modified; return true; &#125; /// &lt;summary&gt; /// 添加数据 /// &lt;/summary&gt; /// &lt;param name="entity"&gt;待添加数据&lt;/param&gt; /// &lt;returns&gt;已添加数据&lt;/returns&gt; public UserDal AddEntity(UserDal entity) &#123; entity = DbEntities.Set&lt;UserDal&gt;().Add(entity); return entity; &#125; &#125;&#125;注：这里的增删改操作并不即时进行，而是在封装在数据会话层中，以实现工作单元模式，提高数据库的操作效率。考虑到每个类都需要实现相同的数据操作，我们可以将以上方法封装到一个泛型基类中，各类型只需要继承泛型基类就可以实现以上方法：BaseDal.cs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374using System;using System.Data.Entity;using System.Linq;namespace PMS.DAL&#123; public class BaseDal&lt;T&gt; where T:class ,new() &#123; public DbContext DbEntities = DbContextFactory.CreateContext(); /// &lt;summary&gt; /// 查询过滤 /// &lt;/summary&gt; /// &lt;param name="whereLamada"&gt;过滤条件Lambda表达式&lt;/param&gt; /// &lt;returns&gt;实体集合&lt;/returns&gt; public IQueryable&lt;T&gt; LoadEntities(System.Linq.Expressions.Expression&lt;Func&lt;T, bool&gt;&gt; whereLamada) &#123; return DbEntities.Set&lt;T&gt;().Where(whereLamada); &#125; /// &lt;summary&gt; /// 分页查询 /// &lt;/summary&gt; /// &lt;typeparam name="TS"&gt;排序类型&lt;/typeparam&gt; /// &lt;param name="pageIndex"&gt;查询的页码&lt;/param&gt; /// &lt;param name="pageSize"&gt;每页显示的数目&lt;/param&gt; /// &lt;param name="totalCount"&gt;符合条件的总行数&lt;/param&gt; /// &lt;param name="whereLambda"&gt;过滤条件Lambda表达式&lt;/param&gt; /// &lt;param name="orderbyLambda"&gt;排序Lambda表达式&lt;/param&gt; /// &lt;param name="isAsc"&gt;排序方向&lt;/param&gt; /// &lt;returns&gt;实体集合&lt;/returns&gt; public IQueryable&lt;T&gt; LoadPageEntities&lt;TS&gt;(int pageIndex, int pageSize, out int totalCount, System.Linq.Expressions.Expression&lt;Func&lt;T, bool&gt;&gt; whereLambda, System.Linq.Expressions.Expression&lt;Func&lt;T, TS&gt;&gt; orderbyLambda, bool isAsc) &#123; var temp = DbEntities.Set&lt;T&gt;().Where(whereLambda); totalCount = temp.Count(); temp = isAsc ? temp.OrderBy(orderbyLambda).Skip((pageIndex - 1) * pageSize).Take(pageSize) : temp.OrderByDescending(orderbyLambda).Skip((pageIndex - 1) * pageSize).Take(pageSize); return temp; &#125; /// &lt;summary&gt; /// 删除数据 /// &lt;/summary&gt; /// &lt;param name="entity"&gt;待删数据&lt;/param&gt; /// &lt;returns&gt;删除结果&lt;/returns&gt; public bool DeleteEntity(T entity) &#123; DbEntities.Entry(entity).State = EntityState.Deleted; return true; &#125; /// &lt;summary&gt; /// 编辑数据 /// &lt;/summary&gt; /// &lt;param name="entity"&gt;待编辑数据&lt;/param&gt; /// &lt;returns&gt;编辑结果&lt;/returns&gt; public bool EditEntity(T entity) &#123; DbEntities.Entry(entity).State = EntityState.Modified; return true; &#125; /// &lt;summary&gt; /// 添加数据 /// &lt;/summary&gt; /// &lt;param name="entity"&gt;待添加数据&lt;/param&gt; /// &lt;returns&gt;已添加数据&lt;/returns&gt; public T AddEntity(T entity) &#123; entity = DbEntities.Set&lt;T&gt;().Add(entity); //DbEntities.SaveChanges(); return entity; &#125; &#125;&#125;UserDal继承BaseDal12345678910using PMS.IDAL;using PMS.Model;namespace PMS.DAL&#123; public partial class UserDal : BaseDal&lt;User&gt; &#123; &#125;&#125;数据访问接口层的构建然后我们建立相应的IbaseDal接口和IUserDal接口，并且使UserDal类实现IUserDal接口IBaseDal：1234567891011121314151617181920using System;using System.Linq;namespace PMS.IDAL&#123; public interface IBaseDal&lt;T&gt; where T:class,new() &#123; IQueryable&lt;T&gt; LoadEntities(System.Linq.Expressions.Expression&lt;Func&lt;T, bool&gt;&gt; whereLamada); IQueryable&lt;T&gt; LoadPageEntities&lt;s&gt;(int pageIndex, int pageSize, out int totalCount, System.Linq.Expressions.Expression&lt;Func&lt;T, bool&gt;&gt; whereLambda, System.Linq.Expressions.Expression&lt;Func&lt;T, s&gt;&gt; orderbyLambda, bool isAsc); bool DeleteEntity(T entity); bool EditEntity(T entity); T AddEntity(T entity); &#125;&#125;IUserDal：123456789using PMS.Model;namespace PMS.IDAL&#123; public partial interface IUserDal:IBaseDal&lt;User&gt; &#123; &#125;&#125;UserDal实现IUserDal接口：1public partial class UserDal : BaseDal&lt;User&gt;,IUserDal数据会话层的构建抽象工厂类AbstractFactory：1234567891011121314151617181920212223242526272829303132using System.Configuration;using System.Reflection;using PMS.IDAL;namespace PMS.DALFactory&#123; public partial class AbstractFactory &#123; //读取保存在配置文件中的程序集名称与命名空间名 private static readonly string AssemblyPath = ConfigurationManager.AppSettings["AssemblyPath"]; private static readonly string NameSpace = ConfigurationManager.AppSettings["NameSpace"]; /// &lt;summary&gt; /// 获取UserDal的实例 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static IUserDal CreateUserInfoDal() &#123; var fullClassName = NameSpace + ".UserInfoDal"; return CreateInstance(fullClassName) as IUserDal; &#125; /// &lt;summary&gt; /// 通过反射获得程序集中某类型的实例 /// &lt;/summary&gt; /// &lt;param name="className"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private static object CreateInstance(string className) &#123; var assembly = Assembly.Load(AssemblyPath); return assembly.CreateInstance(className); &#125; &#125;&#125;数据会话类DbSession：123456789101112131415161718192021222324252627282930using System.Data.Entity;using PMS.IDAL;using PMS.DAL;namespace PMS.DALFactory&#123; public partial class DbSession:IDbSession &#123; public DbContext Db &#123; get &#123; return DbContextFactory.CreateContext(); &#125; &#125; private IUserDal _userDal; public IUserDal UserDal &#123; get &#123; return _userDal ?? (_userDal = AbstractFactory.CreateUserInfoDal()); &#125; set &#123; _userDal = value; &#125; &#125; /// &lt;summary&gt; /// 工作单元模式，统一保存数据 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public bool SaveChanges() &#123; return Db.SaveChanges() &gt; 0; &#125; &#125;&#125;业务逻辑层的构建业务类基类BaseService1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586using System;using System.Linq;using System.Linq.Expressions;using PMS.DALFactory;using PMS.IDAL;namespace PMS.BLL&#123; public abstract class BaseService&lt;T&gt; where T:class,new() &#123; public IDbSession CurrentDbSession &#123; get &#123; return new DbSession(); &#125; &#125; public IBaseDal&lt;T&gt; CurrentDal &#123; get; set; &#125; public abstract void SetCurrentDal(); public BaseService() &#123; SetCurrentDal();//子类一定要实现抽象方法，以指明当前类的子类类型。 &#125; /// &lt;summary&gt; /// 查询过滤 /// &lt;/summary&gt; /// &lt;param name="whereLambda"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public IQueryable&lt;T&gt; LoadEntities(Expression&lt;Func&lt;T, bool&gt;&gt; whereLambda) &#123; return CurrentDal.LoadEntities(whereLambda); &#125; /// &lt;summary&gt; /// 分页 /// &lt;/summary&gt; /// &lt;typeparam name="s"&gt;&lt;/typeparam&gt; /// &lt;param name="pageIndex"&gt;&lt;/param&gt; /// &lt;param name="pageSize"&gt;&lt;/param&gt; /// &lt;param name="totalCount"&gt;&lt;/param&gt; /// &lt;param name="whereLambda"&gt;&lt;/param&gt; /// &lt;param name="orderbyLambda"&gt;&lt;/param&gt; /// &lt;param name="isAsc"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public IQueryable&lt;T&gt; LoadPageEntities&lt;s&gt;(int pageIndex, int pageSize, out int totalCount, Expression&lt;Func&lt;T, bool&gt;&gt; whereLambda, Expression&lt;Func&lt;T, s&gt;&gt; orderbyLambda, bool isAsc) &#123; return CurrentDal.LoadPageEntities&lt;s&gt;(pageIndex, pageSize, out totalCount, whereLambda, orderbyLambda, isAsc); &#125; /// &lt;summary&gt; /// 删除 /// &lt;/summary&gt; /// &lt;param name="entity"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public bool DeleteEntity(T entity) &#123; CurrentDal.DeleteEntity(entity); return CurrentDbSession.SaveChanges(); &#125; /// &lt;summary&gt; /// 编辑 /// &lt;/summary&gt; /// &lt;param name="entity"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public bool EditEntity(T entity) &#123; CurrentDal.EditEntity(entity); return CurrentDbSession.SaveChanges(); &#125; /// &lt;summary&gt; /// 添加数据 /// &lt;/summary&gt; /// &lt;param name="entity"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public T AddEntity(T entity) &#123; CurrentDal.AddEntity(entity); CurrentDbSession.SaveChanges(); return entity; &#125; &#125;&#125;UserService类：12345678910111213using PMS.IBLL;using PMS.Model;namespace PMS.BLL&#123; public partial class UserService : BaseService&lt;User&gt; &#123; public override void SetCurrentDal() &#123; CurrentDal = CurrentDbSession.UserDal; &#125; &#125;&#125;业务逻辑接口层的构建直接建立对应的接口并使用UserService类实现IUserService接口IBaseService接口：1234567891011121314151617181920212223using System;using System.Linq;using System.Linq.Expressions;using PMS.IDAL;namespace PMS.IBLL&#123; public interface IBaseService&lt;T&gt; where T : class,new() &#123; IDbSession CurrentDbSession &#123; get; &#125; IBaseDal&lt;T&gt; CurrentDal &#123; get; set; &#125; void SetCurrentDal(); IQueryable&lt;T&gt; LoadEntities(Expression&lt;Func&lt;T, bool&gt;&gt; whereLambda); IQueryable&lt;T&gt; LoadPageEntities&lt;s&gt;(int pageIndex, int pageSize, out int totalCount, Expression&lt;Func&lt;T, bool&gt;&gt; whereLambda, Expression&lt;Func&lt;T, s&gt;&gt; orderbyLambda, bool isAsc); bool DeleteEntity(T entity); bool EditEntity(T entity); T AddEntity(T entity); &#125;&#125;IUserService接口:123456789using PMS.Model;namespace PMS.IBLL&#123; public partial interface IUserService:IBaseService&lt;User&gt; &#123; &#125;&#125;使用UserService类实现IUserService接口:1public partial class UserService : BaseService&lt;User&gt;, IUserService以上我们就完成了整个框架中关于User类的各层次的实现。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【爬虫学习笔记】基于 SimHash 的去重复处理模块ContentSeen的构建]]></title>
    <url>%2Fx%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0x%E5%9F%BA%E4%BA%8E-SimHash-%E7%9A%84%E5%8E%BB%E9%87%8D%E5%A4%8D%E5%A4%84%E7%90%86%E6%A8%A1%E5%9D%97ContentSeen%E7%9A%84%E6%9E%84%E5%BB%BA.html</url>
    <content type="text"><![CDATA[Internet上的一些站点常常存在着镜像网站（mirror），即两个网站的内容一样但网页对应的域名不同。这样会导致对同一份网页爬虫重复抓取多次。为了避免这种情况，对于每一份抓取到的网页，它首先需要进入ContentSeen模块。该模块会判断网页的内容是否和已下载过的某个网页的内容一致，如果一致，则该网页不会再被送去进行下一步的处理。这样的做法能够显著的降低爬虫需要下载的网页数。至于如果判断两个网页的内容是否一致，一般的思路是这样的：并不会去直接比较两个网页的内容，而是将网页的内容经过计算生成FingerPrint（指纹），通常FingerPrint是一个固定长度的字符串，要比网页的正文短很多。如果两个网页的FingerPrint一样，则认为它们内容完全相同。为了完成这一模块，首先我们需要一个强大的指纹算法，将我们的网页内容计算成指纹存入数据库，下次直接判断指纹在保存前通过指纹的对比即可成功完成去重复操作。SmiHash算法首先来看一下大名鼎鼎的Google公司使用的网页去重复算法SimHash吧：GoogleMoses Charikar发表的一篇论文“detecting near-duplicates for web crawling”中提出了simhash算法，专门用来解决亿万级别的网页的去重任务。SimHash作为locality sensitive hash（局部敏感哈希）的一种：其主要思想是降维，将高维的特征向量映射成低维的特征向量，通过两个向量的Hamming Distance来确定文章是否重复或者高度近似。其中，Hamming Distance，又称汉明距离，在信息论中，两个等长字符串之间的汉明距离是两个字符串对应位置的不同字符的个数。也就是说，它就是将一个字符串变换成 另外一个字符串所需要替换的字符个数。例如：1011101 与 1001001 之间的汉明距离是 2。至于我们常说的字符串编辑距离则是一般形式的汉明距离。如此，通过比较多个文档的SimHash值的海明距离，可以获取它们的相似度。详情可以看这里SimHash算法算法实现下面我们进行代码实现:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143using System;using System.Collections.Generic;using System.Linq;namespace Crawler.Common&#123; public class SimHashAnalyser &#123; private const int HashSize = 32; public static float GetLikenessValue(string needle, string haystack, TokeniserType type = TokeniserType.Overlapping) &#123; var needleSimHash = GetSimHash(needle, type); var hayStackSimHash = GetSimHash(haystack, type); return GetLikenessValue(needleSimHash, hayStackSimHash); &#125; public static float GetLikenessValue(int needleSimHash, int hayStackSimHash) &#123; return (HashSize - GetHammingDistance(needleSimHash, hayStackSimHash)) / (float)HashSize; &#125; private static IEnumerable&lt;int&gt; DoHashTokens(IEnumerable&lt;string&gt; tokens) &#123; return tokens.Select(token =&gt; token.GetHashCode()).ToList(); &#125; private static int GetHammingDistance(int firstValue, int secondValue) &#123; var hammingBits = firstValue ^ secondValue; var hammingValue = 0; for (var i = 0; i &lt; 32; i++) if (IsBitSet(hammingBits, i)) hammingValue += 1; return hammingValue; &#125; private static bool IsBitSet(int b, int pos) &#123; return (b &amp; (1 &lt;&lt; pos)) != 0; &#125; public static int GetSimHash(string input) &#123; return GetSimHash(input, TokeniserType.Overlapping); &#125; public static int GetSimHash(string input, TokeniserType tokeniserType) &#123; ITokeniser tokeniser; if (tokeniserType == TokeniserType.Overlapping) tokeniser = new OverlappingStringTokeniser(); else tokeniser = new FixedSizeStringTokeniser(); var hashedtokens = DoHashTokens(tokeniser.Tokenise(input)); var vector = new int[HashSize]; for (var i = 0; i &lt; HashSize; i++) vector[i] = 0; foreach (var value in hashedtokens) for (var j = 0; j &lt; HashSize; j++) if (IsBitSet(value, j)) vector[j] += 1; else vector[j] -= 1; var fingerprint = 0; for (var i = 0; i &lt; HashSize; i++) if (vector[i] &gt; 0) fingerprint += 1 &lt;&lt; i; return fingerprint; &#125; &#125; public interface ITokeniser &#123; IEnumerable&lt;string&gt; Tokenise(string input); &#125; public class FixedSizeStringTokeniser : ITokeniser &#123; private readonly ushort _tokensize; public FixedSizeStringTokeniser(ushort tokenSize = 5) &#123; if (tokenSize &lt; 2) throw new ArgumentException("Token 不能超出范围"); if (tokenSize &gt; 127) throw new ArgumentException("Token 不能超出范围"); _tokensize = tokenSize; &#125; public IEnumerable&lt;string&gt; Tokenise(string input) &#123; var chunks = new List&lt;string&gt;(); var offset = 0; while (offset &lt; input.Length) &#123; chunks.Add(new string(input.Skip(offset).Take(_tokensize).ToArray())); offset += _tokensize; &#125; return chunks; &#125; &#125; public class OverlappingStringTokeniser : ITokeniser &#123; private readonly ushort _chunkSize; private readonly ushort _overlapSize; public OverlappingStringTokeniser(ushort chunkSize = 4, ushort overlapSize = 3) &#123; if (chunkSize &lt;= overlapSize) throw new ArgumentException("Chunck 必须大于 overlap"); _overlapSize = overlapSize; _chunkSize = chunkSize; &#125; public IEnumerable&lt;string&gt; Tokenise(string input) &#123; var result = new List&lt;string&gt;(); var position = 0; while (position &lt; input.Length - _chunkSize) &#123; result.Add(input.Substring(position, _chunkSize)); position += _chunkSize - _overlapSize; &#125; return result; &#125; &#125; public enum TokeniserType &#123; Overlapping, FixedSize &#125;&#125;调用调用方法如下:12345678var s1 = "the cat sat on the mat.";var s2 = "the cat sat on a mat.";var similarity = SimHashAnalyser.GetLikenessValue(s1, s2);Console.Clear();Console.WriteLine("相似度: &#123;0&#125;%", similarity * 100);Console.ReadKey();输出为:相似度: 78.125%封装接下来就是对ContentSeen模块的简单封装:123456789101112131415161718192021using Crawler.Common;namespace Crawler.Processing&#123; /// &lt;summary&gt; /// 对于每一份抓取到的网页，它首先需要进入Content Seen模块。该模块会判断网页的内容是否和已下载过的某个网页的内容一致，如果一致，则该网页不会再被送去进行下一步的处理。 /// &lt;/summary&gt; public class ContentSeen &#123; public static int GetFingerPrint(string html) &#123; return SimHashAnalyser.GetSimHash(html); &#125; public static float Similarity(int print1, int print2) &#123; return SimHashAnalyser.GetLikenessValue(print1, print2); &#125; &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【爬虫学习笔记】ScrapySharp简单封装为Requester]]></title>
    <url>%2Fx%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0xScrapySharp%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85%E4%B8%BARequester.html</url>
    <content type="text"><![CDATA[为了便于使用及日后的扩展，将Scrapy简单封装为了Requester。具体代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243using System;using System.Collections.Generic;using Crawler.Common;namespace Crawler.Protocol&#123; public class Requester &#123; private Uri Url &#123; get; set; &#125; private Browser Browser &#123; get; set; &#125; public Requester(string url, Dictionary&lt;string, string&gt; headers = null, Browser browser = null) &#123; var u = new Uri(url); //检测地址是域名还是IP地址,如果是域名,则使用DnsResolver解析为IP地址 var leftPart = u.GetLeftPart(UriPartial.Authority).Replace(u.GetLeftPart(UriPartial.Scheme), ""); //正则匹配是否为IP地址 if (!RegexHelper.IsMatch(leftPart, @"\d+\.\d+\.\d+\.\d+\w")) &#123; var dns = new DnsResolver(leftPart); if (dns.IsSuccess) u = new Uri(url.Replace(leftPart, dns.Record.Address.ToString())); &#125; Url = u; Browser = browser ?? new Browser(); if (headers == null) return; foreach (var header in headers) Browser.Headers[header.Key] = header.Value; &#125; public string GetHtml() &#123; return Browser.DownloadString(Url); &#125; public byte[] GetFile() &#123; return Browser.NavigateToPage(Url).RawResponse.Body; &#125; &#125;&#125;考虑到可能对ScrapyBrowser做一些扩展（例如增加对FTP等其他协议的支持），故新建了Browser类继承自ScrapyBrowser类：123456789using ScrapySharp.Network;namespace Crawler.Protocol&#123; public class Browser : ScrapingBrowser &#123; &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>ScrapySharp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【爬虫学习笔记】DNS解析服务增加缓存机制]]></title>
    <url>%2Fx%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0xDNS%E8%A7%A3%E6%9E%90%E6%9C%8D%E5%8A%A1%E5%A2%9E%E5%8A%A0%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6.html</url>
    <content type="text"><![CDATA[之前我们已经基于ARSoft.Tools.Net简单实现了DNS解析模块的功能，但是当性能要求升高时，每一次爬取都要进行DNS请求，甚至很有可能一段时间内每次请求的都是相同的地址，频繁的DNS请求就会成为性能瓶颈，所以我们要通过缓存机制将DNS解析结果缓存下来，降低DNS解析操作，提升系统性能。如此，我们基于之前封装的MemoryCacheHelper类对DnsResolver类进行改造：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 using System;using System.Collections.Generic;using System.Diagnostics;using System.Net;using ARSoft.Tools.Net;using ARSoft.Tools.Net.Dns;using Mem = Crawler.Common.MemoryCacheHelper;namespace Crawler.Protocol&#123; public class DnsResolver &#123; public TimeSpan TimeSpan &#123; get; set; &#125; public string Url &#123; get; set; &#125; public ARecord Record &#123; get; set; &#125; public string DnsServer &#123; get; set; &#125; public int TimeOut &#123; get; set; &#125; public ReturnCode ReturnCode &#123; get; set; &#125; public bool IsSuccess &#123; get; private set; &#125; public TimeSpan TimeToLive &#123; get; set; &#125; public DnsResolver(string url, string dnsServer = "223.5.5.5", int timeOut = 10000) &#123; Url = url; DnsServer = dnsServer; TimeOut = timeOut; IsSuccess = false; if (Mem.Contains(url)) Fill(Mem.Get&lt;DnsResolver&gt;(url)); else Dig(); &#125; private void Fill(DnsResolver resolver) &#123; TimeSpan = resolver.TimeSpan; Url = resolver.Url; Record = resolver.Record; DnsServer = resolver.DnsServer; TimeOut = resolver.TimeOut; ReturnCode = resolver.ReturnCode; IsSuccess = resolver.IsSuccess; &#125; public void Dig() &#123; //初始化DnsClient，第一个参数为DNS服务器的IP，第二个参数为超时时间 var dnsClient = new DnsClient(IPAddress.Parse(DnsServer), TimeOut); var s = new Stopwatch(); s.Start(); //解析域名。将域名请求发送至DNS服务器解析，参数为需要解析的域名 var dnsMessage = dnsClient.Resolve(DomainName.Parse(Url)); s.Stop(); TimeSpan = s.Elapsed; //若返回结果为空，或者存在错误，则该请求失败。 if (dnsMessage == null || (dnsMessage.ReturnCode != ReturnCode.NoError &amp;&amp; dnsMessage.ReturnCode != ReturnCode.NxDomain)) IsSuccess = false; //循环遍历返回结果，将返回的IPV4记录添加到结果集List中。 if (dnsMessage != null) &#123; if (dnsMessage.AnswerRecords.Count &gt; 0) &#123; Record = dnsMessage.AnswerRecords[0] as ARecord; if (Record != null) &#123; IsSuccess = true; TimeToLive=new TimeSpan(0,0,Record.TimeToLive); Mem.Add(Url, this, TimeToLive); &#125; &#125; &#125; if (dnsMessage != null) ReturnCode = dnsMessage.ReturnCode; &#125; &#125;&#125;这样,每次做完DNS解析后，会根据域名的TTL将解析结果缓存下来，下次查询时可以直接调用缓存，提高系统性能。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【爬虫学习笔记】MemoryCache缓存的用法学习]]></title>
    <url>%2Fx%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0xMemoryCache%E7%BC%93%E5%AD%98%E7%9A%84%E7%94%A8%E6%B3%95%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[在完成了DNS解析模块之后，我意识到了DNS缓存机制也很有必要。在Redis，Memcache，和.Net自带的Cache之间,考虑到部署问题，最终选择了后者，之前在学习Web及开发的过程中用过System.Web.Caching.Cache这个类库，但是这次的爬虫程序我打算部署为桌面软件，所以选用了System.Runtime.Caching.MemoryCache（后期如有必要也会加入System.Web.Caching.Cache来适配Web端程序）。MemoryCache的使用网上介绍的不多，不过这个是.NET4.0新引入的缓存对象，估计主要是替换原来企业库的缓存模块，使得.NET的缓存可以无处不在，而不用基于特定的Windows版本上使用。出于方便考虑，我们将不再实例化新的MemoryCache对象，只对MemoryCache的默认示例Memory.Default进行增删查操作。基础操作增加增加缓存需要提供两个参数，CacheItem类表示缓存中的单个缓存项,构造函数:CacheItem(String, Object, String) 用缓存项的指定键、值和区域初始化新的 CacheItem 实例。三个参数分别为：键、值和区域。CacheItemPolicy类则表示缓存项的过期信息，只含有默认的构造函数。增加一条缓存：1234567891011var item = new CacheItem("习大大", "两学一做");var policy = new CacheItemPolicy();policy.SlidingExpiration = new TimeSpan(500);//插入一条key为"习大大",value为"两学一做",500毫秒后自动销毁的缓存MemoryCache.Default.Add(item, policy);//重新设置policy的过期时间为当前时间+十分钟policy.AbsoluteExpiration = DateTimeOffset.Now + TimeSpan.FromMinutes(10);//注意,如果要使用Sliding时间,则Absolute必须为DateTimeOffset.MaxValue,反之,则Sliding必须为TimeSpan.Zeropolicy.SlidingExpiration = TimeSpan.Zero;//重新插入,覆盖前一条数据MemoryCache.Default.Add(item, policy);注意,如果要使用Sliding时间,则Absolute必须为DateTimeOffset.MaxValue,反之,则Sliding必须为TimeSpan.Zero查询缓存对象类似于字典集,查询可以直接采用memoryCache[key]来进行,例如我们查询一下前面插入的那条数据:1var idea = MemoryCache.Default["习大大"];移除参数key:要移除的缓存项的唯一标识符。regionName:缓存中的一个添加了缓存项的命名区域。不要为该参数传递值。默认情况下，此参数为null，因为 MemoryCache 类未实现区域。返回值Type: System.Object 如果在缓存中找到该项，则为已移除的缓存项；否则为 null。删除前面加入的那一项:1MemoryCache.Default.Remove("习大大");进一步封装明白了基本的用法之后，我们就可以对它做进一步的封装，使之使用起来更为便捷：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112using System;using System.Collections.Generic;using System.Linq;using System.Runtime.Caching;namespace Crawler.Common&#123; /// &lt;summary&gt; /// 基于MemoryCache的缓存辅助类 /// &lt;/summary&gt; public static class MemoryCacheHelper &#123; private static readonly object _locker = new object(); public static bool Contains(string key) &#123; return MemoryCache.Default.Contains(key); &#125; /// &lt;summary&gt; /// 获取Catch元素 /// &lt;/summary&gt; /// &lt;typeparam name="T"&gt;所获取的元素的类型&lt;/typeparam&gt; /// &lt;param name="key"&gt;元素的键&lt;/param&gt; /// &lt;returns&gt;特定的元素值&lt;/returns&gt; public static T Get&lt;T&gt;(string key) &#123; if (string.IsNullOrWhiteSpace(key)) throw new ArgumentException("不合法的key!"); if (!MemoryCache.Default.Contains(key)) throw new ArgumentException("获取失败,不存在该key!"); if (!(MemoryCache.Default[key] is T)) throw new ArgumentException("未找到所需类型数据!"); return (T)MemoryCache.Default[key]; &#125; /// &lt;summary&gt; /// 添加Catch元素 /// &lt;/summary&gt; /// &lt;param name="key"&gt;元素的键&lt;/param&gt; /// &lt;param name="value"&gt;元素的值&lt;/param&gt; /// &lt;param name="slidingExpiration"&gt;元素过期时间(时间间隔)&lt;/param&gt; /// &lt;param name="absoluteExpiration"&gt;元素过期时间(绝对时间)&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool Add(string key, object value, TimeSpan? slidingExpiration = null, DateTime? absoluteExpiration = null) &#123; var item = new CacheItem(key, value); var policy = CreatePolicy(slidingExpiration, absoluteExpiration); lock (_locker) return MemoryCache.Default.Add(item, policy); &#125; /// &lt;summary&gt; /// 移出Cache元素 /// &lt;/summary&gt; /// &lt;typeparam name="T"&gt;待移出元素的类型&lt;/typeparam&gt; /// &lt;param name="key"&gt;待移除元素的键&lt;/param&gt; /// &lt;returns&gt;已经移出的元素&lt;/returns&gt; public static T Remove&lt;T&gt;(string key) &#123; if (string.IsNullOrWhiteSpace(key)) throw new ArgumentException("不合法的key!"); if (!MemoryCache.Default.Contains(key)) throw new ArgumentException("获取失败,不存在该key!"); var value = MemoryCache.Default.Get(key); if (!(value is T)) throw new ArgumentException("未找到所需类型数据!"); return (T)MemoryCache.Default.Remove(key); &#125; /// &lt;summary&gt; /// 移出多条缓存数据,默认为所有缓存 /// &lt;/summary&gt; /// &lt;typeparam name="T"&gt;待移出的缓存类型&lt;/typeparam&gt; /// &lt;param name="keyList"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static List&lt;T&gt; RemoveAll&lt;T&gt;(IEnumerable&lt;string&gt; keyList = null) &#123; if (keyList != null) return (from key in keyList where MemoryCache.Default.Contains(key) where MemoryCache.Default.Get(key) is T select (T)MemoryCache.Default.Remove(key)).ToList(); while (MemoryCache.Default.GetCount() &gt; 0) MemoryCache.Default.Remove(MemoryCache.Default.ElementAt(0).Key); return new List&lt;T&gt;(); &#125; /// &lt;summary&gt; /// 设置过期信息 /// &lt;/summary&gt; /// &lt;param name="slidingExpiration"&gt;&lt;/param&gt; /// &lt;param name="absoluteExpiration"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private static CacheItemPolicy CreatePolicy(TimeSpan? slidingExpiration, DateTime? absoluteExpiration) &#123; var policy = new CacheItemPolicy(); if (absoluteExpiration.HasValue) &#123; policy.AbsoluteExpiration = absoluteExpiration.Value; &#125; else if (slidingExpiration.HasValue) &#123; policy.SlidingExpiration = slidingExpiration.Value; &#125; policy.Priority = CacheItemPriority.Default; return policy; &#125; &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【爬虫学习笔记】.Net 基于ARSoft.Tools.Net的DNS解析模块（半成品）]]></title>
    <url>%2Fx%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0xCx%E5%9F%BA%E4%BA%8EARSoft.Tools.Net%E7%9A%84DNS%E8%A7%A3%E6%9E%90%E6%A8%A1%E5%9D%97%EF%BC%88%E5%8D%8A%E6%88%90%E5%93%81%EF%BC%89.html</url>
    <content type="text"><![CDATA[最近在做爬虫的作业，今天学习的内容是关于DNS解析模块的制作的。使用的库为ARSoft.Tools.Net，它是一个非常强大的开源DNS控件库，包含.Net SPF validation, SenderID validation以及DNS Client、DNS Server接口。使用该接口可轻松实现DNS客户请求端及服务器解析端。项目地址：http://arsofttoolsnet.codeplex.com/，Nuget包地址：https://www.nuget.org/packages/ARSoft.Tools.Net/。引入首先引入nuget包:Install-Package ARSoft.Tools.NetInstall-Package ARSoft.Tools.Net具体实现实现代码:12345678910111213141516171819202122232425262728293031323334353637/// &lt;summary&gt;/// DNS解析/// &lt;/summary&gt;/// &lt;param name="dnsServer"&gt;DNS服务器IP&lt;/param&gt;/// &lt;param name="timeOut"&gt;解析超时时间&lt;/param&gt;/// &lt;param name="url"&gt;解析网址&lt;/param&gt;/// &lt;param name="isSuccess"&gt;是否解析成功&lt;/param&gt;/// &lt;returns&gt;解析到的IP信息&lt;/returns&gt;public static IPAddress DnsResolver(string dnsServer, int timeOut, string url, out bool isSuccess)&#123; //初始化DnsClient，第一个参数为DNS服务器的IP，第二个参数为超时时间 var dnsClient = new DnsClient(IPAddress.Parse(dnsServer), timeOut); //解析域名。将域名请求发送至DNS服务器解析，第一个参数为需要解析的域名，第二个参数为 //解析类型， RecordType.A为IPV4类型 //DnsMessage dnsMessage = dnsClient.Resolve("www.sina.com", RecordType.A); var s = new Stopwatch(); s.Start(); var dnsMessage = dnsClient.Resolve(DomainName.Parse(url)); s.Stop(); Console.WriteLine(s.Elapsed.Milliseconds); //若返回结果为空，或者存在错误，则该请求失败。 if (dnsMessage == null || (dnsMessage.ReturnCode != ReturnCode.NoError &amp;&amp; dnsMessage.ReturnCode != ReturnCode.NxDomain)) &#123; isSuccess= false; &#125; //循环遍历返回结果，将返回的IPV4记录添加到结果集List中。 if (dnsMessage != null) foreach (var dnsRecord in dnsMessage.AnswerRecords) &#123; var aRecord = dnsRecord as ARecord; if (aRecord == null) continue; isSuccess = true; return aRecord.Address; &#125; isSuccess= false; return null;&#125;调用代码1234bool isSuccess;IPAddress ip = DnsResolver("223.5.5.5", 200, "shaoweicloud.cn", out isSuccess);if (isSuccess) Console.WriteLine(ip);进一步封装懂的使用方法后我们可以对它做进一步封装,得到DnsResolver类:实现代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253using System;using System.Collections.Generic;using System.Diagnostics;using System.Net;using ARSoft.Tools.Net;using ARSoft.Tools.Net.Dns;namespace Crawler.Protocol&#123; public class DnsResolver &#123; public TimeSpan TimeSpan &#123; get; set; &#125; public string Url &#123; get; set; &#125; public List Record &#123; get; set; &#125; public string DnsServer &#123; get; set; &#125; public int TimeOut &#123; get; set; &#125; public ReturnCode ReturnCode &#123; get; set; &#125; public bool IsSuccess &#123; get; private set; &#125; public DnsResolver(string url, string dnsServer = "223.5.5.5", int timeOut = 200) &#123; Url = url; DnsServer = dnsServer; TimeOut = timeOut; Record=new List(); Dig(); &#125; public void Dig() &#123; //初始化DnsClient，第一个参数为DNS服务器的IP，第二个参数为超时时间 var dnsClient = new DnsClient(IPAddress.Parse(DnsServer), TimeOut); var s = new Stopwatch(); s.Start(); //解析域名。将域名请求发送至DNS服务器解析，参数为需要解析的域名 var dnsMessage = dnsClient.Resolve(DomainName.Parse(Url)); s.Stop(); TimeSpan = s.Elapsed; //若返回结果为空，或者存在错误，则该请求失败。 if (dnsMessage == null || (dnsMessage.ReturnCode != ReturnCode.NoError &amp;&amp; dnsMessage.ReturnCode != ReturnCode.NxDomain)) IsSuccess = false; //循环遍历返回结果，将返回的IPV4记录添加到结果集List中。 if (dnsMessage != null) foreach (var dnsRecord in dnsMessage.AnswerRecords) &#123; var aRecord = dnsRecord as ARecord; if (aRecord == null) continue; IsSuccess = true; Record.Add(aRecord); &#125; if (dnsMessage != null) ReturnCode = dnsMessage.ReturnCode; &#125; &#125;&#125;调用方法123DnsResolver dns = new DnsResolver("shaoweicloud.cn");if (dns.IsSuccess) Console.WriteLine(dns.Record[0]);结束至此，DNS解析模块就基本结束了，至于为什么标题中标注了半成品，是因为我想在基本的DNS解析功能的基础上根据解析到DNS信息中的TTL做一套信息缓存机制，减少不必要的重复查询，目前还在考虑使用何种方法，后续实现会更新。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>爬虫</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【爬虫学习笔记】.Net 使用 ScrapySharp 并行下载天涯图片]]></title>
    <url>%2Fx%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0xCx-%E4%BD%BF%E7%94%A8-ScrapySharp-%E5%B9%B6%E8%A1%8C%E4%B8%8B%E8%BD%BD%E5%A4%A9%E6%B6%AF%E5%9B%BE%E7%89%87.html</url>
    <content type="text"><![CDATA[最近因为一个作业需要完成CNKI爬虫，研究爬虫架构的时候发现了这个疑似移植于Python的著名开源爬虫框架Scrapy的ScrapySharp，然而在网上寻找之后只发现了这个F#的Demo，就使用原文中示例的网站写了这个C#版本的代码。实现下面是代码:123456789101112131415161718192021222324252627282930313233343536373839using System;using System.IO;using System.Linq;using System.Threading.Tasks;using HtmlAgilityPack;using ScrapySharp.Extensions;using ScrapySharp.Network;namespace ScrapySharpDemo&#123; class Program &#123; static void Main(string[] args) &#123; //示例网站地址 var url = "http://bbs.tianya.cn/post-12-563201-1.shtml"; var web = new ScrapingBrowser(); var html = web.DownloadString(new Uri(url)); var doc = new HtmlDocument(); doc.LoadHtml(html); //获取网站中的图片地址 var urls= doc.DocumentNode.CssSelect("div.bbs-content &gt; img").Select(node =&gt; node.GetAttributeValue("original")).ToList(); //并行下载图片 Parallel.ForEach(urls, SavePic); &#125; public static void SavePic(string url) &#123; var web = new ScrapingBrowser(); //因天涯网站限制,所有站外来源都无法访问图片,故先设置请求头Refer属性为当前页地址 web.Headers.Add("Referer", "http://bbs.tianya.cn/post-12-563201-1.shtml"); var pic = web.NavigateToPage(new Uri(url)).RawResponse.Body; var file = url.Substring(url.LastIndexOf("/", StringComparison.Ordinal)); if (!Directory.Exists("imgs")) Directory.CreateDirectory("imgs"); File.WriteAllBytes("imgs" + file, pic); &#125; &#125;&#125;结论:研究之后发现，ScrapySharp和Scrapy差距还是挺大的，没有Scrapy那样完善的八大组件，只含有Http请求的Downloader和基于HtmlAgilityPack扩展的网页解析功能，莫名有些小失望。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>爬虫</tag>
        <tag>ScrapySharp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一木禾网盘文件下载地址批量获取实现]]></title>
    <url>%2F%E4%B8%80%E6%9C%A8%E7%A6%BE%E7%BD%91%E7%9B%98%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80%E6%89%B9%E9%87%8F%E8%8E%B7%E5%8F%96%E5%AE%9E%E7%8E%B0.html</url>
    <content type="text"><![CDATA[流程清晰之后，我们就可以制作软件来对网盘地址链接批量处理得到下载链接。选型我们的整个操作流程类似模拟浏览器操作，最好的解决方法其实是使用Selenium直接操作浏览器抓取。不过这方面我还没什么研究，就直接用最近发现的木鱼大牛的 FSLib.Network 库来实现。这个类库是实现了HTTP访问过程中对Cookie的自动处理，在大多数情况下都可以模拟浏览器。使用nuget在项目中安装 FSLib.Network 包:Install-Package network.fishlee.net获取流程实现下面来依据流程完成通过页面地址来获得文件下载连接的方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768private async void GetDownLoadUrl(string fileUrl)&#123; //建立HTTP客户端 var client = new HttpClient(); //用于接收验证码 StringBuilder Result; //验证码的字符数组 byte[] bytes; //用于接收下载链接 string downPath = string.Empty; //通过正则匹配到链接中的 fileid int id = Convert.ToInt32(Extract(fileUrl, "\\d&#123;7,&#125;")); //有时会出现一级域名为ymhwp的情况，这里先做一下替换，以防不测 fileUrl = fileUrl.Replace("ymhwp", "yimuhe"); //创建展示页面请求 var filecontext = client.Create&lt;string&gt;(HttpMethod.Get, fileUrl); //发送请求 await filecontext.SendTask(); if (filecontext.IsValid())//如果请求成功 &#123; //替换链接中的fil为down，使其成为下载页面地址 fileUrl = fileUrl.Replace("file", "down"); //创建下载页面请求 var downcontext = client.Create&lt;string&gt;(HttpMethod.Get, fileUrl); await downcontext.SendTask(); if (downcontext.IsValid()) &#123; //设置初始返回值为0，表示验证码输入错误，即识别失败 int response = 0; while (response == 0)//循环识别，直到识别成功 &#123; //创建验证码图片请求 var vcode = client.Create&lt;Byte[]&gt;(HttpMethod.Get, "http://www.yimuhe.com/n_downcode.php"); await vcode.SendTask(); if (vcode.IsValid()) &#123; //将获取到的验证码图片存入字节数组中 bytes = vcode.Result; Result = new StringBuilder('\0', 256); //识别验证码 GetVcodeFromBuffer(1, bytes, bytes.Length, Result); //创建检验验证码请求 var resp = client.Create&lt;string&gt;(HttpMethod.Post, "http://www.yimuhe.com/n_downcode.php", data: "action=yz&amp;id=" + id + "&amp;code=" + Result); await resp.SendTask(); if (resp.IsValid()) &#123; //返回验证码校验值、成功为1失败为0 response = Convert.ToInt32(resp.Result); &#125; &#125; &#125; //创建获取下载地址请求 var h1 = client.Create&lt;string&gt;(HttpMethod.Post, "http://www.yimuhe.com/n_dd.php?file_id=" + id + "&amp;ser=99", refer: "http://www.yimuhe.com/down-2546737.html", data: id.ToString()); await h1.SendTask(); if (h1.IsValid()) &#123; //通过HtmlAgilityPack库完成html解析，获得下载地址 HtmlDocument html = new HtmlDocument(); html.LoadHtml(h1.Result); downPath = html.GetElementbyId("downs").Attributes["href"].Value; tBAfter.AppendText(downPath + NewLine); &#125; &#125; &#125;&#125;批量获取实现我的批量实现思路为将要获取的链接加入一个队列当中，线程从队头移出数据一条进行地址获取，获取成功不进行操作，失败则将地址添回到队尾。循环获取直到队列为空。另一个队列储存正在处理的数据，仅当两个线程均为空时才会陆续结束所有线程。线程执行的方法在上边的方法基础上又做了一些修改。具体实现代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889private async void GetDownLoadUrl()&#123; //当链接队列和正在处理队列存在不为空时，循环执行以下代码 while (_pathList.Count &gt; 0 || _pathReady.Count &gt; 0) &#123; //当链接队列不为空时 if (_pathList.Count &gt; 0) &#123; //从队头取出一条数据 string fileUrl = _pathList[0]; _pathList.RemoveAt(0); _pathReady.Add(fileUrl); //建立HTTP客户端 var client = new HttpClient(); //用于接收验证码 StringBuilder Result; //验证码的字符数组 byte[] bytes; //用于接收下载链接 string downPath = string.Empty; //通过正则匹配到链接中的 fileid int id = Convert.ToInt32(Extract(fileUrl, "\\d&#123;7,&#125;")); //有时会出现一级域名为ymhwp的情况，这里先做一下替换，以防不测 fileUrl = fileUrl.Replace("ymhwp", "yimuhe"); //创建展示页面请求 var filecontext = client.Create&lt;string&gt;(HttpMethod.Get, fileUrl); //发送请求 await filecontext.SendTask(); if (filecontext.IsValid())//如果请求成功 &#123; //替换链接中的fil为down，使其成为下载页面地址 fileUrl = fileUrl.Replace("file", "down"); //创建下载页面请求 var downcontext = client.Create&lt;string&gt;(HttpMethod.Get, fileUrl); await downcontext.SendTask(); if (downcontext.IsValid()) &#123; //设置初始返回值为0，表示验证码输入错误，即识别失败 int response = 0; while (response == 0)//循环识别，直到识别成功 &#123; //创建验证码图片请求 var vcode = client.Create&lt;Byte[]&gt;(HttpMethod.Get, "http://www.yimuhe.com/n_downcode.php"); await vcode.SendTask(); if (vcode.IsValid()) &#123; //将获取到的验证码图片存入字节数组中 bytes = vcode.Result; Result = new StringBuilder('\0', 256); //识别验证码 GetVcodeFromBuffer(1, bytes, bytes.Length, Result); //创建检验验证码请求 var resp = client.Create&lt;string&gt;(HttpMethod.Post, "http://www.yimuhe.com/n_downcode.php", data: "action=yz&amp;id=" + id + "&amp;code=" + Result); await resp.SendTask(); if (resp.IsValid()) &#123; //返回验证码校验值、成功为1失败为0 response = Convert.ToInt32(resp.Result); &#125; &#125; &#125; //创建获取下载地址请求 var h1 = client.Create&lt;string&gt;(HttpMethod.Post, "http://www.yimuhe.com/n_dd.php?file_id=" + id + "&amp;ser=99", refer: "http://www.yimuhe.com/down-2546737.html", data: id.ToString()); await h1.SendTask(); if (h1.IsValid()) &#123; //通过HtmlAgilityPack库完成html解析，获得下载地址 HtmlDocument html = new HtmlDocument(); html.LoadHtml(h1.Result); downPath = html.GetElementbyId("downs").Attributes["href"].Value; //将获取到的地址显示到界面 tBAfter.AppendText(downPath + NewLine); &#125; &#125; &#125; //如果downPath为空，则请求失败 if (string.IsNullOrWhiteSpace(downPath)) &#123; //将请求链接添回队尾 _pathList.Add(path); &#125; //处理完毕，移出当前处理队列 _pathReady.Remove(path); &#125; &#125;&#125;结束本文旨在抛砖引玉，因为一些都懂得的原因，就不给出成品的下载地址了，有需要的童鞋可以自行完成。]]></content>
      <categories>
        <category>踩坑笔记</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一木禾网盘文件下载地址抓取分析]]></title>
    <url>%2F%E4%B8%80%E6%9C%A8%E7%A6%BE%E7%BD%91%E7%9B%98%E4%B8%8B%E8%BD%BD%E5%88%86%E6%9E%90%E5%8F%8A%E6%89%B9%E9%87%8F%E8%8E%B7%E5%8F%96%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%8A%EF%BC%89.html</url>
    <content type="text"><![CDATA[本文是对抓取一木禾网盘文件下载地址的整个流程就行分析，并依次解决其中各个环节涉及的技术问题。缘由最近因为一些个人原因用到了一木禾网盘，这个收费网盘虽然较一些国外的倒数30秒网盘容易了一些，也没有十分钟只能下载一个的限制，但如果下载资源较多还是显得十分麻烦。网上搜索了很长时间，功夫不负有心认，终于在吾爱破解找到了 cylisme 作品 一木禾网盘批量下载 。软件界面如下：虽然可以进行使用，但是每一个验证码都必须手动输入，就起了自己制作一个网盘批量下载器的想法 。我本人只是一个C#初学者，言辞中有不正确的请指出，若文中内容侵犯了您的权益，请联系删除。流程分析网页端获取下载地址流程分析：使用Chrome的开发人员工具得到了以下流程由上图可知，关键性技术问题为验证码识别验证码识别一木禾的验证码是杂色点比较多的四位数字，如下图：尝试过几次自行去杂色点识别数字，但是因为个人对图形处理方面的知识十分有限，均以失败告终，最终使用了次世代验证码识别系统2.3来完成验证码识别，系统支持C#调用，经过几次调教之后已经能对一木禾验证码有不错的识别率。以下是软件界面:本篇主要进行一些理论分析，下篇做具体代码实现。]]></content>
      <categories>
        <category>踩坑笔记</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# TextBox Ctrl+A全选]]></title>
    <url>%2FCx-TextBox-Ctrl%2BA%E5%85%A8%E9%80%89.html</url>
    <content type="text"><![CDATA[Winform程序中光标在TextBox控件中时按下 Ctrl + A 快捷键，并不能选中全部文字，而是会发出警告音。本文给出实现方法。在TextBox控件中使用快捷键，一般要求按下快捷键立刻产生效果，KeyUp事件显然不符合我们的要求，而KeyPress事件中不支持使用组合件，所以我们选用KeyDown事件，具体代码实现如下：1234567private void tBBefore_KeyDown(object sender, KeyEventArgs e)&#123; if (e.Control &amp;&amp; e.KeyCode == Keys.A) &#123; ((TextBox)sender).SelectAll(); &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Winform</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#激爽特性——扩展方法]]></title>
    <url>%2FCx%E6%BF%80%E7%88%BD%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[在最近的学习中，发现了一种用起来特别爽的C#特性——扩展方法，之前拜读《大话设计模式》一书的时候，书中提到这样一句话：“反射，反射，程序员的快乐”，本人菜鸟一只，到现在还未曾使用过反射，对于其是否真的快乐自然无从体会，不过扩展方法用起来称得上是相当快乐！简介下面是MSDN中对于扩展方法的解释扩展方法使你能够向现有类型”添加“方法,而无需创建新的派生类型、重新编译或以其他方法修改原始类型。扩展方法是一种特殊的静态方法，但可以像扩展类型上的实力方法一样进行调用。对于C#和Visual Basic 编写的客户端代码，调用扩展方法与调用在类型中实际定义的方法之间没有明显的差异。刚开始学习C#的时候,经常碰到各种需要状态转换的场合,那个时候代码里常常是大坨大坨的Convert.ToXX();当时非常羡慕String类可以直接调用ToString方法,省时省力,代码看起来还特别美观,之后学会了把Convert.ToXX()打包到一个方法里,代码不那么冗余了,但还是不甚美观,且费时费力,直到今天,我发现了C#中这个让人激爽无比的特性,这件事情终于有了完美的解决方案!语法下面来看一下基本的语法:1234public static 返回类型 方法名(this 需要添加扩展方法的类名 变量名,,,)&#123; return;&#125;实现首先我们写这样一个类:12345678910namespace ExtensionMethods&#123; public static class ExtensionMethods &#123; public static int ToInt(this string s) &#123; return Convert.ToInt32(s); &#125; &#125;&#125;然后只需要在另一个类中引用这个类的命名空间，就可以方便地使用我们写好的扩展方法进行类型转换了:1234567891011using ExtensionMethods;namespace xxx&#123; public static class xxxx &#123; public static int Test() &#123; int i = "123".ToInt(); &#125; &#125;&#125;怎么样？是不是感觉一股凉气当头灌下——真爽啊！别急，光这样怎么能够满足我们的需求呢，接下来我们继续优化。优化以上已经方便了不少，但还是有以下两个问题：每次还需要引用命名空间，太浪费时间精力。解决方案：将扩展方法直接放到类型所在的命名空间下依旧以上面的代码为例，就是：12345678910namespace System&#123; public static class ExtensionMethods &#123; public static int ToInt(this string s) &#123; return Convert.ToInt32(s); &#125; &#125;&#125;如果输入的String并不能转化为数字,会报错。解决方案：加入另一个参数为默认值，若不能转化成功，则返回默认值。代码如下:12345public static int ToInt32(this string s, int def = default(int))&#123; int result; return Int32.TryParse(s, out result) ? result : def;&#125;按照上面的思路,我们可以打包一个包含各种常用类型转换的类,写程序的时候只要直接加入这个类,就可以方便地进行各种进制转换了.下面提供一个自用的Convert类Convert.zip]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>特性</tag>
        <tag>扩展方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#线性筛法快速求出范围内的所有质数]]></title>
    <url>%2FCx%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%B3%95%E6%B1%82%E5%87%BA%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E6%89%80%E6%9C%89%E8%B4%A8%E6%95%B0.html</url>
    <content type="text"><![CDATA[质数是指在大于1的自然数中，除了1和它本身以外不再有其他因数的数。本文列举了几种求区间内所有质数的算法。一般方法验证质数我们根据质数的定义可以对某一自然数进行检测，方法如下：123456789101112131415161718/// &lt;summary&gt;/// 判断自然数是否是质数/// &lt;/summary&gt;/// &lt;param name="n"&gt;需要判断的数&lt;/param&gt;/// &lt;returns&gt;是/否&lt;/returns&gt;public static bool IsPrime(int n)&#123; if (n &lt; 2) return false; for (var i = n - 1; i &gt; 1; i--) &#123; //n除以每个比n小比1大的自然数 if (n % i == 0) //如果有能被整除的，则不是质数 return false; &#125; //否则则为质数 return true;&#125;获取范围内质数123456789101112/// &lt;summary&gt;/// 获取自然数区间内的所有质数/// &lt;/summary&gt;/// &lt;param name="startInt"&gt;自然数区间起始点&lt;/param&gt;/// &lt;param name="endInt"&gt;自然数区间终点&lt;/param&gt;/// &lt;returns&gt;自然数区间内的所有质数的集合&lt;/returns&gt;public static IEnumerable&lt;int&gt; GetPrimes(int startInt, int endInt)&#123; for (var i = startInt; i &lt;= endInt; i++) if (IsPrime(i)) yield return i;&#125;筛法什么是筛法科普篇:筛法是一种简单检定质数的算法。据说是古希腊的埃拉托斯特尼（Eratosthenes）发明的，又称埃拉托斯特尼筛法（sieve of Eratosthenes）.使用筛法求某上限内所有质数12345678910111213141516/// &lt;summary&gt;/// 求某上限内的所有质数/// &lt;/summary&gt;/// &lt;param name="j"&gt;上限自然数&lt;/param&gt;/// &lt;returns&gt;上限内所有质数&lt;/returns&gt;public static IEnumerable&lt;int&gt; GenPrime(int j)&#123; var bts = new BitArray(j + 1); for (var x = 2; x &lt; bts.Length / 2; x++) for (var y = x + 1; y &lt; bts.Length; y++) if (bts[y] == false &amp;&amp; y % x == 0) bts[y] = true; for (var x = 2; x &lt; bts.Length; x++) if (bts[x] == false) yield return x;&#125;使用筛法求某自然数区间内所有质数使用两次上面的方法分别求取区间起始点和终点作为上限的所有质数后取差集12345678/// &lt;summary&gt;/// 获取自然数区间内的所有质数/// &lt;/summary&gt;/// &lt;param name="startInt"&gt;自然数区间起始点&lt;/param&gt;/// &lt;param name="endInt"&gt;自然数区间终点&lt;/param&gt;/// &lt;returns&gt;自然数区间内的所有质数的集合&lt;/returns&gt;public static IEnumerable&lt;int&gt; GenPrimes(int startInt, int endInt) =&gt; GenPrime(endInt).Except(GenPrime(startInt));快速线性筛法实现在某位高手的博文中发现了复杂度更低的线性筛法一般筛法求素数+快速线性筛法求素数下面是C#的实现12345678910111213141516171819202122232425/// &lt;summary&gt;/// 求某上限内的所有质数/// &lt;/summary&gt;/// &lt;param name="x"&gt;上限自然数&lt;/param&gt;/// &lt;returns&gt;上限内所有质数&lt;/returns&gt;private static IEnumerable&lt;int&gt; LinearGenPrime(int x)&#123; var numPrime = 0; var ints = new List&lt;int&gt;(); var isNotPrime = new BitArray(x); for (var i = 2; i &lt; x; i++) &#123; if (!isNotPrime[i]) &#123; yield return i; numPrime++; &#125; for (var j = 0; j &lt; numPrime &amp;&amp; i * ints[j] &lt; x; j++) &#123; isNotPrime[i * ints[j]] = true; if (!Convert.ToBoolean(i % ints[j])) break; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>质数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新手正式入驻博客园]]></title>
    <url>%2F%E6%96%B0%E6%89%8B%E6%AD%A3%E5%BC%8F%E5%85%A5%E9%A9%BB%E5%8D%9A%E5%AE%A2%E5%9B%AD.html</url>
    <content type="text"><![CDATA[本人是计算机专业大二狗一枚，目前在学习C#，今天突发奇想，打算开一个博客，定期记录一些自己学习期间的心得，希望各位大牛能多多提点。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
</search>
